; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\SphereLib\sphere.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_sqrtf
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0Vector3d@@QAE@XZ				; Vector3d::Vector3d
PUBLIC	??0Vector3d@@QAE@ABV0@@Z			; Vector3d::Vector3d
PUBLIC	??0Vector3d@@QAE@MMM@Z				; Vector3d::Vector3d
PUBLIC	??4Vector3d@@QAEAAV0@ABV0@@Z			; Vector3d::operator=
PUBLIC	??HVector3d@@QBE?AV0@ABV0@@Z			; Vector3d::operator+
PUBLIC	??GVector3d@@QBE?AV0@ABV0@@Z			; Vector3d::operator-
PUBLIC	??DVector3d@@QBE?AV0@M@Z			; Vector3d::operator*
PUBLIC	??XVector3d@@QAEXM@Z				; Vector3d::operator*=
PUBLIC	?GetX@Vector3d@@QBEMXZ				; Vector3d::GetX
PUBLIC	?GetY@Vector3d@@QBEMXZ				; Vector3d::GetY
PUBLIC	?GetZ@Vector3d@@QBEMXZ				; Vector3d::GetZ
PUBLIC	?SetX@Vector3d@@QAEXM@Z				; Vector3d::SetX
PUBLIC	?SetY@Vector3d@@QAEXM@Z				; Vector3d::SetY
PUBLIC	?SetZ@Vector3d@@QAEXM@Z				; Vector3d::SetZ
PUBLIC	?Set@Vector3d@@QAEXMMM@Z			; Vector3d::Set
PUBLIC	?Length2@Vector3d@@QBEMXZ			; Vector3d::Length2
PUBLIC	?DistanceSq@Vector3d@@QBEMABV1@@Z		; Vector3d::DistanceSq
PUBLIC	?Dot@Vector3d@@QBEMABV1@@Z			; Vector3d::Dot
PUBLIC	?IsInStaticRange@Vector3d@@QBE_NXZ		; Vector3d::IsInStaticRange
PUBLIC	?Set@Sphere@@QAEXABVVector3d@@M@Z		; Sphere::Set
PUBLIC	?Compute@Sphere@@QAEXABVSphereInterface@@@Z	; Sphere::Compute
PUBLIC	?RayIntersection@Sphere@@QAE_NABVVector3d@@0MPAV2@@Z ; Sphere::RayIntersection
PUBLIC	?RayIntersection@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ; Sphere::RayIntersection
PUBLIC	?RayIntersectionInFront@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ; Sphere::RayIntersectionInFront
PUBLIC	?Report@Sphere@@QAEXXZ				; Sphere::Report
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@4a47fe70
PUBLIC	__real@4cbebc20
PUBLIC	__real@bf800000
PUBLIC	__real@ca47fe70
PUBLIC	__real@ccbebc20
EXTRN	_sqrt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@ccbebc20
CONST	SEGMENT
__real@ccbebc20 DD 0ccbebc20r			; -1e+008
CONST	ENDS
;	COMDAT __real@ca47fe70
CONST	SEGMENT
__real@ca47fe70 DD 0ca47fe70r			; -3.2767e+006
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@4cbebc20
CONST	SEGMENT
__real@4cbebc20 DD 04cbebc20r			; 1e+008
CONST	ENDS
;	COMDAT __real@4a47fe70
CONST	SEGMENT
__real@4a47fe70 DD 04a47fe70r			; 3.2767e+006
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?Report@Sphere@@QAEXXZ
_TEXT	SEGMENT
?Report@Sphere@@QAEXXZ PROC				; Sphere::Report, COMDAT
; _this$ = ecx

; 128  : }

  00000	c3		 ret	 0
?Report@Sphere@@QAEXXZ ENDP				; Sphere::Report
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?RayIntersectionInFront@Sphere@@QAE_NABVVector3d@@0PAV2@@Z
_TEXT	SEGMENT
_sect$ = -12						; size = 12
_rayOrigin$ = 8						; size = 4
_V$ = 12						; size = 4
_intersect$ = 16					; size = 4
?RayIntersectionInFront@Sphere@@QAE_NABVVector3d@@0PAV2@@Z PROC ; Sphere::RayIntersectionInFront, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 107  :   Vector3d sect;
; 108  :   bool hit = RayIntersection(rayOrigin,V,&sect);

  00006	8d 45 f4	 lea	 eax, DWORD PTR _sect$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _V$[ebp]
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _rayOrigin$[ebp]
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ?RayIntersection@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ; Sphere::RayIntersection

; 109  : 
; 110  :   if ( hit )

  00019	84 c0		 test	 al, al
  0001b	74 70		 je	 SHORT $LN2@RayInterse
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  0001d	f3 0f 10 6d f8	 movss	 xmm5, DWORD PTR _sect$[ebp+4]
  00022	f3 0f 10 65 f4	 movss	 xmm4, DWORD PTR _sect$[ebp]
  00027	0f 28 c5	 movaps	 xmm0, xmm5
  0002a	f3 0f 5c 47 04	 subss	 xmm0, DWORD PTR [edi+4]

; 66   : 	return(Diff); };
; 67   : 	
; 68   :     Vector3d operator * (const float s) const       // MULTIPLY BY SCALAR (*)
; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);
; 70   : 	return(Scaled); };
; 71   : 	
; 72   :     Vector3d operator / (const float s) const       // DIVIDE BY SCALAR (/)
; 73   :     { 
; 74   : 		float r = 1.0f / s;
; 75   :         Vector3d Scaled(x*r, y*r, z*r);
; 76   :         return(Scaled); 
; 77   :     };
; 78   : 	
; 79   :     void operator += (const Vector3d A)             // ACCUMULATED VECTOR ADDITION (+=)
; 80   : 	{ x+=A.x; y+=A.y; z+=A.z; };
; 81   :     void operator -= (const Vector3d A)             // ACCUMULATED VECTOR SUBTRACTION (+=)
; 82   : 	{ x-=A.x; y-=A.y; z-=A.z; };
; 83   :     void operator *= (const float s)        // ACCUMULATED SCALAR MULTIPLICATION (*=) (bpc 4/24/2000)
; 84   : 	{x*=s; y*=s; z*=s;}
; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;
; 147  : 		return l2;
; 148  : 	};
; 149  : 	
; 150  : 	inline float Distance(const Vector3d &a) const   // distance between two points.
; 151  : 	{
; 152  : 		return sqrtf(DistanceSq(a));
; 153  : 	}
; 154  : 	
; 155  : 	inline float Distance2d(const Vector3d &a) const   // distance between two points.
; 156  : 	{
; 157  : 		return sqrtf(DistanceSq2d(a));
; 158  : 	}
; 159  : 
; 160  : 	float DistanceXY(const Vector3d &a) const
; 161  : 	{
; 162  : 		float dx = a.x - x;
; 163  : 		float dy = a.y - y;
; 164  : 		float dist = dx*dx + dy*dy;
; 165  : 		return dist;
; 166  : 	}
; 167  : 	
; 168  : 	float DistanceSq(const Vector3d &a) const  // squared distance.
; 169  : 	{
; 170  : 		float dx = a.x - x;
; 171  : 		float dy = a.y - y;
; 172  : 		float dz = a.z - z;
; 173  : 		return dx*dx + dy*dy + dz*dz;
; 174  : 	};
; 175  : 
; 176  : 	float DistanceSq2d(const Vector3d &a) const  // squared distance.
; 177  : 	{
; 178  : 		float dx = a.x - x;
; 179  : 		float dy = a.y - y;
; 180  : 		return dx*dx + dy*dy;
; 181  : 	};
; 182  : 	
; 183  : 	float Normalize(void)       // normalize to a unit vector, returns distance.
; 184  : 	{
; 185  : 		float l = Length(); // get length.
; 186  : 		if ( l != 0 )
; 187  : 		{
; 188  : 			x/=l;
; 189  : 			y/=l;
; 190  : 			z/=l;
; 191  : 		}
; 192  : 		else
; 193  : 		{
; 194  : 			x = y = z = 0;
; 195  : 		}
; 196  : 		return l;
; 197  : 	};
; 198  : 	
; 199  : 	float Dot(const Vector3d &a) const        // computes dot product.
; 200  : 	{
; 201  : 		return (x * a.x + y * a.y + z * a.z );

  0002f	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  00034	0f 28 dc	 movaps	 xmm3, xmm4
  00037	f3 0f 5c 1f	 subss	 xmm3, DWORD PTR [edi]
  0003b	f3 0f 10 75 fc	 movss	 xmm6, DWORD PTR _sect$[ebp+8]
  00040	0f 28 ce	 movaps	 xmm1, xmm6
  00043	f3 0f 5c 4f 08	 subss	 xmm1, DWORD PTR [edi+8]

; 66   : 	return(Diff); };
; 67   : 	
; 68   :     Vector3d operator * (const float s) const       // MULTIPLY BY SCALAR (*)
; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);
; 70   : 	return(Scaled); };
; 71   : 	
; 72   :     Vector3d operator / (const float s) const       // DIVIDE BY SCALAR (/)
; 73   :     { 
; 74   : 		float r = 1.0f / s;
; 75   :         Vector3d Scaled(x*r, y*r, z*r);
; 76   :         return(Scaled); 
; 77   :     };
; 78   : 	
; 79   :     void operator += (const Vector3d A)             // ACCUMULATED VECTOR ADDITION (+=)
; 80   : 	{ x+=A.x; y+=A.y; z+=A.z; };
; 81   :     void operator -= (const Vector3d A)             // ACCUMULATED VECTOR SUBTRACTION (+=)
; 82   : 	{ x-=A.x; y-=A.y; z-=A.z; };
; 83   :     void operator *= (const float s)        // ACCUMULATED SCALAR MULTIPLICATION (*=) (bpc 4/24/2000)
; 84   : 	{x*=s; y*=s; z*=s;}
; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;
; 147  : 		return l2;
; 148  : 	};
; 149  : 	
; 150  : 	inline float Distance(const Vector3d &a) const   // distance between two points.
; 151  : 	{
; 152  : 		return sqrtf(DistanceSq(a));
; 153  : 	}
; 154  : 	
; 155  : 	inline float Distance2d(const Vector3d &a) const   // distance between two points.
; 156  : 	{
; 157  : 		return sqrtf(DistanceSq2d(a));
; 158  : 	}
; 159  : 
; 160  : 	float DistanceXY(const Vector3d &a) const
; 161  : 	{
; 162  : 		float dx = a.x - x;
; 163  : 		float dy = a.y - y;
; 164  : 		float dist = dx*dx + dy*dy;
; 165  : 		return dist;
; 166  : 	}
; 167  : 	
; 168  : 	float DistanceSq(const Vector3d &a) const  // squared distance.
; 169  : 	{
; 170  : 		float dx = a.x - x;
; 171  : 		float dy = a.y - y;
; 172  : 		float dz = a.z - z;
; 173  : 		return dx*dx + dy*dy + dz*dz;
; 174  : 	};
; 175  : 
; 176  : 	float DistanceSq2d(const Vector3d &a) const  // squared distance.
; 177  : 	{
; 178  : 		float dx = a.x - x;
; 179  : 		float dy = a.y - y;
; 180  : 		return dx*dx + dy*dy;
; 181  : 	};
; 182  : 	
; 183  : 	float Normalize(void)       // normalize to a unit vector, returns distance.
; 184  : 	{
; 185  : 		float l = Length(); // get length.
; 186  : 		if ( l != 0 )
; 187  : 		{
; 188  : 			x/=l;
; 189  : 			y/=l;
; 190  : 			z/=l;
; 191  : 		}
; 192  : 		else
; 193  : 		{
; 194  : 			x = y = z = 0;
; 195  : 		}
; 196  : 		return l;
; 197  : 	};
; 198  : 	
; 199  : 	float Dot(const Vector3d &a) const        // computes dot product.
; 200  : 	{
; 201  : 		return (x * a.x + y * a.y + z * a.z );

  00048	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0004c	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00050	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00054	f3 0f 58 d0	 addss	 xmm2, xmm0
  00058	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  0005d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00061	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 117  :     if ( dot >= 0  ) // then it's in front!

  00065	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@00000000
  0006c	72 1f		 jb	 SHORT $LN2@RayInterse

; 118  :     {
; 119  :       if ( intersect ) *intersect = sect;

  0006e	8b 45 10	 mov	 eax, DWORD PTR _intersect$[ebp]
  00071	85 c0		 test	 eax, eax
  00073	74 0e		 je	 SHORT $LN14@RayInterse
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00075	f3 0f 11 20	 movss	 DWORD PTR [eax], xmm4
  00079	f3 0f 11 68 04	 movss	 DWORD PTR [eax+4], xmm5
  0007e	f3 0f 11 70 08	 movss	 DWORD PTR [eax+8], xmm6
$LN14@RayInterse:
  00083	5f		 pop	 edi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 120  :       return true;

  00084	b0 01		 mov	 al, 1
  00086	5e		 pop	 esi

; 124  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 0c 00	 ret	 12			; 0000000cH
$LN2@RayInterse:
  0008d	5f		 pop	 edi

; 121  :     }
; 122  :   }
; 123  :   return false;

  0008e	32 c0		 xor	 al, al
  00090	5e		 pop	 esi

; 124  : }

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH
?RayIntersectionInFront@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ENDP ; Sphere::RayIntersectionInFront
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?RayIntersection@Sphere@@QAE_NABVVector3d@@0PAV2@@Z
_TEXT	SEGMENT
_c$1$ = -8						; size = 4
_V$3$ = -4						; size = 4
_V$1$ = 8						; size = 4
_rayOrigin$ = 8						; size = 4
_b$1$ = 12						; size = 4
_dir$ = 12						; size = 4
_d$1 = 16						; size = 4
_intersect$ = 16					; size = 4
?RayIntersection@Sphere@@QAE_NABVVector3d@@0PAV2@@Z PROC ; Sphere::RayIntersection, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  00006	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]
  0000b	f3 0f 10 61 08	 movss	 xmm4, DWORD PTR [ecx+8]
  00010	f3 0f 10 69 0c	 movss	 xmm5, DWORD PTR [ecx+12]

; 30   : 		x = a.x;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  00018	57		 push	 edi

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  00019	8b 7d 08	 mov	 edi, DWORD PTR _rayOrigin$[ebp]

; 30   : 		x = a.x;

  0001c	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]

; 31   : 		y = a.y;

  00020	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  00025	f3 0f 5c 17	 subss	 xmm2, DWORD PTR [edi]
  00029	f3 0f 5c 67 04	 subss	 xmm4, DWORD PTR [edi+4]
  0002e	f3 0f 5c 6f 08	 subss	 xmm5, DWORD PTR [edi+8]

; 32   : 		z = a.z;

  00033	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00038	f3 0f 11 75 08	 movss	 DWORD PTR _V$1$[ebp], xmm6
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 55   :   float dist2 = EO.x*EO.x + EO.y*EO.y + EO.z * EO.z;

  0003d	0f 28 ca	 movaps	 xmm1, xmm2
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 31   : 		y = a.y;

  00040	f3 0f 11 5d 0c	 movss	 DWORD PTR _b$1$[ebp], xmm3
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 55   :   float dist2 = EO.x*EO.x + EO.y*EO.y + EO.z * EO.z;

  00045	0f 28 c4	 movaps	 xmm0, xmm4
  00048	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0004c	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 32   : 		z = a.z;

  00050	f3 0f 11 7d fc	 movss	 DWORD PTR _V$3$[ebp], xmm7
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 55   :   float dist2 = EO.x*EO.x + EO.y*EO.y + EO.z * EO.z;

  00055	f3 0f 58 c8	 addss	 xmm1, xmm0
  00059	0f 28 c5	 movaps	 xmm0, xmm5
  0005c	f3 0f 59 c5	 mulss	 xmm0, xmm5
  00060	f3 0f 58 c8	 addss	 xmm1, xmm0

; 56   :   // Bug Fix For Gem, if origin is *inside* the sphere, invert the
; 57   :   // direction vector so that we get a valid intersection location.
; 58   :   if ( dist2 < mRadius2 ) V*=-1;

  00064	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  00069	0f 2f c1	 comiss	 xmm0, xmm1
  0006c	76 23		 jbe	 SHORT $LN16@RayInterse
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 84   : 	{x*=s; y*=s; z*=s;}

  0006e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00076	f3 0f 59 f0	 mulss	 xmm6, xmm0
  0007a	f3 0f 59 d8	 mulss	 xmm3, xmm0
  0007e	f3 0f 59 f8	 mulss	 xmm7, xmm0
  00082	f3 0f 11 75 08	 movss	 DWORD PTR _V$1$[ebp], xmm6
  00087	f3 0f 11 5d 0c	 movss	 DWORD PTR _b$1$[ebp], xmm3
  0008c	f3 0f 11 7d fc	 movss	 DWORD PTR _V$3$[ebp], xmm7
$LN16@RayInterse:

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  00091	0f 28 c2	 movaps	 xmm0, xmm2
  00094	0f 28 cb	 movaps	 xmm1, xmm3
  00097	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0009b	f3 0f 59 cc	 mulss	 xmm1, xmm4

; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;

  0009f	f3 0f 59 d2	 mulss	 xmm2, xmm2

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  000a3	f3 0f 58 c8	 addss	 xmm1, xmm0

; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;

  000a7	f3 0f 59 e4	 mulss	 xmm4, xmm4

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  000ab	0f 28 c7	 movaps	 xmm0, xmm7
  000ae	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;

  000b2	f3 0f 58 d4	 addss	 xmm2, xmm4
  000b6	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  000ba	f3 0f 58 c8	 addss	 xmm1, xmm0

; 85   : 	
; 86   :     Vector3d operator - (void) const                // NEGATION (-)
; 87   : 	{ Vector3d Negated(-x, -y, -z);
; 88   : 	return(Negated); };
; 89   : 	
; 90   :     float operator [] (const int i) const         // ALLOWS VECTOR ACCESS AS AN ARRAY.
; 91   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 92   :     float & operator [] (const int i)
; 93   : 	{ return( (i==0)?x:((i==1)?y:z) ); };
; 94   : 	//
; 95   : 	
; 96   : 	// accessor methods.
; 97   : 	float GetX(void) const { return x; };
; 98   : 	float GetY(void) const { return y; };
; 99   : 	float GetZ(void) const { return z; };
; 100  : 	
; 101  : 	void SetX(float t)   { x   = t; };
; 102  : 	void SetY(float t)   { y   = t; };
; 103  : 	void SetZ(float t)   { z   = t; };
; 104  : 	
; 105  : 	void Set(float a,float b,float c)
; 106  : 	{
; 107  : 		x = a;
; 108  : 		y = b;
; 109  : 		z = c;
; 110  : 	};
; 111  : 	
; 112  : 	void Zero(void)
; 113  : 	{
; 114  : 		x = y = z = 0;
; 115  : 	};
; 116  : 	
; 117  : 	// return -(*this).
; 118  : 	Vector3d negative(void) const
; 119  : 	{
; 120  : 		Vector3d result;
; 121  : 		result.x = -x;
; 122  : 		result.y = -y;
; 123  : 		result.z = -z;
; 124  : 		return result;
; 125  : 	}
; 126  : 	
; 127  : 	float Magnitude(void) const
; 128  : 	{
; 129  : 		return (sqrtf(x * x + y * y + z * z));
; 130  : 	};
; 131  : 	
; 132  : 	void Lerp(const Vector3d& from,const Vector3d& to,float slerp)
; 133  : 	{
; 134  : 		*this = to-from; // delta on all 3 axis
; 135  : 		*this*=slerp;    // times interpolant distance.
; 136  : 		*this+=from;     // plus source
; 137  : 	};
; 138  : 	
; 139  : 	float Length(void) const          // length of vector.
; 140  : 	{
; 141  : 		return float(sqrtf( x*x + y*y + z*z ));
; 142  : 	};
; 143  : 	
; 144  : 	float Length2(void) const         // squared distance, prior to square root.
; 145  : 	{
; 146  : 		float l2 = x*x+y*y+z*z;

  000be	f3 0f 58 d5	 addss	 xmm2, xmm5
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 62   : 	float disc = mRadius2 - (EO.Length2() - v*v);

  000c2	0f 28 c1	 movaps	 xmm0, xmm1
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  000c5	f3 0f 11 4d f8	 movss	 DWORD PTR _c$1$[ebp], xmm1
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 62   : 	float disc = mRadius2 - (EO.Length2() - v*v);

  000ca	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000ce	f3 0f 5c d0	 subss	 xmm2, xmm0
  000d2	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [ecx+20]
  000d7	f3 0f 5c c2	 subss	 xmm0, xmm2

; 63   : 
; 64   : 	if (disc > 0.0f)

  000db	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000e2	76 70		 jbe	 SHORT $LN2@RayInterse

; 65   : 	{
; 66   : 
; 67   : 		if ( intersect )

  000e4	56		 push	 esi
  000e5	8b 75 10	 mov	 esi, DWORD PTR _intersect$[ebp]
  000e8	85 f6		 test	 esi, esi
  000ea	74 5e		 je	 SHORT $LN36@RayInterse
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  000ec	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ef	83 ec 08	 sub	 esp, 8
  000f2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f7	e8 00 00 00 00	 call	 _sqrt
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 74   :       *intersect = rayOrigin + V*(v-d);

  000fc	f3 0f 10 5d f8	 movss	 xmm3, DWORD PTR _c$1$[ebp]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00101	83 c4 08	 add	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);

  00104	f3 0f 10 65 0c	 movss	 xmm4, DWORD PTR _b$1$[ebp]

; 58   : 	return(*this);  };
; 59   : 	
; 60   :     Vector3d operator + (const Vector3d& A) const     // ADDITION (+)
; 61   : 	{ Vector3d Sum(x+A.x, y+A.y, z+A.z);

  00109	f3 0f 10 17	 movss	 xmm2, DWORD PTR [edi]
  0010d	f3 0f 10 4f 04	 movss	 xmm1, DWORD PTR [edi+4]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 70   : 		  float d = sqrtf(disc);

  00112	d9 5d 10	 fstp	 DWORD PTR _d$1[ebp]

; 74   :       *intersect = rayOrigin + V*(v-d);

  00115	f3 0f 5c 5d 10	 subss	 xmm3, DWORD PTR _d$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);

  0011a	0f 28 c3	 movaps	 xmm0, xmm3
  0011d	f3 0f 59 e3	 mulss	 xmm4, xmm3
  00121	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _V$1$[ebp]
  00126	f3 0f 59 5d fc	 mulss	 xmm3, DWORD PTR _V$3$[ebp]

; 58   : 	return(*this);  };
; 59   : 	
; 60   :     Vector3d operator + (const Vector3d& A) const     // ADDITION (+)
; 61   : 	{ Vector3d Sum(x+A.x, y+A.y, z+A.z);

  0012b	f3 0f 58 cc	 addss	 xmm1, xmm4
  0012f	f3 0f 58 d0	 addss	 xmm2, xmm0
  00133	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00138	f3 0f 58 c3	 addss	 xmm0, xmm3

; 33   : 	};
; 34   : 	
; 35   : 	Vector3d(float a,float b,float c) // construct with initial point.
; 36   : 	{
; 37   : 		x = a;
; 38   : 		y = b;
; 39   : 		z = c;
; 40   : 	};
; 41   : 	
; 42   : 	bool operator==(const Vector3d &a) const
; 43   : 	{
; 44   : 		if ( a.x == x && a.y == y && a.z == z ) return true;
; 45   : 		return false;
; 46   : 	};
; 47   : 	
; 48   : 	bool operator!=(const Vector3d &a) const
; 49   : 	{
; 50   : 		if ( a.x != x || a.y != y || a.z != z ) return true;
; 51   : 		return false;
; 52   : 	};
; 53   : 	
; 54   : 	
; 55   : 	// Operators
; 56   :     Vector3d& operator = (const Vector3d& A)          // ASSIGNMENT (=)
; 57   : 	{ x=A.x; y=A.y; z=A.z;

  0013c	f3 0f 11 4e 04	 movss	 DWORD PTR [esi+4], xmm1
  00141	f3 0f 11 16	 movss	 DWORD PTR [esi], xmm2
  00145	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
$LN36@RayInterse:
  0014a	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 78   : 		return true;

  0014b	b0 01		 mov	 al, 1
  0014d	5f		 pop	 edi

; 81   : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 0c 00	 ret	 12			; 0000000cH
$LN2@RayInterse:

; 79   : 	}
; 80   : 	return false;

  00154	32 c0		 xor	 al, al
  00156	5f		 pop	 edi

; 81   : }

  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c2 0c 00	 ret	 12			; 0000000cH
?RayIntersection@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ENDP ; Sphere::RayIntersection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?RayIntersection@Sphere@@QAE_NABVVector3d@@0MPAV2@@Z
_TEXT	SEGMENT
_sect$ = -12						; size = 12
_rayOrigin$ = 8						; size = 4
_V$ = 12						; size = 4
_distance$ = 16						; size = 4
_intersect$ = 20					; size = 4
?RayIntersection@Sphere@@QAE_NABVVector3d@@0MPAV2@@Z PROC ; Sphere::RayIntersection, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 89   :   Vector3d sect;
; 90   :   bool hit = RayIntersectionInFront(rayOrigin,V,&sect);

  00006	8d 45 f4	 lea	 eax, DWORD PTR _sect$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR _rayOrigin$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 0c	 push	 DWORD PTR _V$[ebp]
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ?RayIntersectionInFront@Sphere@@QAE_NABVVector3d@@0PAV2@@Z ; Sphere::RayIntersectionInFront

; 91   : 
; 92   :   if ( hit )

  00017	84 c0		 test	 al, al
  00019	74 66		 je	 SHORT $LN3@RayInterse
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 170  : 		float dx = a.x - x;

  0001b	f3 0f 10 5d f4	 movss	 xmm3, DWORD PTR _sect$[ebp]

; 171  : 		float dy = a.y - y;

  00020	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _sect$[ebp+4]
  00025	0f 28 cb	 movaps	 xmm1, xmm3
  00028	f3 0f 5c 0e	 subss	 xmm1, DWORD PTR [esi]

; 172  : 		float dz = a.z - z;

  0002c	f3 0f 10 6d fc	 movss	 xmm5, DWORD PTR _sect$[ebp+8]
  00031	0f 28 d4	 movaps	 xmm2, xmm4
  00034	f3 0f 5c 56 04	 subss	 xmm2, DWORD PTR [esi+4]
  00039	0f 28 c5	 movaps	 xmm0, xmm5
  0003c	f3 0f 5c 46 08	 subss	 xmm0, DWORD PTR [esi+8]

; 173  : 		return dx*dx + dy*dy + dz*dz;

  00041	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00045	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00049	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0004d	f3 0f 58 d1	 addss	 xmm2, xmm1
  00051	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 95   :     if ( d > (distance*distance) ) return false;

  00055	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0005a	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0005e	0f 2f d0	 comiss	 xmm2, xmm0
  00061	77 1e		 ja	 SHORT $LN3@RayInterse

; 96   :     if ( intersect ) *intersect = sect;

  00063	8b 45 14	 mov	 eax, DWORD PTR _intersect$[ebp]
  00066	85 c0		 test	 eax, eax
  00068	74 0e		 je	 SHORT $LN8@RayInterse
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  0006a	f3 0f 11 18	 movss	 DWORD PTR [eax], xmm3
  0006e	f3 0f 11 60 04	 movss	 DWORD PTR [eax+4], xmm4
  00073	f3 0f 11 68 08	 movss	 DWORD PTR [eax+8], xmm5
$LN8@RayInterse:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 97   :     return true;

  00078	b0 01		 mov	 al, 1
  0007a	5e		 pop	 esi

; 100  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 10 00	 ret	 16			; 00000010H
$LN3@RayInterse:

; 98   :   }
; 99   :   return false;

  00081	32 c0		 xor	 al, al
  00083	5e		 pop	 esi

; 100  : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 10 00	 ret	 16			; 00000010H
?RayIntersection@Sphere@@QAE_NABVVector3d@@0MPAV2@@Z ENDP ; Sphere::RayIntersection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?Compute@Sphere@@QAEXABVSphereInterface@@@Z
_TEXT	SEGMENT
_ymin$1$ = -96						; size = 4
_ymax$3$ = -92						; size = 4
_zmin$3$ = -88						; size = 4
_zmin$1$ = -84						; size = 4
_zmax$3$ = -80						; size = 4
_ymin$3$ = -76						; size = 4
_count$1$ = -72						; size = 4
_dz$4$ = -68						; size = 4
_zmax$2$ = -64						; size = 4
_dia1$1$ = -60						; size = 4
_zmax$1$ = -56						; size = 4
_zmin$2$ = -52						; size = 4
_ymax$1$ = -48						; size = 4
_dx$4$ = -44						; size = 4
_ymax$2$ = -40						; size = 4
_dia1$2$ = -36						; size = 4
__X$1$ = -32						; size = 4
_yspan$1$ = -32						; size = 4
_dia1$3$ = -28						; size = 4
_maxspan$1$ = -24					; size = 4
_this$GSCopy$1$ = -24					; size = 4
tv1210 = -24						; size = 4
_old_to_p$1 = -24					; size = 4
_zspan$1$ = -20						; size = 4
_ymin$2$ = -20						; size = 4
_caller_p$2 = -16					; size = 12
_caller_p$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
?Compute@Sphere@@QAEXABVSphereInterface@@@Z PROC	; Sphere::Compute, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  00010	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ccbebc20
  00018	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@4cbebc20

; 108  : 		y = b;

  00020	0f 28 d8	 movaps	 xmm3, xmm0
  00023	53		 push	 ebx
  00024	8b 5d 08	 mov	 ebx, DWORD PTR _source$[ebp]
  00027	56		 push	 esi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 146  : {

  00028	8b f1		 mov	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  0002a	f3 0f 11 4d c4	 movss	 DWORD PTR _dia1$1$[ebp], xmm1
  0002f	57		 push	 edi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 158  :   int count = source.GetVertexCount();

  00030	8b 03		 mov	 eax, DWORD PTR [ebx]
  00032	8b cb		 mov	 ecx, ebx
  00034	89 75 e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  00037	f3 0f 11 4d dc	 movss	 DWORD PTR _dia1$2$[ebp], xmm1

; 109  : 		z = c;

  0003c	f3 0f 11 4d e4	 movss	 DWORD PTR _dia1$3$[ebp], xmm1

; 107  : 		x = a;

  00041	f3 0f 11 45 d4	 movss	 DWORD PTR _dx$4$[ebp], xmm0

; 108  : 		y = b;

  00046	f3 0f 11 5d e0	 movss	 DWORD PTR __X$1$[ebp], xmm3

; 109  : 		z = c;

  0004b	f3 0f 11 45 bc	 movss	 DWORD PTR _dz$4$[ebp], xmm0

; 107  : 		x = a;

  00050	f3 0f 11 4d a0	 movss	 DWORD PTR _ymin$1$[ebp], xmm1

; 108  : 		y = b;

  00055	f3 0f 11 4d ec	 movss	 DWORD PTR _ymin$2$[ebp], xmm1

; 109  : 		z = c;

  0005a	f3 0f 11 4d b4	 movss	 DWORD PTR _ymin$3$[ebp], xmm1

; 107  : 		x = a;

  0005f	f3 0f 11 45 d0	 movss	 DWORD PTR _ymax$1$[ebp], xmm0

; 108  : 		y = b;

  00064	f3 0f 11 45 d8	 movss	 DWORD PTR _ymax$2$[ebp], xmm0

; 109  : 		z = c;

  00069	f3 0f 11 45 a4	 movss	 DWORD PTR _ymax$3$[ebp], xmm0

; 107  : 		x = a;

  0006e	f3 0f 11 4d ac	 movss	 DWORD PTR _zmin$1$[ebp], xmm1

; 108  : 		y = b;

  00073	f3 0f 11 4d cc	 movss	 DWORD PTR _zmin$2$[ebp], xmm1

; 109  : 		z = c;

  00078	f3 0f 11 4d a8	 movss	 DWORD PTR _zmin$3$[ebp], xmm1

; 107  : 		x = a;

  0007d	f3 0f 11 45 c8	 movss	 DWORD PTR _zmax$1$[ebp], xmm0

; 108  : 		y = b;

  00082	f3 0f 11 45 c0	 movss	 DWORD PTR _zmax$2$[ebp], xmm0

; 109  : 		z = c;

  00087	f3 0f 11 45 b0	 movss	 DWORD PTR _zmax$3$[ebp], xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 158  :   int count = source.GetVertexCount();

  0008c	ff 50 04	 call	 DWORD PTR [eax+4]

; 160  :   for (int i=0; i<count; i++)

  0008f	33 ff		 xor	 edi, edi
  00091	89 45 b8	 mov	 DWORD PTR _count$1$[ebp], eax
  00094	85 c0		 test	 eax, eax
  00096	0f 8e c4 00 00
	00		 jle	 $LN186@Compute
  0009c	8b f0		 mov	 esi, eax
  0009e	8b ff		 npad	 2
$LL15@Compute:

; 161  : 	{
; 162  :     Vector3d caller_p;
; 163  :     source.GetVertex(i,caller_p);

  000a0	8b 13		 mov	 edx, DWORD PTR [ebx]
  000a2	8d 45 f0	 lea	 eax, DWORD PTR _caller_p$3[ebp]
  000a5	50		 push	 eax
  000a6	57		 push	 edi
  000a7	8b cb		 mov	 ecx, ebx
  000a9	ff 52 08	 call	 DWORD PTR [edx+8]

; 164  : 
; 165  :   	if (caller_p.GetX()<xmin.GetX()) 	xmin = caller_p; /* New xminimum point */

  000ac	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _caller_p$3[ebp]
  000b1	f3 0f 10 5d c4	 movss	 xmm3, DWORD PTR _dia1$1$[ebp]
  000b6	0f 2f da	 comiss	 xmm3, xmm2
  000b9	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _caller_p$3[ebp+8]
  000be	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _caller_p$3[ebp+4]
  000c3	76 14		 jbe	 SHORT $LN187@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  000c5	0f 28 e2	 movaps	 xmm4, xmm2
  000c8	f3 0f 11 4d dc	 movss	 DWORD PTR _dia1$2$[ebp], xmm1
  000cd	f3 0f 11 65 c4	 movss	 DWORD PTR _dia1$1$[ebp], xmm4
  000d2	f3 0f 11 45 e4	 movss	 DWORD PTR _dia1$3$[ebp], xmm0
  000d7	eb 05		 jmp	 SHORT $LN34@Compute
$LN187@Compute:
  000d9	f3 0f 10 65 c4	 movss	 xmm4, DWORD PTR _dia1$1$[ebp]
$LN34@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 166  :   	if (caller_p.GetX()>xmax.GetX())	xmax = caller_p;

  000de	0f 2f 55 d4	 comiss	 xmm2, DWORD PTR _dx$4$[ebp]
  000e2	76 12		 jbe	 SHORT $LN40@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  000e4	0f 28 d9	 movaps	 xmm3, xmm1
  000e7	f3 0f 11 55 d4	 movss	 DWORD PTR _dx$4$[ebp], xmm2
  000ec	f3 0f 11 5d e0	 movss	 DWORD PTR __X$1$[ebp], xmm3
  000f1	f3 0f 11 45 bc	 movss	 DWORD PTR _dz$4$[ebp], xmm0
$LN40@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 167  :   	if (caller_p.GetY()<ymin.GetY())	ymin = caller_p;

  000f6	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _ymin$2$[ebp]
  000fb	0f 2f d9	 comiss	 xmm3, xmm1
  000fe	76 0f		 jbe	 SHORT $LN46@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00100	f3 0f 11 55 a0	 movss	 DWORD PTR _ymin$1$[ebp], xmm2
  00105	f3 0f 11 4d ec	 movss	 DWORD PTR _ymin$2$[ebp], xmm1
  0010a	f3 0f 11 45 b4	 movss	 DWORD PTR _ymin$3$[ebp], xmm0
$LN46@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 168  :   	if (caller_p.GetY()>ymax.GetY())	ymax = caller_p;

  0010f	0f 2f 4d d8	 comiss	 xmm1, DWORD PTR _ymax$2$[ebp]
  00113	76 0f		 jbe	 SHORT $LN52@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00115	f3 0f 11 55 d0	 movss	 DWORD PTR _ymax$1$[ebp], xmm2
  0011a	f3 0f 11 4d d8	 movss	 DWORD PTR _ymax$2$[ebp], xmm1
  0011f	f3 0f 11 45 a4	 movss	 DWORD PTR _ymax$3$[ebp], xmm0
$LN52@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 169  :   	if (caller_p.GetZ()<zmin.GetZ())	zmin = caller_p;

  00124	f3 0f 10 5d a8	 movss	 xmm3, DWORD PTR _zmin$3$[ebp]
  00129	0f 2f d8	 comiss	 xmm3, xmm0
  0012c	76 0f		 jbe	 SHORT $LN58@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  0012e	f3 0f 11 55 ac	 movss	 DWORD PTR _zmin$1$[ebp], xmm2
  00133	f3 0f 11 4d cc	 movss	 DWORD PTR _zmin$2$[ebp], xmm1
  00138	f3 0f 11 45 a8	 movss	 DWORD PTR _zmin$3$[ebp], xmm0
$LN58@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 170  :   	if (caller_p.GetZ()>zmax.GetZ()) zmax = caller_p;

  0013d	0f 2f 45 b0	 comiss	 xmm0, DWORD PTR _zmax$3$[ebp]
  00141	76 0f		 jbe	 SHORT $LN14@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00143	f3 0f 11 55 c8	 movss	 DWORD PTR _zmax$1$[ebp], xmm2
  00148	f3 0f 11 4d c0	 movss	 DWORD PTR _zmax$2$[ebp], xmm1
  0014d	f3 0f 11 45 b0	 movss	 DWORD PTR _zmax$3$[ebp], xmm0
$LN14@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 160  :   for (int i=0; i<count; i++)

  00152	47		 inc	 edi
  00153	3b fe		 cmp	 edi, esi
  00155	0f 8c 45 ff ff
	ff		 jl	 $LL15@Compute
  0015b	8b 75 e8	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0015e	eb 08		 jmp	 SHORT $LN13@Compute
$LN186@Compute:
  00160	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@4cbebc20
$LN13@Compute:

; 171  : 	}
; 172  : 
; 173  :   /* Set xspan = distance between the 2 points xmin & xmax (squared) */
; 174  :   float dx = xmax.GetX() - xmin.GetX();
; 175  :   float dy = xmax.GetY() - xmin.GetY();

  00168	f3 0f 10 6d e0	 movss	 xmm5, DWORD PTR __X$1$[ebp]
  0016d	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _dx$4$[ebp]
  00172	0f 28 d5	 movaps	 xmm2, xmm5
  00175	f3 0f 5c 55 dc	 subss	 xmm2, DWORD PTR _dia1$2$[ebp]

; 176  :   float dz = xmax.GetZ() - xmin.GetZ();

  0017a	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _dz$4$[ebp]
  0017f	f3 0f 5c cc	 subss	 xmm1, xmm4
  00183	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _dia1$3$[ebp]

; 177  :   float xspan = dx*dx + dy*dy + dz*dz;
; 178  : 
; 179  :   /* Same for y & z spans */
; 180  :   dx = ymax.GetX() - ymin.GetX();
; 181  :   dy = ymax.GetY() - ymin.GetY();

  00188	f3 0f 10 7d ec	 movss	 xmm7, DWORD PTR _ymin$2$[ebp]

; 182  :   dz = ymax.GetZ() - ymin.GetZ();
; 183  :   float yspan = dx*dx + dy*dy + dz*dz;
; 184  : 
; 185  :   dx = zmax.GetX() - zmin.GetX();
; 186  :   dy = zmax.GetY() - zmin.GetY();
; 187  :   dz = zmax.GetZ() - zmin.GetZ();

  0018d	f3 0f 10 75 b0	 movss	 xmm6, DWORD PTR _zmax$3$[ebp]
  00192	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00196	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0019a	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0019e	f3 0f 58 d1	 addss	 xmm2, xmm1
  001a2	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _ymax$1$[ebp]
  001a7	f3 0f 5c 4d a0	 subss	 xmm1, DWORD PTR _ymin$1$[ebp]
  001ac	f3 0f 58 d0	 addss	 xmm2, xmm0
  001b0	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _ymax$3$[ebp]
  001b5	f3 0f 5c 45 b4	 subss	 xmm0, DWORD PTR _ymin$3$[ebp]
  001ba	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001be	f3 0f 11 55 e8	 movss	 DWORD PTR _maxspan$1$[ebp], xmm2
  001c3	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _ymax$2$[ebp]
  001c8	f3 0f 5c d7	 subss	 xmm2, xmm7
  001cc	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001d0	f3 0f 59 d2	 mulss	 xmm2, xmm2
  001d4	f3 0f 58 d1	 addss	 xmm2, xmm1
  001d8	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR _zmax$1$[ebp]
  001dd	f3 0f 5c 4d ac	 subss	 xmm1, DWORD PTR _zmin$1$[ebp]
  001e2	f3 0f 58 d0	 addss	 xmm2, xmm0
  001e6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _zmax$2$[ebp]
  001eb	f3 0f 5c 45 cc	 subss	 xmm0, DWORD PTR _zmin$2$[ebp]

; 188  :   float zspan = dx*dx + dy*dy + dz*dz;

  001f0	f3 0f 59 c9	 mulss	 xmm1, xmm1
  001f4	f3 0f 11 55 e0	 movss	 DWORD PTR _yspan$1$[ebp], xmm2
  001f9	f3 0f 10 55 a8	 movss	 xmm2, DWORD PTR _zmin$3$[ebp]
  001fe	f3 0f 11 45 ec	 movss	 DWORD PTR _zspan$1$[ebp], xmm0
  00203	0f 28 c6	 movaps	 xmm0, xmm6
  00206	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _zspan$1$[ebp]
  0020b	f3 0f 5c c2	 subss	 xmm0, xmm2
  0020f	f3 0f 59 db	 mulss	 xmm3, xmm3
  00213	f3 0f 58 d9	 addss	 xmm3, xmm1
  00217	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0021b	f3 0f 10 cb	 movss	 xmm1, xmm3

; 189  : 
; 190  :   /* Set points dia1 & dia2 to the maximally separated pair */
; 191  :   dia1 = xmin;
; 192  :   dia2 = xmax; /* assume xspan biggest */
; 193  :   float maxspan = xspan;
; 194  : 
; 195  :   if (yspan>maxspan)

  0021f	f3 0f 10 5d e0	 movss	 xmm3, DWORD PTR _yspan$1$[ebp]
  00224	f3 0f 58 c8	 addss	 xmm1, xmm0
  00228	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _maxspan$1$[ebp]
  0022d	0f 2f d8	 comiss	 xmm3, xmm0
  00230	f3 0f 10 5d d4	 movss	 xmm3, DWORD PTR _dx$4$[ebp]
  00235	76 2a		 jbe	 SHORT $LN188@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00237	f3 0f 10 5d b4	 movss	 xmm3, DWORD PTR _ymin$3$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 197  : 	  maxspan = yspan;

  0023c	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _yspan$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00241	f3 0f 10 65 a0	 movss	 xmm4, DWORD PTR _ymin$1$[ebp]
  00246	f3 0f 10 6d d8	 movss	 xmm5, DWORD PTR _ymax$2$[ebp]
  0024b	f3 0f 11 7d dc	 movss	 DWORD PTR _dia1$2$[ebp], xmm7
  00250	f3 0f 10 7d a4	 movss	 xmm7, DWORD PTR _ymax$3$[ebp]
  00255	f3 0f 11 5d e4	 movss	 DWORD PTR _dia1$3$[ebp], xmm3
  0025a	f3 0f 10 5d d0	 movss	 xmm3, DWORD PTR _ymax$1$[ebp]
  0025f	eb 05		 jmp	 SHORT $LN108@Compute
$LN188@Compute:
  00261	f3 0f 10 7d bc	 movss	 xmm7, DWORD PTR _dz$4$[ebp]
$LN108@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 202  :   if (zspan>maxspan)

  00266	0f 2f c8	 comiss	 xmm1, xmm0
  00269	76 1e		 jbe	 SHORT $LN189@Compute
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  0026b	f3 0f 10 65 ac	 movss	 xmm4, DWORD PTR _zmin$1$[ebp]
  00270	0f 28 fe	 movaps	 xmm7, xmm6
  00273	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _zmin$2$[ebp]
  00278	f3 0f 10 5d c8	 movss	 xmm3, DWORD PTR _zmax$1$[ebp]
  0027d	f3 0f 10 6d c0	 movss	 xmm5, DWORD PTR _zmax$2$[ebp]
  00282	f3 0f 11 55 e4	 movss	 DWORD PTR _dia1$3$[ebp], xmm2
  00287	eb 05		 jmp	 SHORT $LN112@Compute
$LN189@Compute:
  00289	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _dia1$2$[ebp]
$LN112@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 212  :   mCenter.SetY( (dia1.GetY()+dia2.GetY())*0.5f );

  0028e	0f 28 cd	 movaps	 xmm1, xmm5
  00291	0f 28 d3	 movaps	 xmm2, xmm3
  00294	f3 0f 58 c8	 addss	 xmm1, xmm0
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00298	83 ec 08	 sub	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 211  :   mCenter.SetX( (dia1.GetX()+dia2.GetX())*0.5f );

  0029b	f3 0f 58 d4	 addss	 xmm2, xmm4

; 213  :   mCenter.SetZ( (dia1.GetZ()+dia2.GetZ())*0.5f );

  0029f	0f 28 c7	 movaps	 xmm0, xmm7
  002a2	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  002aa	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _dia1$3$[ebp]
  002af	f3 0f 59 cc	 mulss	 xmm1, xmm4
  002b3	f3 0f 59 d4	 mulss	 xmm2, xmm4

; 214  :   /* calculate initial radius**2 and radius */
; 215  :   dx = dia2.GetX()-mCenter.GetX(); /* x component of radius vector */
; 216  :   dy = dia2.GetY()-mCenter.GetY(); /* y component of radius vector */

  002b7	f3 0f 5c e9	 subss	 xmm5, xmm1
  002bb	f3 0f 59 c4	 mulss	 xmm0, xmm4
  002bf	f3 0f 5c da	 subss	 xmm3, xmm2
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 101  : 	void SetX(float t)   { x   = t; };

  002c3	f3 0f 11 56 04	 movss	 DWORD PTR [esi+4], xmm2

; 102  : 	void SetY(float t)   { y   = t; };

  002c8	f3 0f 11 4e 08	 movss	 DWORD PTR [esi+8], xmm1
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 217  :   dz = dia2.GetZ()-mCenter.GetZ(); /* z component of radius vector */

  002cd	f3 0f 5c f8	 subss	 xmm7, xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 103  : 	void SetZ(float t)   { z   = t; };

  002d1	f3 0f 11 46 0c	 movss	 DWORD PTR [esi+12], xmm0
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 218  :   mRadius2 = dx*dx + dy*dy + dz*dz;

  002d6	f3 0f 59 ed	 mulss	 xmm5, xmm5
  002da	f3 0f 59 db	 mulss	 xmm3, xmm3
  002de	f3 0f 59 ff	 mulss	 xmm7, xmm7
  002e2	f3 0f 58 eb	 addss	 xmm5, xmm3
  002e6	f3 0f 58 ef	 addss	 xmm5, xmm7
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  002ea	0f 5a c5	 cvtps2pd xmm0, xmm5
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 218  :   mRadius2 = dx*dx + dy*dy + dz*dz;

  002ed	f3 0f 11 6e 14	 movss	 DWORD PTR [esi+20], xmm5
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  002f2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002f7	e8 00 00 00 00	 call	 _sqrt
  002fc	d9 5d e8	 fstp	 DWORD PTR tv1210[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 219  :   mRadius = float(sqrt(mRadius2));

  002ff	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR tv1210[ebp]

; 223  :   for (int j=0; j<count; j++)

  00304	33 ff		 xor	 edi, edi
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00306	83 c4 08	 add	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 219  :   mRadius = float(sqrt(mRadius2));

  00309	f3 0f 11 46 10	 movss	 DWORD PTR [esi+16], xmm0

; 223  :   for (int j=0; j<count; j++)

  0030e	39 7d b8	 cmp	 DWORD PTR _count$1$[ebp], edi
  00311	0f 8e ff 00 00
	00		 jle	 $LN2@Compute
$LL4@Compute:

; 224  : 	{
; 225  :     Vector3d caller_p;
; 226  :     source.GetVertex(j,caller_p);

  00317	8b 03		 mov	 eax, DWORD PTR [ebx]
  00319	8d 4d f0	 lea	 ecx, DWORD PTR _caller_p$2[ebp]
  0031c	51		 push	 ecx
  0031d	57		 push	 edi
  0031e	8b cb		 mov	 ecx, ebx
  00320	ff 50 08	 call	 DWORD PTR [eax+8]

; 227  :   	dx = caller_p.GetX()-mCenter.GetX();

  00323	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _caller_p$2[ebp]

; 228  : 	  dy = caller_p.GetY()-mCenter.GetY();

  00328	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _caller_p$2[ebp+4]
  0032d	f3 0f 5c 56 08	 subss	 xmm2, DWORD PTR [esi+8]
  00332	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [esi+4]

; 229  :   	dz = caller_p.GetZ()-mCenter.GetZ();

  00337	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _caller_p$2[ebp+8]
  0033c	f3 0f 5c 46 0c	 subss	 xmm0, DWORD PTR [esi+12]

; 230  : 	  float old_to_p_sq = dx*dx + dy*dy + dz*dz;

  00341	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00345	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00349	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0034d	f3 0f 58 d1	 addss	 xmm2, xmm1
  00351	f3 0f 58 d0	 addss	 xmm2, xmm0

; 231  :   	if (old_to_p_sq > mRadius2) 	/* do r**2 test first */

  00355	0f 2f 56 14	 comiss	 xmm2, DWORD PTR [esi+20]
  00359	0f 86 ad 00 00
	00		 jbe	 $LN3@Compute
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0035f	0f 5a c2	 cvtps2pd xmm0, xmm2
  00362	83 ec 08	 sub	 esp, 8
  00365	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0036a	e8 00 00 00 00	 call	 _sqrt
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 235  :   		mRadius = (mRadius + old_to_p) * 0.5f;

  0036f	f3 0f 10 76 10	 movss	 xmm6, DWORD PTR [esi+16]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00374	83 c4 08	 add	 esp, 8
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 239  :       float recip = 1.0f /old_to_p;

  00377	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 97   : 	float GetX(void) const { return x; };

  0037f	f3 0f 10 6e 04	 movss	 xmm5, DWORD PTR [esi+4]

; 98   : 	float GetY(void) const { return y; };

  00384	f3 0f 10 56 08	 movss	 xmm2, DWORD PTR [esi+8]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 233  : 	  	float old_to_p = float(sqrt(old_to_p_sq));

  00389	d9 5d e8	 fstp	 DWORD PTR _old_to_p$1[ebp]

; 235  :   		mRadius = (mRadius + old_to_p) * 0.5f;

  0038c	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _old_to_p$1[ebp]
  00391	f3 0f 58 f1	 addss	 xmm6, xmm1

; 237  :   		float old_to_new = old_to_p - mRadius;

  00395	0f 28 e1	 movaps	 xmm4, xmm1

; 239  :       float recip = 1.0f /old_to_p;

  00398	f3 0f 5e d9	 divss	 xmm3, xmm1
  0039c	f3 0f 59 35 00
	00 00 00	 mulss	 xmm6, DWORD PTR __real@3f000000
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 99   : 	float GetZ(void) const { return z; };

  003a4	f3 0f 10 4e 0c	 movss	 xmm1, DWORD PTR [esi+12]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 236  : 	  	mRadius2 = mRadius*mRadius; 	/* for next r**2 compare */

  003a9	0f 28 c6	 movaps	 xmm0, xmm6

; 240  : 
; 241  :   		float cx = (mRadius*mCenter.GetX() + old_to_new*caller_p.GetX()) * recip;

  003ac	f3 0f 59 ee	 mulss	 xmm5, xmm6
  003b0	f3 0f 59 c6	 mulss	 xmm0, xmm6
  003b4	f3 0f 5c e6	 subss	 xmm4, xmm6

; 242  : 	  	float cy = (mRadius*mCenter.GetY() + old_to_new*caller_p.GetY()) * recip;

  003b8	f3 0f 59 d6	 mulss	 xmm2, xmm6
  003bc	f3 0f 11 46 14	 movss	 DWORD PTR [esi+20], xmm0
  003c1	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _caller_p$2[ebp]
  003c6	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 243  : 		  float cz = (mRadius*mCenter.GetZ() + old_to_new*caller_p.GetZ()) * recip;

  003ca	f3 0f 59 ce	 mulss	 xmm1, xmm6
  003ce	f3 0f 58 e8	 addss	 xmm5, xmm0
  003d2	f3 0f 11 76 10	 movss	 DWORD PTR [esi+16], xmm6
  003d7	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _caller_p$2[ebp+4]
  003dc	f3 0f 59 c4	 mulss	 xmm0, xmm4
  003e0	f3 0f 59 eb	 mulss	 xmm5, xmm3
  003e4	f3 0f 58 d0	 addss	 xmm2, xmm0
  003e8	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _caller_p$2[ebp+8]
  003ed	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 107  : 		x = a;

  003f1	f3 0f 11 6e 04	 movss	 DWORD PTR [esi+4], xmm5
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 243  : 		  float cz = (mRadius*mCenter.GetZ() + old_to_new*caller_p.GetZ()) * recip;

  003f6	f3 0f 58 c8	 addss	 xmm1, xmm0
  003fa	f3 0f 59 d3	 mulss	 xmm2, xmm3
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 108  : 		y = b;

  003fe	f3 0f 11 56 08	 movss	 DWORD PTR [esi+8], xmm2
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 243  : 		  float cz = (mRadius*mCenter.GetZ() + old_to_new*caller_p.GetZ()) * recip;

  00403	f3 0f 59 cb	 mulss	 xmm1, xmm3
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 109  : 		z = c;

  00407	f3 0f 11 4e 0c	 movss	 DWORD PTR [esi+12], xmm1
$LN3@Compute:
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 223  :   for (int j=0; j<count; j++)

  0040c	47		 inc	 edi
  0040d	3b 7d b8	 cmp	 edi, DWORD PTR _count$1$[ebp]
  00410	0f 8c 01 ff ff
	ff		 jl	 $LL4@Compute
$LN2@Compute:

; 244  : 
; 245  :       mCenter.Set(cx,cy,cz);
; 246  : 		}
; 247  : 	}
; 248  : }

  00416	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00419	5f		 pop	 edi
  0041a	5e		 pop	 esi
  0041b	33 cd		 xor	 ecx, ebp
  0041d	5b		 pop	 ebx
  0041e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00423	8b e5		 mov	 esp, ebp
  00425	5d		 pop	 ebp
  00426	c2 04 00	 ret	 4
?Compute@Sphere@@QAEXABVSphereInterface@@@Z ENDP	; Sphere::Compute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?Set@Sphere@@QAEXABVVector3d@@M@Z
_TEXT	SEGMENT
_center$ = 8						; size = 4
_radius$ = 12						; size = 4
?Set@Sphere@@QAEXABVVector3d@@M@Z PROC			; Sphere::Set, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00003	8b 55 08	 mov	 edx, DWORD PTR _center$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 36   : 	mRadius = radius;

  00006	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00016	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00019	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp

; 36   : 	mRadius = radius;

  0001c	f3 0f 11 41 10	 movss	 DWORD PTR [ecx+16], xmm0

; 37   : 	mRadius2 = radius*radius;

  00021	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00025	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 38   : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?Set@Sphere@@QAEXABVVector3d@@M@Z ENDP			; Sphere::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\sphere.cpp
;	COMDAT ?IsInStaticRange@Vector3d@@QBE_NXZ
_TEXT	SEGMENT
?IsInStaticRange@Vector3d@@QBE_NXZ PROC			; Vector3d::IsInStaticRange, COMDAT
; _this$ = ecx

; 21   : 	const float LIMIT = 3276700.0f;
; 22   : 	if (x<LIMIT && x>-LIMIT)

  00000	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@4a47fe70
  00008	0f 2f 11	 comiss	 xmm2, DWORD PTR [ecx]
  0000b	76 34		 jbe	 SHORT $LN1@IsInStatic
  0000d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00011	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@ca47fe70
  00019	0f 2f c1	 comiss	 xmm0, xmm1
  0001c	76 23		 jbe	 SHORT $LN1@IsInStatic

; 23   : 		if (y<LIMIT && y>-LIMIT)

  0001e	0f 2f 51 04	 comiss	 xmm2, DWORD PTR [ecx+4]
  00022	76 1d		 jbe	 SHORT $LN1@IsInStatic
  00024	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00029	0f 2f c1	 comiss	 xmm0, xmm1
  0002c	76 13		 jbe	 SHORT $LN1@IsInStatic

; 24   : 			if (z<LIMIT && z>-LIMIT)

  0002e	0f 2f 51 08	 comiss	 xmm2, DWORD PTR [ecx+8]
  00032	76 0d		 jbe	 SHORT $LN1@IsInStatic
  00034	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00039	0f 2f c1	 comiss	 xmm0, xmm1
  0003c	76 03		 jbe	 SHORT $LN1@IsInStatic

; 25   : 				return true;

  0003e	b0 01		 mov	 al, 1

; 28   : }

  00040	c3		 ret	 0
$LN1@IsInStatic:

; 26   : 
; 27   : 	return false;

  00041	32 c0		 xor	 al, al

; 28   : }

  00043	c3		 ret	 0
?IsInStaticRange@Vector3d@@QBE_NXZ ENDP			; Vector3d::IsInStaticRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?Dot@Vector3d@@QBEMABV1@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?Dot@Vector3d@@QBEMABV1@@Z PROC				; Vector3d::Dot, COMDAT
; _this$ = ecx

; 200  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  : 		return (x * a.x + y * a.y + z * a.z );

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000c	d9 00		 fld	 DWORD PTR [eax]
  0000e	d8 09		 fmul	 DWORD PTR [ecx]
  00010	de c1		 faddp	 ST(1), ST(0)
  00012	d9 40 08	 fld	 DWORD PTR [eax+8]
  00015	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00018	de c1		 faddp	 ST(1), ST(0)

; 202  : 	};

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?Dot@Vector3d@@QBEMABV1@@Z ENDP				; Vector3d::Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?DistanceSq@Vector3d@@QBEMABV1@@Z
_TEXT	SEGMENT
tv184 = 8						; size = 4
_a$ = 8							; size = 4
?DistanceSq@Vector3d@@QBEMABV1@@Z PROC			; Vector3d::DistanceSq, COMDAT
; _this$ = ecx

; 169  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		float dx = a.x - x;

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]

; 171  : 		float dy = a.y - y;

  0000a	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  0000f	f3 0f 5c 51 04	 subss	 xmm2, DWORD PTR [ecx+4]
  00014	f3 0f 5c 09	 subss	 xmm1, DWORD PTR [ecx]

; 172  : 		float dz = a.z - z;

  00018	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001d	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]

; 173  : 		return dx*dx + dy*dy + dz*dz;

  00022	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00026	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0002a	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0002e	f3 0f 58 d1	 addss	 xmm2, xmm1
  00032	f3 0f 58 d0	 addss	 xmm2, xmm0
  00036	f3 0f 11 55 08	 movss	 DWORD PTR tv184[ebp], xmm2
  0003b	d9 45 08	 fld	 DWORD PTR tv184[ebp]

; 174  : 	};

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?DistanceSq@Vector3d@@QBEMABV1@@Z ENDP			; Vector3d::DistanceSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?Length2@Vector3d@@QBEMXZ
_TEXT	SEGMENT
_l2$ = -4						; size = 4
?Length2@Vector3d@@QBEMXZ PROC				; Vector3d::Length2, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		float l2 = x*x+y*y+z*z;

  00004	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  00009	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  0000d	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00012	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00016	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001a	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0001e	f3 0f 58 d1	 addss	 xmm2, xmm1
  00022	f3 0f 58 d0	 addss	 xmm2, xmm0
  00026	f3 0f 11 55 fc	 movss	 DWORD PTR _l2$[ebp], xmm2

; 147  : 		return l2;

  0002b	d9 45 fc	 fld	 DWORD PTR _l2$[ebp]

; 148  : 	};

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?Length2@Vector3d@@QBEMXZ ENDP				; Vector3d::Length2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?Set@Vector3d@@QAEXMMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
?Set@Vector3d@@QAEXMMM@Z PROC				; Vector3d::Set, COMDAT
; _this$ = ecx

; 106  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  : 		x = a;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]
  00008	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 108  : 		y = b;

  0000c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00011	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 109  : 		z = c;

  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _c$[ebp]
  0001b	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 110  : 	};

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
?Set@Vector3d@@QAEXMMM@Z ENDP				; Vector3d::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?SetZ@Vector3d@@QAEXM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?SetZ@Vector3d@@QAEXM@Z PROC				; Vector3d::SetZ, COMDAT
; _this$ = ecx

; 103  : 	void SetZ(float t)   { z   = t; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _t$[ebp]
  00008	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?SetZ@Vector3d@@QAEXM@Z ENDP				; Vector3d::SetZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?SetY@Vector3d@@QAEXM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?SetY@Vector3d@@QAEXM@Z PROC				; Vector3d::SetY, COMDAT
; _this$ = ecx

; 102  : 	void SetY(float t)   { y   = t; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _t$[ebp]
  00008	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?SetY@Vector3d@@QAEXM@Z ENDP				; Vector3d::SetY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?SetX@Vector3d@@QAEXM@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?SetX@Vector3d@@QAEXM@Z PROC				; Vector3d::SetX, COMDAT
; _this$ = ecx

; 101  : 	void SetX(float t)   { x   = t; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _t$[ebp]
  00008	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?SetX@Vector3d@@QAEXM@Z ENDP				; Vector3d::SetX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?GetZ@Vector3d@@QBEMXZ
_TEXT	SEGMENT
?GetZ@Vector3d@@QBEMXZ PROC				; Vector3d::GetZ, COMDAT
; _this$ = ecx

; 99   : 	float GetZ(void) const { return z; };

  00000	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetZ@Vector3d@@QBEMXZ ENDP				; Vector3d::GetZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?GetY@Vector3d@@QBEMXZ
_TEXT	SEGMENT
?GetY@Vector3d@@QBEMXZ PROC				; Vector3d::GetY, COMDAT
; _this$ = ecx

; 98   : 	float GetY(void) const { return y; };

  00000	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetY@Vector3d@@QBEMXZ ENDP				; Vector3d::GetY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ?GetX@Vector3d@@QBEMXZ
_TEXT	SEGMENT
?GetX@Vector3d@@QBEMXZ PROC				; Vector3d::GetX, COMDAT
; _this$ = ecx

; 97   : 	float GetX(void) const { return x; };

  00000	d9 01		 fld	 DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetX@Vector3d@@QBEMXZ ENDP				; Vector3d::GetX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??XVector3d@@QAEXM@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??XVector3d@@QAEXM@Z PROC				; Vector3d::operator*=, COMDAT
; _this$ = ecx

; 84   : 	{x*=s; y*=s; z*=s;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00007	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _s$[ebp]
  0000c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00010	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00014	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00019	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0001d	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00022	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00027	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0002b	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??XVector3d@@QAEXM@Z ENDP				; Vector3d::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??DVector3d@@QBE?AV0@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DVector3d@@QBE?AV0@M@Z PROC				; Vector3d::operator*, COMDAT
; _this$ = ecx

; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _s$[ebp]
  00008	f3 0f 10 19	 movss	 xmm3, DWORD PTR [ecx]
  0000c	f3 0f 10 51 04	 movss	 xmm2, DWORD PTR [ecx+4]
  00011	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]

; 37   : 		x = a;

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 69   : 	{ Vector3d Scaled(x*s, y*s, z*s);

  00019	f3 0f 59 d8	 mulss	 xmm3, xmm0
  0001d	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00021	f3 0f 59 c8	 mulss	 xmm1, xmm0

; 37   : 		x = a;

  00025	f3 0f 11 18	 movss	 DWORD PTR [eax], xmm3

; 38   : 		y = b;

  00029	f3 0f 11 50 04	 movss	 DWORD PTR [eax+4], xmm2

; 39   : 		z = c;

  0002e	f3 0f 11 48 08	 movss	 DWORD PTR [eax+8], xmm1

; 70   : 	return(Scaled); };

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??DVector3d@@QBE?AV0@M@Z ENDP				; Vector3d::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??GVector3d@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_A$ = 12						; size = 4
??GVector3d@@QBE?AV0@ABV0@@Z PROC			; Vector3d::operator-, COMDAT
; _this$ = ecx

; 65   : 	{ Vector3d Diff(x-A.x, y-A.y, z-A.z);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00006	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  0000a	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [ecx+4]
  0000f	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00014	f3 0f 5c 10	 subss	 xmm2, DWORD PTR [eax]
  00018	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  0001d	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]

; 37   : 		x = a;

  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2

; 38   : 		y = b;

  00029	f3 0f 11 48 04	 movss	 DWORD PTR [eax+4], xmm1

; 39   : 		z = c;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 66   : 	return(Diff); };

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??GVector3d@@QBE?AV0@ABV0@@Z ENDP			; Vector3d::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??HVector3d@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_A$ = 12						; size = 4
??HVector3d@@QBE?AV0@ABV0@@Z PROC			; Vector3d::operator+, COMDAT
; _this$ = ecx

; 61   : 	{ Vector3d Sum(x+A.x, y+A.y, z+A.z);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _A$[ebp]
  00006	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]

; 37   : 		x = a;

  00014	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 61   : 	{ Vector3d Sum(x+A.x, y+A.y, z+A.z);

  00017	f3 0f 58 11	 addss	 xmm2, DWORD PTR [ecx]
  0001b	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]
  00020	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]

; 37   : 		x = a;

  00025	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2

; 38   : 		y = b;

  00029	f3 0f 11 48 04	 movss	 DWORD PTR [eax+4], xmm1

; 39   : 		z = c;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 62   : 	return(Sum); };

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??HVector3d@@QBE?AV0@ABV0@@Z ENDP			; Vector3d::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??4Vector3d@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
??4Vector3d@@QAEAAV0@ABV0@@Z PROC			; Vector3d::operator=, COMDAT
; _this$ = ecx

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 58   : 	return(*this);  };

  00016	8b c1		 mov	 eax, ecx
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4Vector3d@@QAEAAV0@ABV0@@Z ENDP			; Vector3d::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@MMM@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
??0Vector3d@@QAE@MMM@Z PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 35   : 	Vector3d(float a,float b,float c) // construct with initial point.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 	{
; 37   : 		x = a;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _a$[ebp]

; 38   : 		y = b;
; 39   : 		z = c;
; 40   : 	};

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _c$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0Vector3d@@QAE@MMM@Z ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@ABV0@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Vector3d@@QAE@ABV0@@Z PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 28   : 	Vector3d(const Vector3d &a) // constructor copies existing vector.

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	{
; 30   : 		x = a.x;

  00003	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 31   : 		y = a.y;

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 32   : 		z = a.z;

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 33   : 	};

  00016	8b c1		 mov	 eax, ecx
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0Vector3d@@QAE@ABV0@@Z ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\spherelib\vector.h
;	COMDAT ??0Vector3d@@QAE@XZ
_TEXT	SEGMENT
??0Vector3d@@QAE@XZ PROC				; Vector3d::Vector3d, COMDAT
; _this$ = ecx

; 26   : 	Vector3d(void) { };  // null constructor, does not inialize point.

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0Vector3d@@QAE@XZ ENDP				; Vector3d::Vector3d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 1136 :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  00008	83 ec 08	 sub	 esp, 8
  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	e8 00 00 00 00	 call	 _sqrt
  00018	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]

; 1136 :         {return (sqrtf(_X)); }

  0001b	d9 45 08	 fld	 DWORD PTR tv129[ebp]

; 775  :     return (float)sqrt(_X);

  0001e	83 c4 08	 add	 esp, 8

; 1136 :         {return (sqrtf(_X)); }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  00008	83 ec 08	 sub	 esp, 8
  0000b	0f 5a c0	 cvtps2pd xmm0, xmm0
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	e8 00 00 00 00	 call	 _sqrt
  00018	d9 5d 08	 fstp	 DWORD PTR tv72[ebp]
  0001b	d9 45 08	 fld	 DWORD PTR tv72[ebp]
  0001e	83 c4 08	 add	 esp, 8

; 776  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
END
