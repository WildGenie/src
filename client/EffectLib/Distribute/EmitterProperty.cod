; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\EffectLib\EmitterProperty.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0CEmitterProperty@@QAE@XZ			; CEmitterProperty::CEmitterProperty
PUBLIC	??1CEmitterProperty@@UAE@XZ			; CEmitterProperty::~CEmitterProperty
PUBLIC	?Clear@CEmitterProperty@@QAEXXZ			; CEmitterProperty::Clear
PUBLIC	?GetEmitterShape@CEmitterProperty@@QAEEXZ	; CEmitterProperty::GetEmitterShape
PUBLIC	?GetEmitterAdvancedType@CEmitterProperty@@QAEEXZ ; CEmitterProperty::GetEmitterAdvancedType
PUBLIC	?isEmitFromEdge@CEmitterProperty@@QAEHXZ	; CEmitterProperty::isEmitFromEdge
PUBLIC	?GetEmittingSize@CEmitterProperty@@QAEXMPAM@Z	; CEmitterProperty::GetEmittingSize
PUBLIC	?GetEmittingAngularVelocity@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmittingAngularVelocity
PUBLIC	?GetEmittingDirectionX@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmittingDirectionX
PUBLIC	?GetEmittingDirectionY@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmittingDirectionY
PUBLIC	?GetEmittingDirectionZ@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmittingDirectionZ
PUBLIC	?GetEmittingVelocity@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmittingVelocity
PUBLIC	?GetEmissionCountPerSecond@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetEmissionCountPerSecond
PUBLIC	?GetParticleLifeTime@CEmitterProperty@@QAEXMPAM@Z ; CEmitterProperty::GetParticleLifeTime
PUBLIC	?GetParticleSizeX@CEmitterProperty@@QAEXMPAM@Z	; CEmitterProperty::GetParticleSizeX
PUBLIC	?GetParticleSizeY@CEmitterProperty@@QAEXMPAM@Z	; CEmitterProperty::GetParticleSizeY
PUBLIC	??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
PUBLIC	?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ; std::allocator<CTimeEvent<float> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal
PUBLIC	??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
PUBLIC	??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
PUBLIC	?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
PUBLIC	?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end
PUBLIC	?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
PUBLIC	?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front
PUBLIC	?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back
PUBLIC	?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear
PUBLIC	?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy
PUBLIC	??_GCEmitterProperty@@UAEPAXI@Z			; CEmitterProperty::`scalar deleting destructor'
PUBLIC	??1?$CTimeEvent@M@@QAE@XZ			; CTimeEvent<float>::~CTimeEvent<float>
PUBLIC	??_G?$CTimeEvent@M@@QAEPAXI@Z			; CTimeEvent<float>::`scalar deleting destructor'
PUBLIC	??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z ; GetTimeEventBlendValue<float>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
PUBLIC	??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->
PUBLIC	??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-
PUBLIC	??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
PUBLIC	??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z ; std::pointer_traits<CTimeEvent<float> *>::pointer_to
PUBLIC	??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z ; std::addressof<CTimeEvent<float> >
PUBLIC	??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >
PUBLIC	??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
PUBLIC	??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z ; std::_Distance<CTimeEvent<float> *,int>
PUBLIC	??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z ; std::advance<CTimeEvent<float> *,int>
PUBLIC	??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z		; operator<<float>
PUBLIC	??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z ; std::less<void>::operator()<CTimeEvent<float> &,float const &>
PUBLIC	??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z		; operator<<float>
PUBLIC	??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z ; std::less<void>::operator()<float const &,CTimeEvent<float> &>
PUBLIC	??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>
PUBLIC	??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >
PUBLIC	??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z ; std::_Iter_cat<CTimeEvent<float> *>
PUBLIC	??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CTimeEvent<float> *,int>
PUBLIC	??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CTimeEvent<float> *,int>
PUBLIC	??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Unchecked<CTimeEvent<float> *>
PUBLIC	??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z ; std::_Dist_type<CTimeEvent<float> *>
PUBLIC	??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z ; std::forward<CTimeEvent<float> * &>
PUBLIC	??_7CEmitterProperty@@6B@			; CEmitterProperty::`vftable'
PUBLIC	??_R4CEmitterProperty@@6B@			; CEmitterProperty::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEmitterProperty@@@8			; CEmitterProperty `RTTI Type Descriptor'
PUBLIC	??_R3CEmitterProperty@@8			; CEmitterProperty::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEmitterProperty@@8			; CEmitterProperty::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEmitterProperty@@8		; CEmitterProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_ECEmitterProperty@@UAEPAXI@Z:PROC		; CEmitterProperty::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__fltused:DWORD
;	COMDAT ??_R1A@?0A@EA@CEmitterProperty@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEmitterProperty@@8 DD FLAT:??_R0?AVCEmitterProperty@@@8 ; CEmitterProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEmitterProperty@@8
rdata$r	ENDS
;	COMDAT ??_R2CEmitterProperty@@8
rdata$r	SEGMENT
??_R2CEmitterProperty@@8 DD FLAT:??_R1A@?0A@EA@CEmitterProperty@@8 ; CEmitterProperty::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEmitterProperty@@8
rdata$r	SEGMENT
??_R3CEmitterProperty@@8 DD 00H				; CEmitterProperty::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEmitterProperty@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEmitterProperty@@@8
data$r	SEGMENT
??_R0?AVCEmitterProperty@@@8 DD FLAT:??_7type_info@@6B@	; CEmitterProperty `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEmitterProperty@@', 00H
data$r	ENDS
;	COMDAT ??_R4CEmitterProperty@@6B@
rdata$r	SEGMENT
??_R4CEmitterProperty@@6B@ DD 00H			; CEmitterProperty::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEmitterProperty@@@8
	DD	FLAT:??_R3CEmitterProperty@@8
rdata$r	ENDS
;	COMDAT ??_7CEmitterProperty@@6B@
CONST	SEGMENT
??_7CEmitterProperty@@6B@ DD FLAT:??_R4CEmitterProperty@@6B@ ; CEmitterProperty::`vftable'
	DD	FLAT:??_ECEmitterProperty@@UAEPAXI@Z
CONST	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z PROC ; std::forward<CTimeEvent<float> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z ENDP ; std::forward<CTimeEvent<float> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z PROC ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2553 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2557 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 35		 jle	 SHORT $LN26@Upper_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Upper_boun:
; File a:\vs\vc\include\algorithm

; 2559 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00029	f3 0f 10 04 d6	 movss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00031	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2563 : 		if (!_Pred(_Val, *_Mid))

  00034	77 0c		 ja	 SHORT $LN2@Upper_boun

; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;

  00036	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2567 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	2b c2		 sub	 eax, edx
  0003e	03 c8		 add	 ecx, eax

; 2568 : 			}
; 2569 : 		else

  00040	eb 02		 jmp	 SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2570 : 			_Count = _Count2;

  00042	8b ca		 mov	 ecx, edx
$LN1@Upper_boun:

; 2557 : 	while (0 < _Count)

  00044	85 c9		 test	 ecx, ecx
  00046	7f d8		 jg	 SHORT $LL4@Upper_boun
$LN26@Upper_boun:

; 2571 : 		}
; 2572 : 	return (_First);

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 2573 : 	}

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z PROC ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2508 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 31		 jle	 SHORT $LN26@Lower_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Lower_boun:
; File a:\vs\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	0f 2f 04 d6	 comiss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002d	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

  00030	76 0c		 jbe	 SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;

  00032	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2518 : 			_Count -= _Count2 + 1;

  00035	83 c8 ff	 or	 eax, -1
  00038	2b c2		 sub	 eax, edx
  0003a	03 c8		 add	 ecx, eax

; 2519 : 			}
; 2520 : 		else

  0003c	eb 02		 jmp	 SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

  0003e	8b ca		 mov	 ecx, edx
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

  00040	85 c9		 test	 ecx, ecx
  00042	7f dc		 jg	 SHORT $LL4@Lower_boun
$LN26@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 2524 : 	}

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z PROC ; std::_Dist_type<CTimeEvent<float> *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z ENDP ; std::_Dist_type<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z PROC ; std::_Unchecked<CTimeEvent<float> *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ENDP ; std::_Unchecked<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CTimeEvent<float> *,int>, COMDAT

; 689  : 	{	// increment iterator by offset, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 691  : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CTimeEvent<float> *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 751  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z PROC ; std::_Iter_cat<CTimeEvent<float> *>, COMDAT

; 405  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z ENDP ; std::_Iter_cat<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z PROC ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ENDP ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z PROC ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z ENDP ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z PROC ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 2580 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2584 : 			_Dist_type(_First))));

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2557 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 35		 jle	 SHORT $LN36@upper_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL12@upper_boun:
; File a:\vs\vc\include\algorithm

; 2559 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00029	f3 0f 10 04 d6	 movss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00031	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2563 : 		if (!_Pred(_Val, *_Mid))

  00034	77 0c		 ja	 SHORT $LN10@upper_boun

; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;

  00036	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2567 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	2b c2		 sub	 eax, edx
  0003e	03 c8		 add	 ecx, eax

; 2568 : 			}
; 2569 : 		else

  00040	eb 02		 jmp	 SHORT $LN9@upper_boun
$LN10@upper_boun:

; 2570 : 			_Count = _Count2;

  00042	8b ca		 mov	 ecx, edx
$LN9@upper_boun:

; 2557 : 	while (0 < _Count)

  00044	85 c9		 test	 ecx, ecx
  00046	7f d8		 jg	 SHORT $LL12@upper_boun
$LN36@upper_boun:

; 2584 : 			_Dist_type(_First))));

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 2585 : 	}

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ENDP ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z PROC ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2508 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 31		 jle	 SHORT $LN36@lower_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL12@lower_boun:
; File a:\vs\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	0f 2f 04 d6	 comiss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002d	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

  00030	76 0c		 jbe	 SHORT $LN10@lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;

  00032	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2518 : 			_Count -= _Count2 + 1;

  00035	83 c8 ff	 or	 eax, -1
  00038	2b c2		 sub	 eax, edx
  0003a	03 c8		 add	 ecx, eax

; 2519 : 			}
; 2520 : 		else

  0003c	eb 02		 jmp	 SHORT $LN9@lower_boun
$LN10@lower_boun:

; 2521 : 			_Count = _Count2;

  0003e	8b ca		 mov	 ecx, edx
$LN9@lower_boun:

; 2508 : 	while (0 < _Count)

  00040	85 c9		 test	 ecx, ecx
  00042	7f dc		 jg	 SHORT $LL12@lower_boun
$LN36@lower_boun:

; 2535 : 			_Dist_type(_First))));

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 2536 : 	}

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ENDP ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xstddef
;	COMDAT ??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z PROC ; std::less<void>::operator()<float const &,CTimeEvent<float> &>, COMDAT
; _this$ = ecx

; 263  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al
; File a:\vs\vc\include\xstddef

; 269  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z ENDP ; std::less<void>::operator()<float const &,CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z PROC		; operator<<float>, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 199  : 	return lhs < rhs.m_fTime;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al

; 200  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z ENDP		; operator<<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xstddef
;	COMDAT ??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z PROC ; std::less<void>::operator()<CTimeEvent<float> &,float const &>, COMDAT
; _this$ = ecx

; 263  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al
; File a:\vs\vc\include\xstddef

; 269  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z ENDP ; std::less<void>::operator()<CTimeEvent<float> &,float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z PROC		; operator<<float>, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 	return lhs.m_fTime < rhs;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al

; 194  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z ENDP		; operator<<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z PROC ; std::advance<CTimeEvent<float> *,int>, COMDAT

; 696  : 	{	// increment iterator by offset, arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z ENDP ; std::advance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z PROC ; std::_Distance<CTimeEvent<float> *,int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z ENDP ; std::_Distance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$1$ = 16						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z PROC ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2603 : 	{	// find range equivalent to _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0000a	2b cb		 sub	 ecx, ebx
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2607 : 	while (0 < _Count)

  00010	85 c9		 test	 ecx, ecx
  00012	7e 3c		 jle	 SHORT $LN5@Equal_rang
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00014	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00017	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001b	eb 03 8d 49 00	 npad	 5
$LL6@Equal_rang:
; File a:\vs\vc\include\algorithm

; 2609 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	f3 0f 10 04 d3	 movss	 xmm0, DWORD PTR [ebx+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 34 d3	 lea	 esi, DWORD PTR [ebx+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00031	0f 2f c8	 comiss	 xmm1, xmm0
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00034	89 75 10	 mov	 DWORD PTR __Mid$1$[ebp], esi
; File a:\vs\vc\include\algorithm

; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

  00037	76 0c		 jbe	 SHORT $LN4@Equal_rang

; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  0003f	2b c2		 sub	 eax, edx
  00041	03 c8		 add	 ecx, eax

; 2618 : 		else if (_Pred(_Val, *_Mid))

  00043	eb 07		 jmp	 SHORT $LN1@Equal_rang
$LN4@Equal_rang:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00045	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2618 : 		else if (_Pred(_Val, *_Mid))

  00048	76 12		 jbe	 SHORT $LN2@Equal_rang

; 2619 : 			_Count = _Count2;	// range in first half, loop

  0004a	8b ca		 mov	 ecx, edx
$LN1@Equal_rang:

; 2607 : 	while (0 < _Count)

  0004c	85 c9		 test	 ecx, ecx
  0004e	7f d0		 jg	 SHORT $LL6@Equal_rang
$LN5@Equal_rang:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	5e		 pop	 esi
  00054	89 18		 mov	 DWORD PTR [eax], ebx
  00056	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00059	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 2630 : 	}

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN2@Equal_rang:

; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);

  0005c	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0005f	8d 04 cb	 lea	 eax, DWORD PTR [ebx+ecx*8]
; File a:\vs\vc\include\algorithm

; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);

  00062	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00065	50		 push	 eax
  00066	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
  0006f	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00072	8b f0		 mov	 esi, eax
  00074	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Mid$1$[ebp]
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00080	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);

  00083	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00086	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00089	5e		 pop	 esi
  0008a	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\algorithm

; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));

  0008c	8b c1		 mov	 eax, ecx
  0008e	5b		 pop	 ebx

; 2630 : 	}

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z PROC ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >, COMDAT

; 2638 : 	{	// find range equivalent to _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00006	6a 00		 push	 0
  00008	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0000b	8d 45 f8	 lea	 eax, DWORD PTR __Ans$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00020	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00023	8b 4d f8	 mov	 ecx, DWORD PTR __Ans$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Ans$[ebp+4]
  0002b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\algorithm

; 2646 : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ENDP ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z PROC ; std::addressof<CTimeEvent<float> >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z ENDP ; std::addressof<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z PROC ; std::pointer_traits<CTimeEvent<float> *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z ENDP ; std::pointer_traits<CTimeEvent<float> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z PROC ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z ENDP ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z PROC ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>, COMDAT

; 2654 : 	{	// find range equivalent to _Val, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00006	6a 00		 push	 0

; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));

  00008	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  0000c	8d 45 f8	 lea	 eax, DWORD PTR __Ans$1[ebp]
  0000f	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  00012	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00015	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00024	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __Ans$1[ebp]
  0002a	89 08		 mov	 DWORD PTR [eax], ecx
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Ans$1[ebp+4]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\algorithm

; 2656 : 	}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ENDP ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 03	 shl	 eax, 3
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 03	 shl	 eax, 3
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+, COMDAT
; _this$ = ecx

; 365  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 368  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--, COMDAT
; _this$ = ecx

; 141  : 		--this->_Ptr;

  00000	83 01 f8	 add	 DWORD PTR [ecx], -8	; fffffff8H

; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 349  : 		}

  00005	c3		 ret	 0
??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->, COMDAT
; _this$ = ecx

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 330  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--, COMDAT
; _this$ = ecx

; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;

  00000	83 01 f8	 add	 DWORD PTR [ecx], -8	; fffffff8H

; 142  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 143  : 		}

  00005	c3		 ret	 0
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z
_TEXT	SEGMENT
_result$ = -8						; size = 8
_fElapsedTime$ = 8					; size = 4
_rVector$ = 12						; size = 4
_pReturnValue$ = 16					; size = 4
??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z PROC ; GetTimeEventBlendValue<float>, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _rVector$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 228  : {

  00006	83 ec 08	 sub	 esp, 8
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00010	75 0d		 jne	 SHORT $LN6@GetTimeEve

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00012	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 264  : 	}
; 265  : 
; 266  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN6@GetTimeEve:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0001f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00022	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00024	74 3c		 je	 SHORT $LN219@GetTimeEve

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00026	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002a	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fElapsedTime$[ebp]
  0002f	0f 2f c1	 comiss	 xmm0, xmm1
  00032	77 2e		 ja	 SHORT $LN219@GetTimeEve

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00034	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00038	76 0c		 jbe	 SHORT $LN3@GetTimeEve

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003a	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  0003d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00040	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 	}
; 265  : 
; 266  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN3@GetTimeEve:

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00046	8d 55 08	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00049	52		 push	 edx
  0004a	51		 push	 ecx
  0004b	50		 push	 eax
  0004c	8d 45 f8	 lea	 eax, DWORD PTR _result$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00055	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00058	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _result$[ebp+4]
  0005e	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00060	74 0c		 je	 SHORT $LN2@GetTimeEve
$LN219@GetTimeEve:

; 258  : 		*pReturnValue = result.first->m_Value;

  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 	}
; 265  : 
; 266  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN2@GetTimeEve:

; 259  : 	else
; 260  : 	{
; 261  : 		--result.first;
; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0006e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00072	0f 28 d0	 movaps	 xmm2, xmm0
  00075	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  0007a	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fElapsedTime$[ebp]
  0007f	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00083	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00088	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0008d	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00090	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00094	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  00099	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2

; 264  : 	}
; 265  : 
; 266  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z ENDP ; GetTimeEventBlendValue<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CTimeEvent@M@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CTimeEvent@M@@QAEPAXI@Z PROC			; CTimeEvent<float>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 09		 je	 SHORT $LN6@scalar
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??_G?$CTimeEvent@M@@QAEPAXI@Z ENDP			; CTimeEvent<float>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??1?$CTimeEvent@M@@QAE@XZ
_TEXT	SEGMENT
??1?$CTimeEvent@M@@QAE@XZ PROC				; CTimeEvent<float>::~CTimeEvent<float>, COMDAT
; _this$ = ecx

; 121  : 	~CTimeEvent(){}

  00000	c3		 ret	 0
??1?$CTimeEvent@M@@QAE@XZ ENDP				; CTimeEvent<float>::~CTimeEvent<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEmitterProperty@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEmitterProperty@@UAEPAXI@Z PROC			; CEmitterProperty::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEmitterProperty@@UAE@XZ ; CEmitterProperty::~CEmitterProperty
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCEmitterProperty@@UAEPAXI@Z ENDP			; CEmitterProperty::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 08	 sub	 eax, 8

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front, COMDAT
; _this$ = ecx

; 1224 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1225 : 		}

  00002	c3		 ret	 0
?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z PROC ; std::allocator<CTimeEvent<float> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ENDP ; std::allocator<CTimeEvent<float> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ PROC	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ ENDP	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetParticleSizeY@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetParticleSizeY@CEmitterProperty@@QAEXMPAM@Z PROC	; CEmitterProperty::GetParticleSizeY, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 81 a4 00 00
	00		 mov	 eax, DWORD PTR [ecx+164]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 65   : 	GetTimeEventBlendValue(fTime, m_TimeEventSizeY, pfValue);

  0000c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00011	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+168]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 65   : 	GetTimeEventBlendValue(fTime, m_TimeEventSizeY, pfValue);

  00017	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0001c	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  0001e	75 0f		 jne	 SHORT $LN8@GetParticl

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 66   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
$LN8@GetParticl:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0002f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00032	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00034	74 39		 je	 SHORT $LN221@GetParticl

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00036	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003a	0f 2f c1	 comiss	 xmm0, xmm1
  0003d	77 30		 ja	 SHORT $LN221@GetParticl

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  0003f	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00043	76 0e		 jbe	 SHORT $LN5@GetParticl

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00048	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 66   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
$LN5@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00053	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	50		 push	 eax
  00059	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00065	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  0006b	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  0006d	74 0e		 je	 SHORT $LN4@GetParticl
$LN221@GetParticl:

; 258  : 		*pReturnValue = result.first->m_Value;

  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 66   : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN4@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0007d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00081	0f 28 d0	 movaps	 xmm2, xmm0
  00084	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00089	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  0008e	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00092	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00097	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0009f	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000a3	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a8	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 66   : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?GetParticleSizeY@CEmitterProperty@@QAEXMPAM@Z ENDP	; CEmitterProperty::GetParticleSizeY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetParticleSizeX@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetParticleSizeX@CEmitterProperty@@QAEXMPAM@Z PROC	; CEmitterProperty::GetParticleSizeX, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 60   : 	GetTimeEventBlendValue(fTime, m_TimeEventSizeX, pfValue);

  0000c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00011	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [ecx+156]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 60   : 	GetTimeEventBlendValue(fTime, m_TimeEventSizeX, pfValue);

  00017	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0001c	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  0001e	75 0f		 jne	 SHORT $LN8@GetParticl

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 61   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
$LN8@GetParticl:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0002f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00032	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00034	74 39		 je	 SHORT $LN221@GetParticl

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00036	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003a	0f 2f c1	 comiss	 xmm0, xmm1
  0003d	77 30		 ja	 SHORT $LN221@GetParticl

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  0003f	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00043	76 0e		 jbe	 SHORT $LN5@GetParticl

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00048	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 61   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
$LN5@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00053	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	50		 push	 eax
  00059	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00065	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  0006b	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  0006d	74 0e		 je	 SHORT $LN4@GetParticl
$LN221@GetParticl:

; 258  : 		*pReturnValue = result.first->m_Value;

  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 61   : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN4@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0007d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00081	0f 28 d0	 movaps	 xmm2, xmm0
  00084	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00089	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  0008e	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00092	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00097	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0009f	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000a3	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a8	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 61   : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?GetParticleSizeX@CEmitterProperty@@QAEXMPAM@Z ENDP	; CEmitterProperty::GetParticleSizeX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetParticleLifeTime@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetParticleLifeTime@CEmitterProperty@@QAEXMPAM@Z PROC	; CEmitterProperty::GetParticleLifeTime, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 55   : 	GetTimeEventBlendValue(fTime, m_TimeEventLifeTime, pfValue);

  0000c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00011	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 55   : 	GetTimeEventBlendValue(fTime, m_TimeEventLifeTime, pfValue);

  00017	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0001c	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  0001e	75 0f		 jne	 SHORT $LN8@GetParticl

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 56   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
$LN8@GetParticl:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0002f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00032	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00034	74 39		 je	 SHORT $LN221@GetParticl

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00036	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003a	0f 2f c1	 comiss	 xmm0, xmm1
  0003d	77 30		 ja	 SHORT $LN221@GetParticl

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  0003f	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00043	76 0e		 jbe	 SHORT $LN5@GetParticl

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00048	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 56   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
$LN5@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00053	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	50		 push	 eax
  00059	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00065	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  0006b	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  0006d	74 0e		 je	 SHORT $LN4@GetParticl
$LN221@GetParticl:

; 258  : 		*pReturnValue = result.first->m_Value;

  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 56   : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN4@GetParticl:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0007d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00081	0f 28 d0	 movaps	 xmm2, xmm0
  00084	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00089	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  0008e	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00092	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00097	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0009f	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000a3	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a8	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 56   : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?GetParticleLifeTime@CEmitterProperty@@QAEXMPAM@Z ENDP	; CEmitterProperty::GetParticleLifeTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmissionCountPerSecond@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmissionCountPerSecond@CEmitterProperty@@QAEXMPAM@Z PROC ; CEmitterProperty::GetEmissionCountPerSecond, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR [ecx+128]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 50   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmissionCountPerSecond, pfValue);

  0000c	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00011	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [ecx+132]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 50   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmissionCountPerSecond, pfValue);

  00017	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0001c	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  0001e	75 0f		 jne	 SHORT $LN8@GetEmissio

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00020	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 51   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
$LN8@GetEmissio:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0002f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00032	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00034	74 39		 je	 SHORT $LN221@GetEmissio

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00036	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003a	0f 2f c1	 comiss	 xmm0, xmm1
  0003d	77 30		 ja	 SHORT $LN221@GetEmissio

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  0003f	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00043	76 0e		 jbe	 SHORT $LN5@GetEmissio

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  00045	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00048	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 51   : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
$LN5@GetEmissio:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00053	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	50		 push	 eax
  00059	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00065	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  0006b	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  0006d	74 0e		 je	 SHORT $LN4@GetEmissio
$LN221@GetEmissio:

; 258  : 		*pReturnValue = result.first->m_Value;

  0006f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00072	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 51   : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN4@GetEmissio:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0007d	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00081	0f 28 d0	 movaps	 xmm2, xmm0
  00084	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00089	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  0008e	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00092	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00097	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0009f	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000a3	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a8	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 51   : }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?GetEmissionCountPerSecond@CEmitterProperty@@QAEXMPAM@Z ENDP ; CEmitterProperty::GetEmissionCountPerSecond
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingVelocity@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingVelocity@CEmitterProperty@@QAEXMPAM@Z PROC	; CEmitterProperty::GetEmittingVelocity, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 45   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingVelocity, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 78	 mov	 ecx, DWORD PTR [ecx+120]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 45   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingVelocity, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 46   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 46   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 46   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 46   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingVelocity@CEmitterProperty@@QAEXMPAM@Z ENDP	; CEmitterProperty::GetEmittingVelocity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingDirectionZ@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingDirectionZ@CEmitterProperty@@QAEXMPAM@Z PROC ; CEmitterProperty::GetEmittingDirectionZ, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 40   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionZ, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 40   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionZ, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 41   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 41   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 41   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 41   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingDirectionZ@CEmitterProperty@@QAEXMPAM@Z ENDP ; CEmitterProperty::GetEmittingDirectionZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingDirectionY@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingDirectionY@CEmitterProperty@@QAEXMPAM@Z PROC ; CEmitterProperty::GetEmittingDirectionY, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 35   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionY, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 35   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionY, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 36   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 36   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 36   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 36   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingDirectionY@CEmitterProperty@@QAEXMPAM@Z ENDP ; CEmitterProperty::GetEmittingDirectionY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingDirectionX@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingDirectionX@CEmitterProperty@@QAEXMPAM@Z PROC ; CEmitterProperty::GetEmittingDirectionX, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 30   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionX, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 30   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingDirectionX, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 31   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 31   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 31   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 31   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingDirectionX@CEmitterProperty@@QAEXMPAM@Z ENDP ; CEmitterProperty::GetEmittingDirectionX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingAngularVelocity@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingAngularVelocity@CEmitterProperty@@QAEXMPAM@Z PROC ; CEmitterProperty::GetEmittingAngularVelocity, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 25   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingAngularVelocity, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 25   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingAngularVelocity, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 26   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 26   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 26   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 26   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingAngularVelocity@CEmitterProperty@@QAEXMPAM@Z ENDP ; CEmitterProperty::GetEmittingAngularVelocity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmittingSize@CEmitterProperty@@QAEXMPAM@Z
_TEXT	SEGMENT
_result$1 = -12						; size = 8
_fElapsedTime$ = -4					; size = 4
_fTime$ = 8						; size = 4
_pfValue$ = 12						; size = 4
?GetEmittingSize@CEmitterProperty@@QAEXMPAM@Z PROC	; CEmitterProperty::GetEmittingSize, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00006	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 20   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingSize, pfValue);

  00009	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fTime$[ebp]
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0000e	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 20   : 	GetTimeEventBlendValue(fTime, m_TimeEventEmittingSize, pfValue);

  00011	f3 0f 11 4d fc	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00016	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00018	75 0f		 jne	 SHORT $LN8@GetEmittin

; 230  : 	{
; 231  : 		*pReturnValue = T();

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 21   : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN8@GetEmittin:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00029	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0002c	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  0002e	74 39		 je	 SHORT $LN221@GetEmittin

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00030	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00034	0f 2f c1	 comiss	 xmm0, xmm1
  00037	77 30		 ja	 SHORT $LN221@GetEmittin

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00039	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  0003d	76 0e		 jbe	 SHORT $LN5@GetEmittin

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00042	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00045	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 21   : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN5@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0004d	8d 55 fc	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00050	52		 push	 edx
  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	8d 45 f4	 lea	 eax, DWORD PTR _result$1[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _result$1[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0005f	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _result$1[ebp+4]
  00065	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00067	74 0e		 je	 SHORT $LN4@GetEmittin
$LN221@GetEmittin:

; 258  : 		*pReturnValue = result.first->m_Value;

  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 21   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN4@GetEmittin:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00077	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  00083	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fTime$[ebp]
  00088	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  0008c	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00091	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00096	8b 45 0c	 mov	 eax, DWORD PTR _pfValue$[ebp]
  00099	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0009d	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 21   : }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
?GetEmittingSize@CEmitterProperty@@QAEXMPAM@Z ENDP	; CEmitterProperty::GetEmittingSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?isEmitFromEdge@CEmitterProperty@@QAEHXZ
_TEXT	SEGMENT
?isEmitFromEdge@CEmitterProperty@@QAEHXZ PROC		; CEmitterProperty::isEmitFromEdge, COMDAT
; _this$ = ecx

; 14   : 	return m_bEmitFromEdgeFlag;

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 15   : }

  00003	c3		 ret	 0
?isEmitFromEdge@CEmitterProperty@@QAEHXZ ENDP		; CEmitterProperty::isEmitFromEdge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmitterAdvancedType@CEmitterProperty@@QAEEXZ
_TEXT	SEGMENT
?GetEmitterAdvancedType@CEmitterProperty@@QAEEXZ PROC	; CEmitterProperty::GetEmitterAdvancedType, COMDAT
; _this$ = ecx

; 10   : 	return m_byEmitterAdvancedType;

  00000	8a 41 15	 mov	 al, BYTE PTR [ecx+21]

; 11   : }

  00003	c3		 ret	 0
?GetEmitterAdvancedType@CEmitterProperty@@QAEEXZ ENDP	; CEmitterProperty::GetEmitterAdvancedType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?GetEmitterShape@CEmitterProperty@@QAEEXZ
_TEXT	SEGMENT
?GetEmitterShape@CEmitterProperty@@QAEEXZ PROC		; CEmitterProperty::GetEmitterShape, COMDAT
; _this$ = ecx

; 6    : 	return m_byEmitterShape;

  00000	8a 41 14	 mov	 al, BYTE PTR [ecx+20]

; 7    : }

  00003	c3		 ret	 0
?GetEmitterShape@CEmitterProperty@@QAEEXZ ENDP		; CEmitterProperty::GetEmitterShape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ?Clear@CEmitterProperty@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = -12						; size = 12
?Clear@CEmitterProperty@@QAEXXZ PROC			; CEmitterProperty::Clear, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 70   : 	m_dwMaxEmissionCount = 0;

  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000d	0f 57 c9	 xorps	 xmm1, xmm1

; 71   : 
; 72   : 	m_fCycleLength = 0.0f;

  00010	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 79   : 	m_v3EmittingSize = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00017	f3 0f 10 c1	 movss	 xmm0, xmm1
  0001b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00022	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00029	66 c7 41 14 00
	00		 mov	 WORD PTR [ecx+20], 0
  0002f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 80   : 	m_fEmittingRadius = 0.0f;

  00036	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0003d	0f 14 c1	 unpcklps xmm0, xmm1
  00040	66 0f d6 41 1c	 movq	 QWORD PTR [ecx+28], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 79   : 	m_v3EmittingSize = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp+8]
  0004f	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 82   : 	m_v3EmittingDirection = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00052	0f 14 c9	 unpcklps xmm1, xmm1
  00055	66 0f d6 49 2c	 movq	 QWORD PTR [ecx+44], xmm1
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 82   : 	m_v3EmittingDirection = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00061	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp+8]
  00064	89 41 34	 mov	 DWORD PTR [ecx+52], eax
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00067	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0006a	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  0006d	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00070	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00073	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  00076	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00079	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  0007c	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  0007f	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00082	89 41 78	 mov	 DWORD PTR [ecx+120], eax
  00085	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR [ecx+128]
  0008b	89 81 84 00 00
	00		 mov	 DWORD PTR [ecx+132], eax
  00091	8b 81 8c 00 00
	00		 mov	 eax, DWORD PTR [ecx+140]
  00097	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
  0009d	8b 81 98 00 00
	00		 mov	 eax, DWORD PTR [ecx+152]
  000a3	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax
  000a9	8b 81 a4 00 00
	00		 mov	 eax, DWORD PTR [ecx+164]
  000af	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax
  000b5	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  000b8	89 41 48	 mov	 DWORD PTR [ecx+72], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 94   : }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?Clear@CEmitterProperty@@QAEXXZ ENDP			; CEmitterProperty::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ??1CEmitterProperty@@UAE@XZ
_TEXT	SEGMENT
??1CEmitterProperty@@UAE@XZ PROC			; CEmitterProperty::~CEmitterProperty, COMDAT
; _this$ = ecx

; 101  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEmitterProperty@@6B@
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  0000f	85 c0		 test	 eax, eax
  00011	74 27		 je	 SHORT $LN15@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0

; 1630 : 			this->_Mylast = pointer();

  00026	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0

; 1631 : 			this->_Myend = pointer();

  00030	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
$LN15@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  0003a	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  00040	85 c0		 test	 eax, eax
  00042	74 27		 je	 SHORT $LN50@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004a	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0004d	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], 0

; 1630 : 			this->_Mylast = pointer();

  00057	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], 0

; 1631 : 			this->_Myend = pointer();

  00061	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
$LN50@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  0006b	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [esi+140]
  00071	85 c0		 test	 eax, eax
  00073	74 27		 je	 SHORT $LN85@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0007e	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0

; 1630 : 			this->_Mylast = pointer();

  00088	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0

; 1631 : 			this->_Myend = pointer();

  00092	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], 0
$LN85@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  0009c	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000a2	85 c0		 test	 eax, eax
  000a4	74 27		 je	 SHORT $LN120@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ac	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000af	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 1630 : 			this->_Mylast = pointer();

  000b9	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0

; 1631 : 			this->_Myend = pointer();

  000c3	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
$LN120@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  000cd	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  000d0	85 c0		 test	 eax, eax
  000d2	74 1e		 je	 SHORT $LN155@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000da	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000dd	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 1630 : 			this->_Mylast = pointer();

  000e4	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 1631 : 			this->_Myend = pointer();

  000eb	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
$LN155@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  000f2	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  000f5	85 c0		 test	 eax, eax
  000f7	74 1e		 je	 SHORT $LN190@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ff	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00102	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 1630 : 			this->_Mylast = pointer();

  00109	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 1631 : 			this->_Myend = pointer();

  00110	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0
$LN190@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  00117	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0011a	85 c0		 test	 eax, eax
  0011c	74 1e		 je	 SHORT $LN225@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00124	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00127	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 1630 : 			this->_Mylast = pointer();

  0012e	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 1631 : 			this->_Myend = pointer();

  00135	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
$LN225@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  0013c	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  0013f	85 c0		 test	 eax, eax
  00141	74 1e		 je	 SHORT $LN260@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00149	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0014c	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 1630 : 			this->_Mylast = pointer();

  00153	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 1631 : 			this->_Myend = pointer();

  0015a	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN260@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  00161	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00164	85 c0		 test	 eax, eax
  00166	74 1e		 je	 SHORT $LN295@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00168	50		 push	 eax
  00169	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0016e	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00171	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 1630 : 			this->_Mylast = pointer();

  00178	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0

; 1631 : 			this->_Myend = pointer();

  0017f	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
$LN295@CEmitterPr:

; 1623 : 		if (this->_Myfirst != pointer())

  00186	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00189	85 c0		 test	 eax, eax
  0018b	74 1e		 je	 SHORT $LN330@CEmitterPr
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00193	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00196	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1630 : 			this->_Mylast = pointer();

  0019d	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 1631 : 			this->_Myend = pointer();

  001a4	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
$LN330@CEmitterPr:
  001ab	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 102  : }

  001ac	c3		 ret	 0
??1CEmitterProperty@@UAE@XZ ENDP			; CEmitterProperty::~CEmitterProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp
;	COMDAT ??0CEmitterProperty@@QAE@XZ
_TEXT	SEGMENT
??0CEmitterProperty@@QAE@XZ PROC			; CEmitterProperty::CEmitterProperty, COMDAT
; _this$ = ecx

; 97   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEmitterProperty@@6B@
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00009	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 483  : 		_Mylast = pointer();

  00010	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 484  : 		_Myend = pointer();

  00017	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0

; 482  : 		_Myfirst = pointer();

  0001e	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 483  : 		_Mylast = pointer();

  00025	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0

; 484  : 		_Myend = pointer();

  0002c	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 482  : 		_Myfirst = pointer();

  00033	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 483  : 		_Mylast = pointer();

  0003a	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 484  : 		_Myend = pointer();

  00041	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0

; 482  : 		_Myfirst = pointer();

  00048	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 483  : 		_Mylast = pointer();

  0004f	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 484  : 		_Myend = pointer();

  00056	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0

; 482  : 		_Myfirst = pointer();

  0005d	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 483  : 		_Mylast = pointer();

  00064	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 484  : 		_Myend = pointer();

  0006b	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0

; 482  : 		_Myfirst = pointer();

  00072	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 483  : 		_Mylast = pointer();

  00079	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 484  : 		_Myend = pointer();

  00080	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0

; 482  : 		_Myfirst = pointer();

  00087	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 483  : 		_Mylast = pointer();

  00091	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0

; 484  : 		_Myend = pointer();

  0009b	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0

; 482  : 		_Myfirst = pointer();

  000a5	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0

; 483  : 		_Mylast = pointer();

  000af	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], 0

; 484  : 		_Myend = pointer();

  000b9	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], 0

; 482  : 		_Myfirst = pointer();

  000c3	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], 0

; 483  : 		_Mylast = pointer();

  000cd	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], 0

; 484  : 		_Myend = pointer();

  000d7	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0

; 482  : 		_Myfirst = pointer();

  000e1	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0

; 483  : 		_Mylast = pointer();

  000eb	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0

; 484  : 		_Myend = pointer();

  000f5	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\emitterproperty.cpp

; 98   : 	Clear();

  000ff	e8 00 00 00 00	 call	 ?Clear@CEmitterProperty@@QAEXXZ ; CEmitterProperty::Clear

; 99   : }

  00104	8b c6		 mov	 eax, esi
  00106	5e		 pop	 esi
  00107	c3		 ret	 0
??0CEmitterProperty@@QAE@XZ ENDP			; CEmitterProperty::CEmitterProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
END
