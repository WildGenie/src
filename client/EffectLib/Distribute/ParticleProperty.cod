; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\EffectLib\ParticleProperty.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0DWORDCOLOR@@QAE@ABU0@@Z			; DWORDCOLOR::DWORDCOLOR
PUBLIC	??4DWORDCOLOR@@QAEAAU0@ABU0@@Z			; DWORDCOLOR::operator=
PUBLIC	??0CParticleProperty@@QAE@XZ			; CParticleProperty::CParticleProperty
PUBLIC	??1CParticleProperty@@UAE@XZ			; CParticleProperty::~CParticleProperty
PUBLIC	?Clear@CParticleProperty@@QAEXXZ		; CParticleProperty::Clear
PUBLIC	?InsertTexture@CParticleProperty@@QAEXPBD@Z	; CParticleProperty::InsertTexture
PUBLIC	?SetTexture@CParticleProperty@@QAE_NPBD@Z	; CParticleProperty::SetTexture
PUBLIC	??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
PUBLIC	??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@ABV01@@Z ; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
PUBLIC	?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ; std::allocator<CTimeEvent<float> >::deallocate
PUBLIC	?allocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEPAV?$CTimeEvent@M@@I@Z ; std::allocator<CTimeEvent<float> >::allocate
PUBLIC	?max_size@?$allocator@V?$CTimeEvent@M@@@std@@QBEIXZ ; std::allocator<CTimeEvent<float> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@M@@@2@@Z ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEPAV?$CTimeEvent@M@@I@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Change_alloc
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal
PUBLIC	??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
PUBLIC	??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
PUBLIC	??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=
PUBLIC	?capacity@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::capacity
PUBLIC	?size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::size
PUBLIC	?max_size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::max_size
PUBLIC	?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
PUBLIC	?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear
PUBLIC	?_Buy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAE_NI@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Buy
PUBLIC	?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy
PUBLIC	?_Xlen@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IBEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlen
PUBLIC	??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@XZ ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >
PUBLIC	??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@ABV01@@Z ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >
PUBLIC	?deallocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::allocator<CTimeEvent<DWORDCOLOR> >::deallocate
PUBLIC	?allocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocate
PUBLIC	?max_size@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QBEIXZ ; std::allocator<CTimeEvent<DWORDCOLOR> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@2@@Z ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Change_alloc
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Getal
PUBLIC	??0?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??1?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::~vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::operator=
PUBLIC	?capacity@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::capacity
PUBLIC	?size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::size
PUBLIC	?max_size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
PUBLIC	?empty@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBE_NXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::empty
PUBLIC	?clear@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::clear
PUBLIC	?_Buy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAE_NI@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Buy
PUBLIC	?_Destroy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Tidy
PUBLIC	?_Xlen@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IBEXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlen
PUBLIC	??0?$allocator@PAVCGraphicImage@@@std@@QAE@XZ	; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>
PUBLIC	??0?$allocator@PAVCGraphicImage@@@std@@QAE@ABV01@@Z ; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>
PUBLIC	?deallocate@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@I@Z ; std::allocator<CGraphicImage *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCGraphicImage@@@std@@QAEPAPAVCGraphicImage@@I@Z ; std::allocator<CGraphicImage *>::allocate
PUBLIC	?construct@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@ABQAV3@@Z ; std::allocator<CGraphicImage *>::construct
PUBLIC	?max_size@?$allocator@PAVCGraphicImage@@@std@@QBEIXZ ; std::allocator<CGraphicImage *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImage@@@2@@Z ; std::allocator_traits<std::allocator<CGraphicImage *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::_Wrap_alloc<std::allocator<CGraphicImage *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicImage *> >::_Vector_val<std::_Simple_types<CGraphicImage *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImage@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Change_alloc
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Getal
PUBLIC	??0?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::vector<CGraphicImage *,std::allocator<CGraphicImage *> >
PUBLIC	??1?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::~vector<CGraphicImage *,std::allocator<CGraphicImage *> >
PUBLIC	??4?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::operator=
PUBLIC	?capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Unused_capacity
PUBLIC	?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size
PUBLIC	?max_size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::max_size
PUBLIC	?empty@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBE_NXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::empty
PUBLIC	?push_back@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXABQAVCGraphicImage@@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::push_back
PUBLIC	?clear@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::clear
PUBLIC	?_Buy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAE_NI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Buy
PUBLIC	?_Destroy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXPAPAVCGraphicImage@@0@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEII@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBE_NPBQAVCGraphicImage@@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXPAPAVCGraphicImage@@0@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Orphan_range
PUBLIC	??4CParticleProperty@@QAEAAV0@ABV0@@Z		; CParticleProperty::operator=
PUBLIC	??_GCParticleProperty@@UAEPAXI@Z		; CParticleProperty::`scalar deleting destructor'
PUBLIC	?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ; CSingleton<CResourceManager>::Instance
PUBLIC	??$?9V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z ; std::operator!=<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >
PUBLIC	??1?$CTimeEvent@M@@QAE@XZ			; CTimeEvent<float>::~CTimeEvent<float>
PUBLIC	??_G?$CTimeEvent@M@@QAEPAXI@Z			; CTimeEvent<float>::`scalar deleting destructor'
PUBLIC	??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00@Z ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Ucopy@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEPAV?$CTimeEvent@M@@PAV2@00@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Ucopy<CTimeEvent<float> *>
PUBLIC	??$?9V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z ; std::operator!=<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??1?$CTimeEvent@UDWORDCOLOR@@@@QAE@XZ		; CTimeEvent<DWORDCOLOR>::~CTimeEvent<DWORDCOLOR>
PUBLIC	??0?$CTimeEvent@UDWORDCOLOR@@@@QAE@ABV0@@Z	; CTimeEvent<DWORDCOLOR>::CTimeEvent<DWORDCOLOR>
PUBLIC	??4?$CTimeEvent@UDWORDCOLOR@@@@QAEAAV0@ABV0@@Z	; CTimeEvent<DWORDCOLOR>::operator=
PUBLIC	??_G?$CTimeEvent@UDWORDCOLOR@@@@QAEPAXI@Z	; CTimeEvent<DWORDCOLOR>::`scalar deleting destructor'
PUBLIC	??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$_Ucopy@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV2@00@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Ucopy<CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$?9V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z ; std::operator!=<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >
PUBLIC	??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$_Ucopy@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Ucopy<CGraphicImage * *>
PUBLIC	??$addressof@QAVCGraphicImage@@@std@@YAPBQAVCGraphicImage@@ABQAV1@@Z ; std::addressof<CGraphicImage * const>
PUBLIC	??$construct@PAVCGraphicImage@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>
PUBLIC	??$construct@PAVCGraphicImage@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$_Umove@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Umove<CGraphicImage * *>
PUBLIC	??$_Allocate@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@IPAV1@@Z ; std::_Allocate<CTimeEvent<float> >
PUBLIC	??$_Allocate@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@IPAV1@@Z ; std::_Allocate<CTimeEvent<DWORDCOLOR> >
PUBLIC	??$_Allocate@PAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@IPAPAV1@@Z ; std::_Allocate<CGraphicImage *>
PUBLIC	??$?8V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z ; std::operator==<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >
PUBLIC	??$?8V?$CTimeEvent@M@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@M@@@0@0@Z ; std::operator==<CTimeEvent<float>,CTimeEvent<float> >
PUBLIC	??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >
PUBLIC	??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Uninitialized_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ; std::_Uninitialized_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	??$?8V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z ; std::operator==<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??$?8V?$CTimeEvent@UDWORDCOLOR@@@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@0@0@Z ; std::operator==<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >
PUBLIC	??$_Ptr_cat@V?$CTimeEvent@UDWORDCOLOR@@@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z ; std::_Ptr_cat<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >
PUBLIC	??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$_Uninitialized_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ; std::_Uninitialized_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
PUBLIC	??$?8V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z ; std::operator==<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >
PUBLIC	??$?8PAVCGraphicImage@@PAV0@@std@@YA_NABV?$allocator@PAVCGraphicImage@@@0@0@Z ; std::operator==<CGraphicImage *,CGraphicImage *>
PUBLIC	??$_Ptr_cat@PAVCGraphicImage@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImage@@0@Z ; std::_Ptr_cat<CGraphicImage *,CGraphicImage *>
PUBLIC	??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$_Uninitialized_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ; std::_Uninitialized_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z ; std::forward<CGraphicImage * &>
PUBLIC	??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>
PUBLIC	??$forward@ABQAVCGraphicImage@@@std@@YAABQAVCGraphicImage@@ABQAV1@@Z ; std::forward<CGraphicImage * const &>
PUBLIC	??$construct@PAVCGraphicImage@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ; std::_Uninitialized_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Unchecked<CTimeEvent<float> *>
PUBLIC	??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
PUBLIC	??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Unchecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@Z ; std::_Unchecked<CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
PUBLIC	??$_Rechecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAAAPAV?$CTimeEvent@UDWORDCOLOR@@@@AAPAV1@PAV1@@Z ; std::_Rechecked<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$_Unchecked@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z ; std::_Unchecked<CGraphicImage * *>
PUBLIC	??$_Uninit_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ; std::_Uninit_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$_Rechecked@PAPAVCGraphicImage@@PAPAV1@@std@@YAAAPAPAVCGraphicImage@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z ; std::allocator<CGraphicImage *>::construct<CGraphicImage *,CGraphicImage * &>
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
PUBLIC	??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >
PUBLIC	??$_Uninit_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ; std::_Uninit_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
PUBLIC	??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
PUBLIC	??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
PUBLIC	??$_Uninit_copy@PAVCGraphicImage@@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGraphicImage *,CGraphicImage *>
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
PUBLIC	??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >
PUBLIC	??$_Val_type@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z ; std::_Val_type<CGraphicImage * *>
PUBLIC	??$_Uninit_move@PAVCGraphicImage@@PAV1@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CGraphicImage *,CGraphicImage *,CGraphicImage *>
PUBLIC	??$construct@V?$CTimeEvent@M@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>
PUBLIC	??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
PUBLIC	??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >
PUBLIC	??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ; std::allocator<CTimeEvent<DWORDCOLOR> >::destroy<CTimeEvent<DWORDCOLOR> >
PUBLIC	??$forward@AAV?$CTimeEvent@M@@@std@@YAAAV?$CTimeEvent@M@@AAV1@@Z ; std::forward<CTimeEvent<float> &>
PUBLIC	??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@AAV3@@Z ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>
PUBLIC	??$forward@AAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAAAV?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@Z ; std::forward<CTimeEvent<DWORDCOLOR> &>
PUBLIC	??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@AAV3@@Z ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
PUBLIC	??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z ; std::allocator<CTimeEvent<float> >::construct<CTimeEvent<float>,CTimeEvent<float> &>
PUBLIC	??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z ; std::allocator<CTimeEvent<DWORDCOLOR> >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
PUBLIC	??_7CParticleProperty@@6B@			; CParticleProperty::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CParticleProperty@@6B@			; CParticleProperty::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCParticleProperty@@@8			; CParticleProperty `RTTI Type Descriptor'
PUBLIC	??_R3CParticleProperty@@8			; CParticleProperty::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CParticleProperty@@8			; CParticleProperty::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CParticleProperty@@8		; CParticleProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??_ECParticleProperty@@UAEPAXI@Z:PROC		; CParticleProperty::`vector deleting destructor'
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CParticleProperty@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CParticleProperty@@8 DD FLAT:??_R0?AVCParticleProperty@@@8 ; CParticleProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_R2CParticleProperty@@8
rdata$r	SEGMENT
??_R2CParticleProperty@@8 DD FLAT:??_R1A@?0A@EA@CParticleProperty@@8 ; CParticleProperty::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CParticleProperty@@8
rdata$r	SEGMENT
??_R3CParticleProperty@@8 DD 00H			; CParticleProperty::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCParticleProperty@@@8
data$r	SEGMENT
??_R0?AVCParticleProperty@@@8 DD FLAT:??_7type_info@@6B@ ; CParticleProperty `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCParticleProperty@@', 00H
data$r	ENDS
;	COMDAT ??_R4CParticleProperty@@6B@
rdata$r	SEGMENT
??_R4CParticleProperty@@6B@ DD 00H			; CParticleProperty::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCParticleProperty@@@8
	DD	FLAT:??_R3CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7CParticleProperty@@6B@
CONST	SEGMENT
??_7CParticleProperty@@6B@ DD FLAT:??_R4CParticleProperty@@6B@ ; CParticleProperty::`vftable'
	DD	FLAT:??_ECParticleProperty@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z$0
__unwindtable$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z$2
__ehfuncinfo$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z$0
__unwindtable$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z$2
__ehfuncinfo$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 138  : 	{}

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:
; File a:\vs\vc\include\xmemory0

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z PROC ; std::allocator<CTimeEvent<float> >::construct<CTimeEvent<float>,CTimeEvent<float> &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 601  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z ENDP ; std::allocator<CTimeEvent<float> >::construct<CTimeEvent<float>,CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@AAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@AAV3@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 138  : 	{}

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:
; File a:\vs\vc\include\xmemory0

; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@AAV3@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAAAV?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAAAV?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@Z PROC ; std::forward<CTimeEvent<DWORDCOLOR> &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAAAV?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@Z ENDP ; std::forward<CTimeEvent<DWORDCOLOR> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@AAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@AAV3@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN7@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@V?$CTimeEvent@M@@AAV1@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@AAV3@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$CTimeEvent@M@@@std@@YAAAV?$CTimeEvent@M@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$CTimeEvent@M@@@std@@YAAAV?$CTimeEvent@M@@AAV1@@Z PROC ; std::forward<CTimeEvent<float> &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$CTimeEvent@M@@@std@@YAAAV?$CTimeEvent@M@@AAV1@@Z ENDP ; std::forward<CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::destroy<CTimeEvent<DWORDCOLOR> >, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::destroy<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z PROC ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@M@@@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ENDP ; std::allocator<CTimeEvent<float> >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 138  : 	{}

  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:
; File a:\vs\vc\include\xmemory0

; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@V?$CTimeEvent@UDWORDCOLOR@@@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@AAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::construct<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@V?$CTimeEvent@M@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$CTimeEvent@M@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN11@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@V?$CTimeEvent@M@@AAV1@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@AAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::construct<CTimeEvent<float>,CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCGraphicImage@@PAV1@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCGraphicImage@@PAV1@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CGraphicImage *,CGraphicImage *,CGraphicImage *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCGraphicImage@@PAV1@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CGraphicImage *,CGraphicImage *,CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z PROC ; std::_Val_type<CGraphicImage * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z ENDP ; std::_Val_type<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@PAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@V?$CTimeEvent@M@@@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAXAAV?$allocator@V?$CTimeEvent@M@@@1@PAV?$CTimeEvent@M@@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAVCGraphicImage@@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAVCGraphicImage@@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CGraphicImage *,CGraphicImage *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAVCGraphicImage@@PAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGraphicImage *,CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	3b d7		 cmp	 edx, edi
  0000c	74 22		 je	 SHORT $LN49@Uninit_cop
  0000e	56		 push	 esi
  0000f	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_cop:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0a		 je	 SHORT $LN24@Uninit_cop
  00016	8b 02		 mov	 eax, DWORD PTR [edx]
  00018	89 06		 mov	 DWORD PTR [esi], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 138  : 	{}

  0001a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN24@Uninit_cop:
; File a:\vs\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

  00020	83 c2 08	 add	 edx, 8
  00023	83 c6 08	 add	 esi, 8
  00026	3b d7		 cmp	 edx, edi
  00028	75 e8		 jne	 SHORT $LL6@Uninit_cop

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5f		 pop	 edi

; 385  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN49@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5f		 pop	 edi

; 385  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	57		 push	 edi
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	3b cf		 cmp	 ecx, edi
  0000c	74 22		 je	 SHORT $LN45@Uninit_cop
  0000e	56		 push	 esi
  0000f	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_cop:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0a		 je	 SHORT $LN24@Uninit_cop
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	89 06		 mov	 DWORD PTR [esi], eax
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN24@Uninit_cop:
; File a:\vs\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

  00020	83 c1 08	 add	 ecx, 8
  00023	83 c6 08	 add	 esi, 8
  00026	3b cf		 cmp	 ecx, edi
  00028	75 e8		 jne	 SHORT $LL6@Uninit_cop

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5f		 pop	 edi

; 385  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN45@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5f		 pop	 edi

; 385  : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z PROC ; std::_Uninit_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ENDP ; std::_Uninit_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@UDWORDCOLOR@@@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::destroy<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@V?$CTimeEvent@M@@@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::destroy<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z PROC ; std::allocator<CGraphicImage *>::construct<CGraphicImage *,CGraphicImage * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z ENDP ; std::allocator<CGraphicImage *>::construct<CGraphicImage *,CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCGraphicImage@@PAPAV1@@std@@YAAAPAPAVCGraphicImage@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCGraphicImage@@PAPAV1@@std@@YAAAPAPAVCGraphicImage@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCGraphicImage@@PAPAV1@@std@@YAAAPAPAVCGraphicImage@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z PROC ; std::_Uninit_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z PROC ; std::_Unchecked<CGraphicImage * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@PAPAV1@@Z ENDP ; std::_Unchecked<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAAAPAV?$CTimeEvent@UDWORDCOLOR@@@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAAAPAV?$CTimeEvent@UDWORDCOLOR@@@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAAAPAV?$CTimeEvent@UDWORDCOLOR@@@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z PROC ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 417  : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@Z PROC ; std::_Unchecked<CTimeEvent<DWORDCOLOR> *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAV?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@Z ENDP ; std::_Unchecked<CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z PROC ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00010	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 417  : 	}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z PROC ; std::_Unchecked<CTimeEvent<float> *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ENDP ; std::_Unchecked<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImage@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicImage@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicImage@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCGraphicImage@@@std@@YAABQAVCGraphicImage@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCGraphicImage@@@std@@YAABQAVCGraphicImage@@ABQAV1@@Z PROC ; std::forward<CGraphicImage * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCGraphicImage@@@std@@YAABQAVCGraphicImage@@ABQAV1@@Z ENDP ; std::forward<CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicImage@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImage@@@1@PAPAVCGraphicImage@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z PROC ; std::forward<CGraphicImage * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCGraphicImage@@@std@@YAAAPAVCGraphicImage@@AAPAV1@@Z ENDP ; std::forward<CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@PAPAVCGraphicImage@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAPAPAVCGraphicImage@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<CGraphicImage * *,CGraphicImage * *,std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 2053 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2058 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicImage@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImage@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicImage@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImage@@0@Z PROC ; std::_Ptr_cat<CGraphicImage *,CGraphicImage *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicImage@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImage@@0@Z ENDP ; std::_Ptr_cat<CGraphicImage *,CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8PAVCGraphicImage@@PAV0@@std@@YA_NABV?$allocator@PAVCGraphicImage@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8PAVCGraphicImage@@PAV0@@std@@YA_NABV?$allocator@PAVCGraphicImage@@@0@0@Z PROC ; std::operator==<CGraphicImage *,CGraphicImage *>, COMDAT

; 661  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 662  : 	}

  00002	c3		 ret	 0
??$?8PAVCGraphicImage@@PAV0@@std@@YA_NABV?$allocator@PAVCGraphicImage@@@0@0@Z ENDP ; std::operator==<CGraphicImage *,CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 894  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 416  : 		_Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Uninitialized_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>, COMDAT

; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b d6		 cmp	 edx, esi
  0000f	74 14		 je	 SHORT $LN1@Copy_impl
$LL3@Copy_impl:
  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 142  : 		m_dwColor = r.m_dwColor;

  00015	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
; File a:\vs\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  00018	83 c2 08	 add	 edx, 8
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 142  : 		m_dwColor = r.m_dwColor;

  0001b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  0001e	83 c0 08	 add	 eax, 8
  00021	3b d6		 cmp	 edx, esi
  00023	75 ec		 jne	 SHORT $LL3@Copy_impl
$LN1@Copy_impl:
  00025	5e		 pop	 esi

; 2045 : 		*_Dest = *_First;
; 2046 : 	return (_Dest);
; 2047 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$CTimeEvent@UDWORDCOLOR@@@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$CTimeEvent@UDWORDCOLOR@@@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z PROC ; std::_Ptr_cat<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@V?$CTimeEvent@UDWORDCOLOR@@@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z ENDP ; std::_Ptr_cat<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8V?$CTimeEvent@UDWORDCOLOR@@@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8V?$CTimeEvent@UDWORDCOLOR@@@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@0@0@Z PROC ; std::operator==<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >, COMDAT

; 661  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 662  : 	}

  00002	c3		 ret	 0
??$?8V?$CTimeEvent@UDWORDCOLOR@@@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@0@0@Z ENDP ; std::operator==<CTimeEvent<DWORDCOLOR>,CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 894  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 416  : 		_Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Uninitialized_copy@PAV?$CTimeEvent@M@@PAV1@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 2043 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 14		 je	 SHORT $LN1@Copy_impl
$LL3@Copy_impl:

; 2045 : 		*_Dest = *_First;

  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	83 c1 08	 add	 ecx, 8
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ce		 cmp	 ecx, esi
  00023	75 ec		 jne	 SHORT $LL3@Copy_impl
$LN1@Copy_impl:
  00025	5e		 pop	 esi

; 2046 : 	return (_Dest);
; 2047 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z PROC ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@V?$CTimeEvent@M@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$CTimeEvent@M@@0@Z ENDP ; std::_Ptr_cat<CTimeEvent<float>,CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8V?$CTimeEvent@M@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@M@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8V?$CTimeEvent@M@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@M@@@0@0@Z PROC ; std::operator==<CTimeEvent<float>,CTimeEvent<float> >, COMDAT

; 661  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 662  : 	}

  00002	c3		 ret	 0
??$?8V?$CTimeEvent@M@@V0@@std@@YA_NABV?$allocator@V?$CTimeEvent@M@@@0@0@Z ENDP ; std::operator==<CTimeEvent<float>,CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 894  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@IPAPAV1@@Z PROC ; std::_Allocate<CGraphicImage *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@IPAPAV1@@Z ENDP ; std::_Allocate<CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@IPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@IPAV1@@Z PROC ; std::_Allocate<CTimeEvent<DWORDCOLOR> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@IPAV1@@Z ENDP ; std::_Allocate<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@IPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@IPAV1@@Z PROC ; std::_Allocate<CTimeEvent<float> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@IPAV1@@Z ENDP ; std::_Allocate<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Umove<CGraphicImage * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Umove<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@YAXPAPAVCGraphicImage@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@UDWORDCOLOR@@@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@YAXPAV?$CTimeEvent@M@@0AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImage@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImage@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImage@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImage@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImage@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImage@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::construct<CGraphicImage *,CGraphicImage * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCGraphicImage@@@std@@YAPBQAVCGraphicImage@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCGraphicImage@@@std@@YAPBQAVCGraphicImage@@ABQAV1@@Z PROC ; std::addressof<CGraphicImage * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCGraphicImage@@@std@@YAPBQAVCGraphicImage@@ABQAV1@@Z ENDP ; std::addressof<CGraphicImage * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Ucopy<CGraphicImage * *>, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1641 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEPAPAVCGraphicImage@@PAPAV2@00@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Ucopy<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z PROC ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi

; 2055 : 	_CSTD memmove(&*_Dest, &*_First,
; 2056 : 		_Count * sizeof (*_First));

  0000c	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi
  00013	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 : 	return (_Dest + _Count);

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_impl@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ENDP ; std::_Copy_impl<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >, COMDAT

; 901  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 902  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@PAVCGraphicImage@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<CGraphicImage *>,std::allocator<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV2@00@Z PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Ucopy<CTimeEvent<DWORDCOLOR> *>, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
  00019	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1641 : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV2@00@Z ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Ucopy<CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z PROC ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	57		 push	 edi

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000d	3b d7		 cmp	 edx, edi
  0000f	74 1b		 je	 SHORT $LN5@Copy_impl
  00011	56		 push	 esi
  00012	8b f2		 mov	 esi, edx
  00014	2b f0		 sub	 esi, eax
$LL7@Copy_impl:
  00016	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00018	83 c2 08	 add	 edx, 8
  0001b	89 08		 mov	 DWORD PTR [eax], ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 142  : 		m_dwColor = r.m_dwColor;

  0001d	8b 4c 06 04	 mov	 ecx, DWORD PTR [esi+eax+4]
  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  00024	83 c0 08	 add	 eax, 8
  00027	3b d7		 cmp	 edx, edi
  00029	75 eb		 jne	 SHORT $LL7@Copy_impl
  0002b	5e		 pop	 esi
$LN5@Copy_impl:
  0002c	5f		 pop	 edi

; 2067 : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z ENDP ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CTimeEvent@UDWORDCOLOR@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CTimeEvent@UDWORDCOLOR@@@@QAEPAXI@Z PROC		; CTimeEvent<DWORDCOLOR>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 09		 je	 SHORT $LN6@scalar
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??_G?$CTimeEvent@UDWORDCOLOR@@@@QAEPAXI@Z ENDP		; CTimeEvent<DWORDCOLOR>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??4?$CTimeEvent@UDWORDCOLOR@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4?$CTimeEvent@UDWORDCOLOR@@@@QAEAAV0@ABV0@@Z PROC	; CTimeEvent<DWORDCOLOR>::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 142  : 		m_dwColor = r.m_dwColor;

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??4?$CTimeEvent@UDWORDCOLOR@@@@QAEAAV0@ABV0@@Z ENDP	; CTimeEvent<DWORDCOLOR>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??0?$CTimeEvent@UDWORDCOLOR@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$CTimeEvent@UDWORDCOLOR@@@@QAE@ABV0@@Z PROC		; CTimeEvent<DWORDCOLOR>::CTimeEvent<DWORDCOLOR>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 138  : 	{}

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$CTimeEvent@UDWORDCOLOR@@@@QAE@ABV0@@Z ENDP		; CTimeEvent<DWORDCOLOR>::CTimeEvent<DWORDCOLOR>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??1?$CTimeEvent@UDWORDCOLOR@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CTimeEvent@UDWORDCOLOR@@@@QAE@XZ PROC		; CTimeEvent<DWORDCOLOR>::~CTimeEvent<DWORDCOLOR>, COMDAT
; _this$ = ecx

; 121  : 	~CTimeEvent(){}

  00000	c3		 ret	 0
??1?$CTimeEvent@UDWORDCOLOR@@@@QAE@XZ ENDP		; CTimeEvent<DWORDCOLOR>::~CTimeEvent<DWORDCOLOR>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT

; 901  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 902  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<CTimeEvent<DWORDCOLOR> >,std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEPAV?$CTimeEvent@M@@PAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEPAV?$CTimeEvent@M@@PAV2@00@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Ucopy<CTimeEvent<float> *>, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
  00019	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1641 : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEPAV?$CTimeEvent@M@@PAV2@00@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Ucopy<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00@Z PROC ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00009	56		 push	 esi

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  0000a	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	3b ce		 cmp	 ecx, esi
  0000f	74 14		 je	 SHORT $LN5@Copy_impl
$LL7@Copy_impl:

; 2045 : 		*_Dest = *_First;

  00011	8b 11		 mov	 edx, DWORD PTR [ecx]
  00013	89 10		 mov	 DWORD PTR [eax], edx
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	83 c1 08	 add	 ecx, 8
  0001b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001e	83 c0 08	 add	 eax, 8
  00021	3b ce		 cmp	 ecx, esi
  00023	75 ec		 jne	 SHORT $LL7@Copy_impl
$LN5@Copy_impl:
  00025	5e		 pop	 esi

; 2067 : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00@Z ENDP ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CTimeEvent@M@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CTimeEvent@M@@QAEPAXI@Z PROC			; CTimeEvent<float>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 09		 je	 SHORT $LN6@scalar
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00012	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??_G?$CTimeEvent@M@@QAEPAXI@Z ENDP			; CTimeEvent<float>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??1?$CTimeEvent@M@@QAE@XZ
_TEXT	SEGMENT
??1?$CTimeEvent@M@@QAE@XZ PROC				; CTimeEvent<float>::~CTimeEvent<float>, COMDAT
; _this$ = ecx

; 121  : 	~CTimeEvent(){}

  00000	c3		 ret	 0
??1?$CTimeEvent@M@@QAE@XZ ENDP				; CTimeEvent<float>::~CTimeEvent<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >, COMDAT

; 901  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 902  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@V?$CTimeEvent@M@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<CTimeEvent<float> >,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ PROC ; CSingleton<CResourceManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ENDP ; CSingleton<CResourceManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCParticleProperty@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCParticleProperty@@UAEPAXI@Z PROC			; CParticleProperty::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CParticleProperty@@UAE@XZ ; CParticleProperty::~CParticleProperty
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCParticleProperty@@UAEPAXI@Z ENDP			; CParticleProperty::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ??4CParticleProperty@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_c_ParticleProperty$ = 8				; size = 4
??4CParticleProperty@@QAEAAV0@ABV0@@Z PROC		; CParticleProperty::operator=, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 82   : 	m_byTexAniType = c_ParticleProperty.m_byTexAniType;

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_ParticleProperty$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  0000e	88 47 04	 mov	 BYTE PTR [edi+4], al

; 83   : 	m_fTexAniDelay = c_ParticleProperty.m_fTexAniDelay;
; 84   : 	m_bTexAniRandomStartFrameFlag = c_ParticleProperty.m_bTexAniRandomStartFrameFlag;
; 85   : 	
; 86   : 	m_bySrcBlendType = c_ParticleProperty.m_bySrcBlendType;
; 87   : 	m_byDestBlendType = c_ParticleProperty.m_byDestBlendType;
; 88   : 	m_byColorOperationType = c_ParticleProperty.m_byColorOperationType;
; 89   : 	
; 90   : 	m_byBillboardType = c_ParticleProperty.m_byBillboardType;
; 91   : 	
; 92   : 	m_byRotationType = c_ParticleProperty.m_byRotationType;
; 93   : 	m_fRotationSpeed = c_ParticleProperty.m_fRotationSpeed;
; 94   : 	m_wRotationRandomStartingBegin = c_ParticleProperty.m_wRotationRandomStartingBegin;
; 95   : 	m_wRotationRandomStartingEnd = c_ParticleProperty.m_wRotationRandomStartingEnd;
; 96   : 	
; 97   : 	m_bAttachFlag = c_ParticleProperty.m_bAttachFlag;
; 98   : 	m_bStretchFlag = c_ParticleProperty.m_bStretchFlag;
; 99   : 	
; 100  : 	m_TimeEventGravity = c_ParticleProperty.m_TimeEventGravity;

  00011	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  00014	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00017	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0001a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0001d	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00020	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00024	88 47 10	 mov	 BYTE PTR [edi+16], al
  00027	0f b6 46 11	 movzx	 eax, BYTE PTR [esi+17]
  0002b	88 47 11	 mov	 BYTE PTR [edi+17], al
  0002e	0f b6 46 12	 movzx	 eax, BYTE PTR [esi+18]
  00032	88 47 12	 mov	 BYTE PTR [edi+18], al
  00035	0f b6 46 13	 movzx	 eax, BYTE PTR [esi+19]
  00039	88 47 13	 mov	 BYTE PTR [edi+19], al
  0003c	0f b6 46 14	 movzx	 eax, BYTE PTR [esi+20]
  00040	88 47 14	 mov	 BYTE PTR [edi+20], al
  00043	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00046	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00049	0f b7 46 1c	 movzx	 eax, WORD PTR [esi+28]
  0004d	66 89 47 1c	 mov	 WORD PTR [edi+28], ax
  00051	0f b7 46 1e	 movzx	 eax, WORD PTR [esi+30]
  00055	66 89 47 1e	 mov	 WORD PTR [edi+30], ax
  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	89 47 20	 mov	 DWORD PTR [edi+32], eax
  0005f	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00062	89 47 24	 mov	 DWORD PTR [edi+36], eax
  00065	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=

; 101  : 	m_TimeEventAirResistance = c_ParticleProperty.m_TimeEventAirResistance;

  0006e	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00071	50		 push	 eax
  00072	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  00075	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=

; 102  : 	
; 103  : 	m_TimeEventScaleX = c_ParticleProperty.m_TimeEventScaleX;

  0007a	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0007d	50		 push	 eax
  0007e	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00081	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=

; 104  : 	m_TimeEventScaleY = c_ParticleProperty.m_TimeEventScaleY;

  00086	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00089	50		 push	 eax
  0008a	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
  0008d	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=

; 105  : 
; 106  : #ifdef WORLD_EDITOR
; 107  : 	m_TimeEventColorRed = c_ParticleProperty.m_TimeEventColorRed;
; 108  : 	m_TimeEventColorGreen = c_ParticleProperty.m_TimeEventColorGreen;
; 109  : 	m_TimeEventColorBlue = c_ParticleProperty.m_TimeEventColorBlue;
; 110  : 	m_TimeEventAlpha = c_ParticleProperty.m_TimeEventAlpha;
; 111  : 
; 112  : 	m_TextureNameVector = c_ParticleProperty.m_TextureNameVector;
; 113  : #else
; 114  : 	m_TimeEventColor = c_ParticleProperty.m_TimeEventColor;

  00092	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00095	50		 push	 eax
  00096	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00099	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::operator=

; 115  : #endif
; 116  : 	m_TimeEventRotation = c_ParticleProperty.m_TimeEventRotation;

  0009e	8d 46 64	 lea	 eax, DWORD PTR [esi+100]
  000a1	50		 push	 eax
  000a2	8d 4f 64	 lea	 ecx, DWORD PTR [edi+100]
  000a5	e8 00 00 00 00	 call	 ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=

; 117  : 
; 118  : 	m_ImageVector = c_ParticleProperty.m_ImageVector;

  000aa	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  000ad	50		 push	 eax
  000ae	8d 4f 70	 lea	 ecx, DWORD PTR [edi+112]
  000b1	e8 00 00 00 00	 call	 ??4?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::operator=

; 119  : 
; 120  : 	return *this;

  000b6	8b c7		 mov	 eax, edi
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 121  : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
??4CParticleProperty@@QAEAAV0@ABV0@@Z ENDP		; CParticleProperty::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXPAPAVCGraphicImage@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXPAPAVCGraphicImage@@0@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXPAPAVCGraphicImage@@0@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBE_NPBQAVCGraphicImage@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBE_NPBQAVCGraphicImage@@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBE_NPBQAVCGraphicImage@@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEII@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IBEII@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXPAPAVCGraphicImage@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXPAPAVCGraphicImage@@0@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXPAPAVCGraphicImage@@0@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXABQAVCGraphicImage@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXABQAVCGraphicImage@@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXABQAVCGraphicImage@@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBE_NXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??4?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv651 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::operator=, COMDAT
; _this$ = ecx

; 949  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 950  : 		if (this != &_Right)

  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	3b de		 cmp	 ebx, esi
  0000d	0f 84 f3 00 00
	00		 je	 $LN124@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	57		 push	 edi
  00017	8b 3e		 mov	 edi, DWORD PTR [esi]
  00019	3b f8		 cmp	 edi, eax

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

  0001b	75 10		 jne	 SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  0001d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0001f	5f		 pop	 edi

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  00020	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  00023	8b c3		 mov	 eax, ebx
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx

; 996  : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0002d	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00030	8b d0		 mov	 edx, eax
  00032	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00034	2b d7		 sub	 edx, edi
  00036	2b f1		 sub	 esi, ecx
  00038	c1 fa 02	 sar	 edx, 2
  0003b	c1 fe 02	 sar	 esi, 2
  0003e	89 75 fc	 mov	 DWORD PTR tv651[ebp], esi

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

  00041	3b d6		 cmp	 edx, esi
  00043	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00046	77 2b		 ja	 SHORT $LN7@operator
; File a:\vs\vc\include\xutility

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00048	2b c7		 sub	 eax, edi

; 2056 : 		_Count * sizeof (*_First));

  0004a	83 e0 fc	 and	 eax, -4			; fffffffcH
  0004d	50		 push	 eax
  0004e	57		 push	 edi
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
; File a:\vs\vc\include\xutility

; 2056 : 		_Count * sizeof (*_First));

  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005b	2b 0e		 sub	 ecx, DWORD PTR [esi]

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  0005d	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005f	c1 f9 02	 sar	 ecx, 2
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  00064	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  00067	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  0006a	8b c3		 mov	 eax, ebx
  0006c	5b		 pop	 ebx

; 996  : 		}

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00073	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00076	2b c1		 sub	 eax, ecx
  00078	c1 f8 02	 sar	 eax, 2

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

  0007b	3b d0		 cmp	 edx, eax
  0007d	77 43		 ja	 SHORT $LN5@operator

; 972  : 				pointer _Ptr = _Right._Myfirst + size();

  0007f	8b 45 fc	 mov	 eax, DWORD PTR tv651[ebp]
; File a:\vs\vc\include\xutility

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00082	8b 16		 mov	 edx, DWORD PTR [esi]
; File a:\vs\vc\include\vector

; 972  : 				pointer _Ptr = _Right._Myfirst + size();

  00084	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
; File a:\vs\vc\include\xutility

; 2054 : 	ptrdiff_t _Count = _Last - _First;

  00087	8b c7		 mov	 eax, edi
  00089	2b c2		 sub	 eax, edx

; 2056 : 		_Count * sizeof (*_First));

  0008b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0008e	50		 push	 eax
  0008f	52		 push	 edx
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00096	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00099	2b c7		 sub	 eax, edi
  0009b	c1 f8 02	 sar	 eax, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0009e	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  000a5	56		 push	 esi
  000a6	57		 push	 edi
  000a7	ff 73 04	 push	 DWORD PTR [ebx+4]
  000aa	e8 00 00 00 00	 call	 _memmove
  000af	83 c4 18	 add	 esp, 24			; 00000018H
  000b2	03 c6		 add	 eax, esi
; File a:\vs\vc\include\vector

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  000b4	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  000b7	8b c3		 mov	 eax, ebx
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx

; 996  : 		}

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
$LN5@operator:

; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

  000c2	85 c9		 test	 ecx, ecx
  000c4	74 09		 je	 SHORT $LN101@operator
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cc	83 c4 04	 add	 esp, 4
$LN101@operator:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000cf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000d2	8b cb		 mov	 ecx, ebx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000d4	2b 06		 sub	 eax, DWORD PTR [esi]
  000d6	c1 f8 02	 sar	 eax, 2

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@IAE_NI@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Buy
  000df	84 c0		 test	 al, al
  000e1	74 22		 je	 SHORT $LN123@operator

; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);

  000e3	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000e5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000e8	2b c1		 sub	 eax, ecx
  000ea	c1 f8 02	 sar	 eax, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000ed	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  000f4	56		 push	 esi
  000f5	51		 push	 ecx
  000f6	ff 33		 push	 DWORD PTR [ebx]
  000f8	e8 00 00 00 00	 call	 _memmove
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	03 c6		 add	 eax, esi
; File a:\vs\vc\include\vector

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  00102	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN123@operator:
  00105	5f		 pop	 edi
$LN124@operator:
  00106	5e		 pop	 esi

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  00107	8b c3		 mov	 eax, ebx
  00109	5b		 pop	 ebx

; 996  : 		}

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 04 00	 ret	 4
??4?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::~vector<CGraphicImage *,std::allocator<CGraphicImage *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::~vector<CGraphicImage *,std::allocator<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::vector<CGraphicImage *,std::allocator<CGraphicImage *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::vector<CGraphicImage *,std::allocator<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 594  : 		}

  00000	c2 04 00	 ret	 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImage@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImage@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImage@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImage *,std::allocator<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicImage *> >::_Vector_val<std::_Simple_types<CGraphicImage *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicImage *> >::_Vector_val<std::_Simple_types<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXPAPAVCGraphicImage@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEPAPAVCGraphicImage@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::_Wrap_alloc<std::allocator<CGraphicImage *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImage *> >::_Wrap_alloc<std::allocator<CGraphicImage *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImage@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImage@@@2@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImage *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImage@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImage@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImage *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCGraphicImage@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCGraphicImage@@@std@@QBEIXZ PROC ; std::allocator<CGraphicImage *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCGraphicImage@@@std@@QBEIXZ ENDP ; std::allocator<CGraphicImage *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@ABQAV3@@Z PROC ; std::allocator<CGraphicImage *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@ABQAV3@@Z ENDP ; std::allocator<CGraphicImage *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCGraphicImage@@@std@@QAEPAPAVCGraphicImage@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCGraphicImage@@@std@@QAEPAPAVCGraphicImage@@I@Z PROC ; std::allocator<CGraphicImage *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCGraphicImage@@@std@@QAEPAPAVCGraphicImage@@I@Z ENDP ; std::allocator<CGraphicImage *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@I@Z PROC ; std::allocator<CGraphicImage *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicImage@@@std@@QAEXPAPAVCGraphicImage@@I@Z ENDP ; std::allocator<CGraphicImage *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicImage@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCGraphicImage@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCGraphicImage@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicImage@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGraphicImage@@@std@@QAE@XZ PROC	; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGraphicImage@@@std@@QAE@XZ ENDP	; std::allocator<CGraphicImage *>::allocator<CGraphicImage *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IBEXXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IBEXXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@0@Z ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBE_NXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
tv772 = 8						; size = 4
__Cat$2 = 8						; size = 1
__Cat$3 = 8						; size = 1
__Right$ = 8						; size = 4
__Alval$4 = 11						; size = 1
__Alval$5 = 11						; size = 1
??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::operator=, COMDAT
; _this$ = ecx

; 949  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 950  : 		if (this != &_Right)

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	3b fb		 cmp	 edi, ebx
  00035	74 0e		 je	 SHORT $LN16@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00037	8b 33		 mov	 esi, DWORD PTR [ebx]
  00039	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003c	3b f0		 cmp	 esi, eax

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

  0003e	75 1b		 jne	 SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00040	8b 07		 mov	 eax, DWORD PTR [edi]
$LN209@operator:

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  00042	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN16@operator:

; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  00045	8b c7		 mov	 eax, edi

; 996  : 		}

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0005d	8b d0		 mov	 edx, eax
  0005f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00062	2b d6		 sub	 edx, esi
  00064	2b c1		 sub	 eax, ecx
  00066	c1 fa 03	 sar	 edx, 3
  00069	c1 f8 03	 sar	 eax, 3
  0006c	89 45 08	 mov	 DWORD PTR tv772[ebp], eax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

  0006f	3b d0		 cmp	 edx, eax
  00071	77 1c		 ja	 SHORT $LN7@operator

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new

  00073	51		 push	 ecx
  00074	ff 73 04	 push	 DWORD PTR [ebx+4]
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0007d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new

  00080	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00083	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  00085	8b 07		 mov	 eax, DWORD PTR [edi]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00087	c1 f9 03	 sar	 ecx, 3

; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  0008a	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

  0008d	eb b3		 jmp	 SHORT $LN209@operator
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  0008f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00092	2b c1		 sub	 eax, ecx
  00094	c1 f8 03	 sar	 eax, 3

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

  00097	3b d0		 cmp	 edx, eax
  00099	77 27		 ja	 SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

  0009b	8b 45 08	 mov	 eax, DWORD PTR tv772[ebp]

; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);

  0009e	51		 push	 ecx
  0009f	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]
  000a2	56		 push	 esi
  000a3	ff 33		 push	 DWORD PTR [ebx]
  000a5	e8 00 00 00 00	 call	 ??$_Copy_impl@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00@Z ; std::_Copy_impl<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *>
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  000aa	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  000ad	8d 45 0b	 lea	 eax, DWORD PTR __Alval$5[ebp]
  000b0	50		 push	 eax
  000b1	ff 77 04	 push	 DWORD PTR [edi+4]
  000b4	ff 73 04	 push	 DWORD PTR [ebx+4]
  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
  000bd	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\vector

; 977  : 			else

  000c0	eb 80		 jmp	 SHORT $LN209@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

  000c2	85 c9		 test	 ecx, ecx
  000c4	74 09		 je	 SHORT $LN175@operator
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c6	51		 push	 ecx
  000c7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cc	83 c4 04	 add	 esp, 4
$LN175@operator:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000cf	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000d2	8b cf		 mov	 ecx, edi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000d4	2b 03		 sub	 eax, DWORD PTR [ebx]
  000d6	c1 f8 03	 sar	 eax, 3

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAE_NI@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Buy
  000df	84 c0		 test	 al, al
  000e1	0f 84 5e ff ff
	ff		 je	 $LN16@operator
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  000e7	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
  000ea	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 986  : 					_TRY_BEGIN

  000ed	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  000f4	50		 push	 eax
  000f5	ff 37		 push	 DWORD PTR [edi]
  000f7	ff 73 04	 push	 DWORD PTR [ebx+4]
  000fa	ff 33		 push	 DWORD PTR [ebx]
  000fc	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@YAPAV?$CTimeEvent@UDWORDCOLOR@@@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<DWORDCOLOR> *,CTimeEvent<DWORDCOLOR> *,std::allocator<CTimeEvent<DWORDCOLOR> > >
  00101	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector
  00104	e9 39 ff ff ff	 jmp	 $LN209@operator
__catch$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z$0:

; 990  : 					_Tidy();

  00109	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@IAEXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Tidy

; 991  : 					_RERAISE;

  00111	6a 00		 push	 0
  00113	6a 00		 push	 0
  00115	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN210@operator:
$LN208@operator:
  0011a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::operator=
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::~vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::~vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Change_alloc, COMDAT
; _this$ = ecx

; 594  : 		}

  00000	c2 04 00	 ret	 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >::_Vector_val<std::_Simple_types<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >::_Wrap_alloc<std::allocator<CTimeEvent<DWORDCOLOR> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@2@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<DWORDCOLOR> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QBEIXZ PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QBEIXZ ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@XZ PROC ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@QAE@XZ ENDP ; std::allocator<CTimeEvent<DWORDCOLOR> >::allocator<CTimeEvent<DWORDCOLOR> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IBEXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IBEXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXPAV?$CTimeEvent@M@@0@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv800 = -24						; size = 4
tv801 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Cat$3 = 8						; size = 1
__Right$ = 8						; size = 4
__Alval$4 = 11						; size = 1
__Alval$5 = 11						; size = 1
??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=, COMDAT
; _this$ = ecx

; 949  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e4	 mov	 DWORD PTR _this$[ebp], edi

; 950  : 		if (this != &_Right)

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	3b fb		 cmp	 edi, ebx
  00035	74 0e		 je	 SHORT $LN16@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00037	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0003a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0003c	3b d6		 cmp	 edx, esi

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

  0003e	75 1b		 jne	 SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00040	8b 07		 mov	 eax, DWORD PTR [edi]
$LN222@operator:

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

  00042	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN16@operator:

; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

  00045	8b c7		 mov	 eax, edi

; 996  : 		}

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0005e	8b c6		 mov	 eax, esi
  00060	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00062	2b c2		 sub	 eax, edx
  00064	2b d9		 sub	 ebx, ecx
  00066	c1 f8 03	 sar	 eax, 3
  00069	c1 fb 03	 sar	 ebx, 3
  0006c	89 5d e8	 mov	 DWORD PTR tv800[ebp], ebx

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

  0006f	3b c3		 cmp	 eax, ebx
  00071	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00074	89 45 ec	 mov	 DWORD PTR tv801[ebp], eax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

  00077	77 2b		 ja	 SHORT $LN7@operator
; File a:\vs\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

  00079	3b d6		 cmp	 edx, esi
  0007b	74 18		 je	 SHORT $LN107@operator
  0007d	8d 49 00	 npad	 3
$LL109@operator:

; 2045 : 		*_Dest = *_First;

  00080	8b 02		 mov	 eax, DWORD PTR [edx]
  00082	8d 49 08	 lea	 ecx, DWORD PTR [ecx+8]
  00085	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00088	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008b	83 c2 08	 add	 edx, 8
  0008e	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  00091	3b d6		 cmp	 edx, esi
  00093	75 eb		 jne	 SHORT $LL109@operator
$LN107@operator:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00095	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00098	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  0009a	8b 07		 mov	 eax, DWORD PTR [edi]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0009c	c1 f9 03	 sar	 ecx, 3

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

  0009f	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

  000a2	eb 9e		 jmp	 SHORT $LN222@operator
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  000a4	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000a7	2b c1		 sub	 eax, ecx
  000a9	c1 f8 03	 sar	 eax, 3

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

  000ac	39 45 ec	 cmp	 DWORD PTR tv801[ebp], eax
  000af	77 29		 ja	 SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

  000b1	8b 45 e8	 mov	 eax, DWORD PTR tv800[ebp]

; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);

  000b4	51		 push	 ecx
  000b5	8d 34 c2	 lea	 esi, DWORD PTR [edx+eax*8]
  000b8	56		 push	 esi
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 ??$_Copy_impl@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@00@Z ; std::_Copy_impl<CTimeEvent<float> *,CTimeEvent<float> *>
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  000bf	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  000c2	8d 45 0b	 lea	 eax, DWORD PTR __Alval$5[ebp]
  000c5	50		 push	 eax
  000c6	ff 77 04	 push	 DWORD PTR [edi+4]
  000c9	ff 73 04	 push	 DWORD PTR [ebx+4]
  000cc	56		 push	 esi
  000cd	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
  000d2	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\vector

; 977  : 			else

  000d5	e9 68 ff ff ff	 jmp	 $LN222@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

  000da	85 c9		 test	 ecx, ecx
  000dc	74 09		 je	 SHORT $LN184@operator
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000de	51		 push	 ecx
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	83 c4 04	 add	 esp, 4
$LN184@operator:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000e7	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000ea	8b cf		 mov	 ecx, edi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000ec	2b 03		 sub	 eax, DWORD PTR [ebx]
  000ee	c1 f8 03	 sar	 eax, 3

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAE_NI@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Buy
  000f7	84 c0		 test	 al, al
  000f9	0f 84 46 ff ff
	ff		 je	 $LN16@operator
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  000ff	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
  00102	8d 45 0b	 lea	 eax, DWORD PTR __Alval$4[ebp]
; File a:\vs\vc\include\vector

; 986  : 					_TRY_BEGIN

  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

  0010c	50		 push	 eax
  0010d	ff 37		 push	 DWORD PTR [edi]
  0010f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00112	ff 33		 push	 DWORD PTR [ebx]
  00114	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$CTimeEvent@M@@PAV1@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CTimeEvent<float> *,CTimeEvent<float> *,std::allocator<CTimeEvent<float> > >
  00119	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector
  0011c	e9 21 ff ff ff	 jmp	 $LN222@operator
__catch$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z$0:

; 990  : 					_Tidy();

  00121	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@IAEXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Tidy

; 991  : 					_RERAISE;

  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN223@operator:
$LN221@operator:
  00132	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::operator=
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::~vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Change_alloc, COMDAT
; _this$ = ecx

; 594  : 		}

  00000	c2 04 00	 ret	 4
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@ABV?$allocator@V?$CTimeEvent@M@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >::_Vector_alloc<0,std::_Vec_base_types<CTimeEvent<float>,std::allocator<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTimeEvent<float> > >::_Vector_val<std::_Simple_types<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEPAV?$CTimeEvent@M@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEPAV?$CTimeEvent@M@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CTimeEvent<float> > >::_Wrap_alloc<std::allocator<CTimeEvent<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@M@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@M@@@2@@Z PROC ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@SAIABV?$allocator@V?$CTimeEvent@M@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CTimeEvent<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$CTimeEvent@M@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$CTimeEvent@M@@@std@@QBEIXZ PROC ; std::allocator<CTimeEvent<float> >::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$CTimeEvent@M@@@std@@QBEIXZ ENDP ; std::allocator<CTimeEvent<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEPAV?$CTimeEvent@M@@I@Z PROC ; std::allocator<CTimeEvent<float> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 03	 shl	 eax, 3
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEPAV?$CTimeEvent@M@@I@Z ENDP ; std::allocator<CTimeEvent<float> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z PROC ; std::allocator<CTimeEvent<float> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$CTimeEvent@M@@@std@@QAEXPAV?$CTimeEvent@M@@I@Z ENDP ; std::allocator<CTimeEvent<float> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ PROC	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$CTimeEvent@M@@@std@@QAE@XZ ENDP	; std::allocator<CTimeEvent<float> >::allocator<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ?SetTexture@CParticleProperty@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?SetTexture@CParticleProperty@@QAE_NPBD@Z PROC		; CParticleProperty::SetTexture, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00003	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00006	2b 41 70	 sub	 eax, DWORD PTR [ecx+112]
  00009	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 17   : 	if (m_ImageVector.size() > 1)

  0000c	83 f8 01	 cmp	 eax, 1
  0000f	76 06		 jbe	 SHORT $LN1@SetTexture

; 18   : 	{
; 19   : 		assert(false);
; 20   : 		return false;

  00011	32 c0		 xor	 al, al

; 28   : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN1@SetTexture:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00017	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 26   : 	InsertTexture(c_szFileName);

  0001a	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0001d	89 41 74	 mov	 DWORD PTR [ecx+116], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 26   : 	InsertTexture(c_szFileName);

  00020	e8 00 00 00 00	 call	 ?InsertTexture@CParticleProperty@@QAEXPBD@Z ; CParticleProperty::InsertTexture

; 27   : 	return true;

  00025	b0 01		 mov	 al, 1

; 28   : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?SetTexture@CParticleProperty@@QAE_NPBD@Z ENDP		; CParticleProperty::SetTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ?InsertTexture@CParticleProperty@@QAEXPBD@Z
_TEXT	SEGMENT
_pImage$ = 8						; size = 4
_c_szFileName$ = 8					; size = 4
?InsertTexture@CParticleProperty@@QAEXPBD@Z PROC	; CParticleProperty::InsertTexture, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7    : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(c_szFileName);

  00004	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0000f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00014	89 45 08	 mov	 DWORD PTR _pImage$[ebp], eax

; 8    : 
; 9    : 	m_ImageVector.push_back(pImage);

  00017	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0001a	8d 45 08	 lea	 eax, DWORD PTR _pImage$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAEXABQAVCGraphicImage@@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::push_back
  00023	5e		 pop	 esi

; 10   : #ifdef WORLD_EDITOR
; 11   : 	m_TextureNameVector.push_back(c_szFileName);
; 12   : #endif
; 13   : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?InsertTexture@CParticleProperty@@QAEXPBD@Z ENDP	; CParticleProperty::InsertTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ?Clear@CParticleProperty@@QAEXXZ
_TEXT	SEGMENT
?Clear@CParticleProperty@@QAEXXZ PROC			; CParticleProperty::Clear, COMDAT
; _this$ = ecx

; 32   : 	m_byRotationType = 0;
; 33   : 	m_fRotationSpeed = 0.0f;
; 34   : 	m_wRotationRandomStartingBegin = 0;
; 35   : 	m_wRotationRandomStartingEnd = 0;
; 36   : 
; 37   : 	m_bAttachFlag = FALSE;
; 38   : 	m_bStretchFlag = FALSE;
; 39   : 
; 40   : 	m_bySrcBlendType = D3DBLEND_SRCALPHA;
; 41   : 	m_byDestBlendType = D3DBLEND_ONE;
; 42   : 	m_byColorOperationType = D3DTOP_MODULATE; 
; 43   : 
; 44   : 	m_byBillboardType = BILLBOARD_TYPE_NONE;

  00000	66 c7 41 13 00
	00		 mov	 WORD PTR [ecx+19], 0
  00006	33 c0		 xor	 eax, eax
  00008	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00012	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00015	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00018	66 c7 41 10 05
	02		 mov	 WORD PTR [ecx+16], 517	; 00000205H
  0001e	c6 41 12 04	 mov	 BYTE PTR [ecx+18], 4

; 45   : 
; 46   : 	m_byTexAniType = TEXTURE_ANIMATION_TYPE_NONE;

  00022	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 47   : 	m_fTexAniDelay = 0.05f;

  00025	c7 41 08 cd cc
	4c 3d		 mov	 DWORD PTR [ecx+8], 1028443341 ; 3d4ccccdH

; 48   : 	m_bTexAniRandomStartFrameFlag = FALSE;

  0002c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0002f	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00032	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  00035	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00038	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0003b	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0003e	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  00041	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00044	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00047	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  0004a	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
  0004d	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00050	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00053	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00056	89 41 74	 mov	 DWORD PTR [ecx+116], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 71   : }

  00059	c3		 ret	 0
?Clear@CParticleProperty@@QAEXXZ ENDP			; CParticleProperty::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ??1CParticleProperty@@UAE@XZ
_TEXT	SEGMENT
??1CParticleProperty@@UAE@XZ PROC			; CParticleProperty::~CParticleProperty, COMDAT
; _this$ = ecx

; 77   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CParticleProperty@@6B@
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN12@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
$LN12@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN25@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0
$LN25@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  00053	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00056	85 c0		 test	 eax, eax
  00058	74 1e		 je	 SHORT $LN60@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00063	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0

; 1630 : 			this->_Mylast = pointer();

  0006a	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 1631 : 			this->_Myend = pointer();

  00071	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
$LN60@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  00078	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0007b	85 c0		 test	 eax, eax
  0007d	74 1e		 je	 SHORT $LN95@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00085	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00088	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0

; 1630 : 			this->_Mylast = pointer();

  0008f	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 1631 : 			this->_Myend = pointer();

  00096	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
$LN95@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  0009d	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000a0	85 c0		 test	 eax, eax
  000a2	74 1e		 je	 SHORT $LN130@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000ad	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0

; 1630 : 			this->_Mylast = pointer();

  000b4	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 1631 : 			this->_Myend = pointer();

  000bb	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN130@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  000c2	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000c5	85 c0		 test	 eax, eax
  000c7	74 1e		 je	 SHORT $LN165@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000cf	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000d2	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 1630 : 			this->_Mylast = pointer();

  000d9	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 1631 : 			this->_Myend = pointer();

  000e0	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN165@CParticleP:

; 1623 : 		if (this->_Myfirst != pointer())

  000e7	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1e		 je	 SHORT $LN200@CParticleP
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f4	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  000f7	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1630 : 			this->_Mylast = pointer();

  000fe	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 1631 : 			this->_Myend = pointer();

  00105	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN200@CParticleP:
  0010c	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 78   : }

  0010d	c3		 ret	 0
??1CParticleProperty@@UAE@XZ ENDP			; CParticleProperty::~CParticleProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp
;	COMDAT ??0CParticleProperty@@QAE@XZ
_TEXT	SEGMENT
??0CParticleProperty@@QAE@XZ PROC			; CParticleProperty::CParticleProperty, COMDAT
; _this$ = ecx

; 74   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CParticleProperty@@6B@

; 75   : }

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 482  : 		_Myfirst = pointer();

  00032	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 483  : 		_Mylast = pointer();

  00039	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 484  : 		_Myend = pointer();

  00040	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 482  : 		_Myfirst = pointer();

  00047	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 483  : 		_Mylast = pointer();

  0004e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 484  : 		_Myend = pointer();

  00055	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 482  : 		_Myfirst = pointer();

  0005c	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 483  : 		_Mylast = pointer();

  00063	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0

; 484  : 		_Myend = pointer();

  0006a	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0

; 482  : 		_Myfirst = pointer();

  00071	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 483  : 		_Mylast = pointer();

  00078	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 484  : 		_Myend = pointer();

  0007f	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 482  : 		_Myfirst = pointer();

  00086	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0

; 483  : 		_Mylast = pointer();

  0008d	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 484  : 		_Myend = pointer();

  00094	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\particleproperty.cpp

; 75   : }

  0009b	c3		 ret	 0
??0CParticleProperty@@QAE@XZ ENDP			; CParticleProperty::CParticleProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??4DWORDCOLOR@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
??4DWORDCOLOR@@QAEAAU0@ABU0@@Z PROC			; DWORDCOLOR::operator=, COMDAT
; _this$ = ecx

; 141  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  : 		m_dwColor = r.m_dwColor;

  00003	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 143  : 		return *this;

  0000a	8b c1		 mov	 eax, ecx

; 144  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??4DWORDCOLOR@@QAEAAU0@ABU0@@Z ENDP			; DWORDCOLOR::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??0DWORDCOLOR@@QAE@ABU0@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
??0DWORDCOLOR@@QAE@ABU0@@Z PROC				; DWORDCOLOR::DWORDCOLOR, COMDAT
; _this$ = ecx

; 138  : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _r$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0DWORDCOLOR@@QAE@ABU0@@Z ENDP				; DWORDCOLOR::DWORDCOLOR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
