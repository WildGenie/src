; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	A:\From C\Desktop\Serwer\Source\Source Client\client\EffectLib\EffectMeshInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_sqrtf
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ; CSingleton<CTimer>::Instance
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z			; D3DXVECTOR3::operator-=
PUBLIC	??GD3DXVECTOR3@@QBE?AU0@XZ			; D3DXVECTOR3::operator-
PUBLIC	??8D3DXVECTOR3@@QBEHABU0@@Z			; D3DXVECTOR3::operator==
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0D3DXQUATERNION@@QAE@MMMM@Z			; D3DXQUATERNION::D3DXQUATERNION
PUBLIC	??0D3DXCOLOR@@QAE@MMMM@Z			; D3DXCOLOR::D3DXCOLOR
PUBLIC	??BD3DXCOLOR@@QBEKXZ				; D3DXCOLOR::operator unsigned long
PUBLIC	?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z	; D3DXVec3LengthSq
PUBLIC	?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z		; D3DXVec3Dot
PUBLIC	?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z	; D3DXVec3Cross
PUBLIC	?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z	; D3DXMatrixIdentity
PUBLIC	?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ; CSingleton<CStateManager>::Instance
PUBLIC	?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ; CSingleton<CResourceManager>::Instance
PUBLIC	?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ ; CDynamicPool<CGraphicImageInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCGraphicImageInstance@@@@QAEXPAVCGraphicImageInstance@@@Z ; CDynamicPool<CGraphicImageInstance>::Free
PUBLIC	?select_on_container_copy_construction@?$allocator@PAVCGraphicImageInstance@@@std@@QBE?AV12@XZ ; std::allocator<CGraphicImageInstance *>::select_on_container_copy_construction
PUBLIC	??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@XZ ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>
PUBLIC	??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@ABV01@@Z ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>
PUBLIC	?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z ; std::allocator<CGraphicImageInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z ; std::allocator<CGraphicImageInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV3@@Z ; std::allocator<CGraphicImageInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCGraphicImageInstance@@@std@@QBEIXZ ; std::allocator<CGraphicImageInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImageInstance@@@2@@Z ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SA?AV?$allocator@PAVCGraphicImageInstance@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
PUBLIC	??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
PUBLIC	??1?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::~vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
PUBLIC	?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve
PUBLIC	?capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin
PUBLIC	?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin
PUBLIC	?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end
PUBLIC	?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end
PUBLIC	?size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE_NXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::empty
PUBLIC	??A?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@I@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::operator[]
PUBLIC	?back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@XZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear
PUBLIC	?_Buy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAE_NI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Buy
PUBLIC	?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXPAPAVCGraphicImageInstance@@0@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEII@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBE_NPBQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXXZ ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXPAPAVCGraphicImageInstance@@0@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Orphan_range
PUBLIC	??0CFrameController@@QAE@ABV0@@Z		; CFrameController::CFrameController
PUBLIC	??_GCFrameController@@UAEPAXI@Z			; CFrameController::`scalar deleting destructor'
PUBLIC	??A?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAEAAUSPTVertex@@I@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::operator[]
PUBLIC	??A?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAEAAUSEffectFrameData@CEffectMesh@@I@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::operator[]
PUBLIC	?begin@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::begin
PUBLIC	?end@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::end
PUBLIC	?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size
PUBLIC	?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
PUBLIC	?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end
PUBLIC	?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
PUBLIC	?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front
PUBLIC	?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back
PUBLIC	??0STextureInstance@CEffectMeshInstance@@QAE@XZ	; CEffectMeshInstance::STextureInstance::STextureInstance
PUBLIC	??1STextureInstance@CEffectMeshInstance@@QAE@XZ	; CEffectMeshInstance::STextureInstance::~STextureInstance
PUBLIC	??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z ; CEffectMeshInstance::STextureInstance::STextureInstance
PUBLIC	??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor'
PUBLIC	??0CEffectMeshInstance@@QAE@XZ			; CEffectMeshInstance::CEffectMeshInstance
PUBLIC	??1CEffectMeshInstance@@UAE@XZ			; CEffectMeshInstance::~CEffectMeshInstance
PUBLIC	?DestroySystem@CEffectMeshInstance@@SAXXZ	; CEffectMeshInstance::DestroySystem
PUBLIC	?New@CEffectMeshInstance@@SAPAV1@XZ		; CEffectMeshInstance::New
PUBLIC	?Delete@CEffectMeshInstance@@SAXPAV1@@Z		; CEffectMeshInstance::Delete
PUBLIC	??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ ; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>
PUBLIC	??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ ; CDynamicPool<CEffectMeshInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ; CDynamicPool<CEffectMeshInstance>::Alloc
PUBLIC	?Free@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Free
PUBLIC	?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Delete
PUBLIC	??0?$allocator@PAVCEffectMeshInstance@@@std@@QAE@XZ ; std::allocator<CEffectMeshInstance *>::allocator<CEffectMeshInstance *>
PUBLIC	?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance *>::deallocate
PUBLIC	?allocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance *>::allocate
PUBLIC	?construct@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV3@@Z ; std::allocator<CEffectMeshInstance *>::construct
PUBLIC	?max_size@?$allocator@PAVCEffectMeshInstance@@@std@@QBEIXZ ; std::allocator<CEffectMeshInstance *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@PAVCEffectMeshInstance@@@2@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCEffectMeshInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Getal
PUBLIC	??0?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >
PUBLIC	??1?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::~vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >
PUBLIC	?capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::begin
PUBLIC	?end@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::end
PUBLIC	?size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::size
PUBLIC	?max_size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::max_size
PUBLIC	?empty@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBE_NXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::empty
PUBLIC	?back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEAAPAVCEffectMeshInstance@@XZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::back
PUBLIC	?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back
PUBLIC	?pop_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::pop_back
PUBLIC	?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEII@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBE_NPBQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXXZ ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Orphan_range
PUBLIC	??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor'
PUBLIC	?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z ; CEffectMeshInstance::OnSetDataPointer
PUBLIC	?OnInitialize@CEffectMeshInstance@@MAEXXZ	; CEffectMeshInstance::OnInitialize
PUBLIC	?OnDestroy@CEffectMeshInstance@@MAEXXZ		; CEffectMeshInstance::OnDestroy
PUBLIC	?OnUpdate@CEffectMeshInstance@@MAE_NM@Z		; CEffectMeshInstance::OnUpdate
PUBLIC	?OnRender@CEffectMeshInstance@@MAEXXZ		; CEffectMeshInstance::OnRender
PUBLIC	?isActive@CEffectMeshInstance@@IAEHXZ		; CEffectMeshInstance::isActive
PUBLIC	??0?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAE@XZ ; std::allocator<CEffectMeshInstance::STextureInstance>::allocator<CEffectMeshInstance::STextureInstance>
PUBLIC	?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate
PUBLIC	?allocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::allocate
PUBLIC	?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::construct
PUBLIC	?max_size@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QBEIXZ ; std::allocator<CEffectMeshInstance::STextureInstance>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::deallocate
PUBLIC	?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Getal
PUBLIC	??0?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
PUBLIC	?capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::capacity
PUBLIC	?_Unused_capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Unused_capacity
PUBLIC	?begin@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::begin
PUBLIC	?end@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::end
PUBLIC	?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::resize
PUBLIC	?size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::size
PUBLIC	?max_size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
PUBLIC	??A?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEAAUSTextureInstance@CEffectMeshInstance@@I@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::operator[]
PUBLIC	?_Pop_back_n@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Pop_back_n
PUBLIC	?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear
PUBLIC	?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy
PUBLIC	?_Grow_to@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEII@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reallocate
PUBLIC	?_Reserve@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reserve
PUBLIC	?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy
PUBLIC	?_Xlen@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlen
PUBLIC	??0?$CRef@VCEffectMesh@@@@QAE@XZ		; CRef<CEffectMesh>::CRef<CEffectMesh>
PUBLIC	??1?$CRef@VCEffectMesh@@@@QAE@XZ		; CRef<CEffectMesh>::~CRef<CEffectMesh>
PUBLIC	?Clear@?$CRef@VCEffectMesh@@@@QAEXXZ		; CRef<CEffectMesh>::Clear
PUBLIC	?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CEffectMesh>::SetPointer
PUBLIC	?GetPointer@?$CRef@VCEffectMesh@@@@QBEPAVCEffectMesh@@XZ ; CRef<CEffectMesh>::GetPointer
PUBLIC	??_GCEffectMeshInstance@@UAEPAXI@Z		; CEffectMeshInstance::`scalar deleting destructor'
PUBLIC	?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ; SafeRotationNormalizedArc
PUBLIC	??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z ; GetTimeEventBlendValue<float>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEABQAVCGraphicImage@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEAAPAVCGraphicImage@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++
PUBLIC	?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ; CEffectMeshInstance_DeleteImageInstance
PUBLIC	?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ; CEffectMeshInstance_DeleteTextureInstance
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPBQAVCGraphicImageInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEABQAVCGraphicImageInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicImageInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicImageInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicImageInstance@@@Z@std@@YAP6AXPAVCGraphicImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,void (__cdecl*)(CGraphicImageInstance *)>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBEPAUSTextureInstance@CEffectMeshInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Unchecked
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@P6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>
PUBLIC	??$addressof@QAVCGraphicImageInstance@@@std@@YAPBQAVCGraphicImageInstance@@ABQAV1@@Z ; std::addressof<CGraphicImageInstance * const>
PUBLIC	??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
PUBLIC	??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEABQAVCEffectMeshInstance@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEPAPAVCEffectMeshInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEAAPAVCEffectMeshInstance@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>
PUBLIC	??$_Uninitialized_default_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$destroy@PAVCGraphicImageInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$_Umove@PAPAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@PAPAV2@00@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Umove<CGraphicImageInstance * *>
PUBLIC	??$addressof@QAVCEffectMeshInstance@@@std@@YAPBQAVCEffectMeshInstance@@ABQAV1@@Z ; std::addressof<CEffectMeshInstance * const>
PUBLIC	??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
PUBLIC	??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>
PUBLIC	??$destroy@PAVCEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
PUBLIC	??$_Umove@PAUSTextureInstance@CEffectMeshInstance@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEPAUSTextureInstance@CEffectMeshInstance@@PAU23@00@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Umove<CEffectMeshInstance::STextureInstance *>
PUBLIC	??$_Allocate@PAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@IPAPAV1@@Z ; std::_Allocate<CGraphicImageInstance *>
PUBLIC	??$_Umove@PAPAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEPAPAVCEffectMeshInstance@@PAPAV2@00@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Umove<CEffectMeshInstance * *>
PUBLIC	??$_Allocate@USTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@IPAU12@@Z ; std::_Allocate<CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Allocate@PAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@IPAPAV1@@Z ; std::_Allocate<CEffectMeshInstance *>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
PUBLIC	??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->
PUBLIC	??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-
PUBLIC	??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPBQAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
PUBLIC	??$_For_each@PAPAVCGraphicImageInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicImageInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CGraphicImageInstance * *,void (__cdecl*)(CGraphicImageInstance *)>
PUBLIC	??$move@AAP6AXPAVCGraphicImageInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicImageInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CGraphicImageInstance *)>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$_For_each@PAUSTextureInstance@CEffectMeshInstance@@P6AXAAU12@@Z@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAP6AXAAU12@@Z@Z ; std::_For_each<CEffectMeshInstance::STextureInstance *,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>
PUBLIC	??$move@AAP6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YA$$QAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CEffectMeshInstance::STextureInstance &)>
PUBLIC	??$forward@AAPAVCGraphicImageInstance@@@std@@YAAAPAVCGraphicImageInstance@@AAPAV1@@Z ; std::forward<CGraphicImageInstance * &>
PUBLIC	??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
PUBLIC	??$forward@ABQAVCGraphicImageInstance@@@std@@YAABQAVCGraphicImageInstance@@ABQAV1@@Z ; std::forward<CGraphicImageInstance * const &>
PUBLIC	??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
PUBLIC	??$_For_each@PAPAVCEffectMeshInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCEffectMeshInstance@@0AAP6AXPAV1@@Z@Z ; std::_For_each<CEffectMeshInstance * *,void (__cdecl*)(CEffectMeshInstance *)>
PUBLIC	??$move@AAP6AXPAVCEffectMeshInstance@@@Z@std@@YA$$QAP6AXPAVCEffectMeshInstance@@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(CEffectMeshInstance *)>
PUBLIC	??$_Val_type@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z ; std::_Val_type<CEffectMeshInstance::STextureInstance *>
PUBLIC	??$_Ptr_cat@USTextureInstance@CEffectMeshInstance@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSTextureInstance@CEffectMeshInstance@@0@Z ; std::_Ptr_cat<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
PUBLIC	??$destroy@PAVCGraphicImageInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@@Z ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>
PUBLIC	??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCGraphicImageInstance@@PAPAV2@@Z ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>
PUBLIC	??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImageInstance@@0@Z ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$forward@AAPAVCEffectMeshInstance@@@std@@YAAAPAVCEffectMeshInstance@@AAPAV1@@Z ; std::forward<CEffectMeshInstance * &>
PUBLIC	??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@AAPAV3@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
PUBLIC	??$forward@ABQAVCEffectMeshInstance@@@std@@YAABQAVCEffectMeshInstance@@ABQAV1@@Z ; std::forward<CEffectMeshInstance * const &>
PUBLIC	??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@ABQAV3@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>
PUBLIC	??$destroy@PAVCEffectMeshInstance@@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$_Ptr_cat@PAVCEffectMeshInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCEffectMeshInstance@@0@Z ; std::_Ptr_cat<CEffectMeshInstance *,CEffectMeshInstance *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
PUBLIC	??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$_Uninitialized_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ; std::_Uninitialized_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
PUBLIC	?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z ; std::pointer_traits<CTimeEvent<float> *>::pointer_to
PUBLIC	??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z ; std::addressof<CTimeEvent<float> >
PUBLIC	??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
PUBLIC	??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z ; std::allocator<CGraphicImageInstance *>::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
PUBLIC	??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
PUBLIC	??$destroy@PAVCGraphicImageInstance@@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z ; std::allocator<CGraphicImageInstance *>::destroy<CGraphicImageInstance *>
PUBLIC	??$_Unchecked@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z ; std::_Unchecked<CGraphicImageInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ; std::_Uninit_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicImageInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CGraphicImageInstance * *,CGraphicImageInstance * *>
PUBLIC	??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z ; std::allocator<CEffectMeshInstance *>::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
PUBLIC	??$destroy@PAVCEffectMeshInstance@@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z ; std::allocator<CEffectMeshInstance *>::destroy<CEffectMeshInstance *>
PUBLIC	??$_Unchecked@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z ; std::_Unchecked<CEffectMeshInstance::STextureInstance *>
PUBLIC	??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
PUBLIC	??$_Rechecked@PAUSTextureInstance@CEffectMeshInstance@@PAU12@@std@@YAAAPAUSTextureInstance@CEffectMeshInstance@@AAPAU12@PAU12@@Z ; std::_Rechecked<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *>
PUBLIC	??$_Unchecked@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z ; std::_Unchecked<CEffectMeshInstance * *>
PUBLIC	??$_Uninit_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ; std::_Uninit_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
PUBLIC	??$_Rechecked@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAAAPAPAVCEffectMeshInstance@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<CEffectMeshInstance * *,CEffectMeshInstance * *>
PUBLIC	??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >
PUBLIC	??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
PUBLIC	??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>
PUBLIC	??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Val_type@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z ; std::_Val_type<CGraphicImageInstance * *>
PUBLIC	??$_Uninit_move@PAVCGraphicImageInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CGraphicImageInstance *,CGraphicImageInstance *,CGraphicImageInstance *>
PUBLIC	??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Val_type@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z ; std::_Val_type<CEffectMeshInstance * *>
PUBLIC	??$_Uninit_move@PAVCEffectMeshInstance@@PAV1@PAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance *,CEffectMeshInstance *,CEffectMeshInstance *>
PUBLIC	??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z ; std::_Distance<CTimeEvent<float> *,int>
PUBLIC	??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z ; std::advance<CTimeEvent<float> *,int>
PUBLIC	??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z		; operator<<float>
PUBLIC	??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z ; std::less<void>::operator()<CTimeEvent<float> &,float const &>
PUBLIC	??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z		; operator<<float>
PUBLIC	??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z ; std::less<void>::operator()<float const &,CTimeEvent<float> &>
PUBLIC	??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
PUBLIC	??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>
PUBLIC	??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>
PUBLIC	??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::destroy<CEffectMeshInstance::STextureInstance>
PUBLIC	??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z ; std::_Iter_cat<CTimeEvent<float> *>
PUBLIC	??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CTimeEvent<float> *,int>
PUBLIC	??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CTimeEvent<float> *,int>
PUBLIC	??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ; std::_Unchecked<CTimeEvent<float> *>
PUBLIC	??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z ; std::_Dist_type<CTimeEvent<float> *>
PUBLIC	??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >
PUBLIC	??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z ; std::forward<CTimeEvent<float> * &>
PUBLIC	??$forward@USTextureInstance@CEffectMeshInstance@@@std@@YA$$QAUSTextureInstance@CEffectMeshInstance@@AAU12@@Z ; std::forward<CEffectMeshInstance::STextureInstance>
PUBLIC	??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
PUBLIC	??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z ; std::allocator<CEffectMeshInstance::STextureInstance>::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > > >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@PAPAVCGraphicImageInstance@@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$_Uninit_copy@PBQAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ; std::_Uninit_copy<CGraphicImageInstance * const *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
PUBLIC	??$_Uninit_copy@QAVCGraphicImageInstance@@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CGraphicImageInstance * const,CGraphicImageInstance *>
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_7CFrameController@@6B@			; CFrameController::`vftable'
PUBLIC	??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@	; CDynamicPool<CEffectMeshInstance>::`vftable'
PUBLIC	?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
PUBLIC	??_7CEffectMeshInstance@@6B@			; CEffectMeshInstance::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CFrameController@@6B@			; CFrameController::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFrameController@@@8			; CFrameController `RTTI Type Descriptor'
PUBLIC	??_R3CFrameController@@8			; CFrameController::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFrameController@@8			; CFrameController::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFrameController@@8		; CFrameController::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CEffectMeshInstance@@6B@			; CEffectMeshInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMeshInstance@@@8			; CEffectMeshInstance `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMeshInstance@@8			; CEffectMeshInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMeshInstance@@8			; CEffectMeshInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMeshInstance@@8		; CEffectMeshInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CEffectElementBaseInstance@@8	; CEffectElementBaseInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectElementBaseInstance@@@8		; CEffectElementBaseInstance `RTTI Type Descriptor'
PUBLIC	??_R3CEffectElementBaseInstance@@8		; CEffectElementBaseInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectElementBaseInstance@@8		; CEffectElementBaseInstance::`RTTI Base Class Array'
PUBLIC	??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@	; CDynamicPool<CEffectMeshInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 ; CDynamicPool<CEffectMeshInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8	; CDynamicPool<CEffectMeshInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8	; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3a83126f
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@437f0000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetElapsedSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetElapsedSecond
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixInverse@12:PROC
EXTRN	_D3DXMatrixRotationX@8:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ:PROC ; CGraphicBase::GetViewMatrix
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z:PROC ; CEffectElementBase::GetPosition
EXTRN	??0CEffectElementBaseInstance@@QAE@XZ:PROC	; CEffectElementBaseInstance::CEffectElementBaseInstance
EXTRN	??1CEffectElementBaseInstance@@UAE@XZ:PROC	; CEffectElementBaseInstance::~CEffectElementBaseInstance
EXTRN	?Initialize@CEffectElementBaseInstance@@QAEXXZ:PROC ; CEffectElementBaseInstance::Initialize
EXTRN	?Destroy@CEffectElementBaseInstance@@QAEXXZ:PROC ; CEffectElementBaseInstance::Destroy
EXTRN	?isActive@CEffectElementBaseInstance@@QAE_NXZ:PROC ; CEffectElementBaseInstance::isActive
EXTRN	??0CFrameController@@QAE@XZ:PROC		; CFrameController::CFrameController
EXTRN	??1CFrameController@@UAE@XZ:PROC		; CFrameController::~CFrameController
EXTRN	?Clear@CFrameController@@QAEXXZ:PROC		; CFrameController::Clear
EXTRN	?Update@CFrameController@@QAEXM@Z:PROC		; CFrameController::Update
EXTRN	?GetCurrentFrame@CFrameController@@QAEEXZ:PROC	; CFrameController::GetCurrentFrame
EXTRN	?SetMaxFrame@CFrameController@@QAEXK@Z:PROC	; CFrameController::SetMaxFrame
EXTRN	?SetFrameTime@CFrameController@@QAEXM@Z:PROC	; CFrameController::SetFrameTime
EXTRN	?SetStartFrame@CFrameController@@QAEXK@Z:PROC	; CFrameController::SetStartFrame
EXTRN	?SetLoopFlag@CFrameController@@QAEXH@Z:PROC	; CFrameController::SetLoopFlag
EXTRN	?SetLoopCount@CFrameController@@QAEXH@Z:PROC	; CFrameController::SetLoopCount
EXTRN	?isActive@CFrameController@@QAEHK@Z:PROC	; CFrameController::isActive
EXTRN	??_ECFrameController@@UAEPAXI@Z:PROC		; CFrameController::`vector deleting destructor'
EXTRN	?GetFrameCount@CEffectMesh@@QAEKXZ:PROC		; CEffectMesh::GetFrameCount
EXTRN	?GetMeshCount@CEffectMesh@@QAEKXZ:PROC		; CEffectMesh::GetMeshCount
EXTRN	?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z:PROC ; CEffectMesh::GetMeshDataPointer
EXTRN	?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z:PROC ; CEffectMesh::GetTextureVectorPointer
EXTRN	?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ:PROC ; CEffectMeshScript::GetMeshFileName
EXTRN	?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z:PROC ; CEffectMeshScript::GetMeshDataPointer
EXTRN	?GetBillboardType@CEffectMeshScript@@QAEHK@Z:PROC ; CEffectMeshScript::GetBillboardType
EXTRN	?isBlendingEnable@CEffectMeshScript@@QAEHK@Z:PROC ; CEffectMeshScript::isBlendingEnable
EXTRN	?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z:PROC ; CEffectMeshScript::GetBlendingSrcType
EXTRN	?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z:PROC ; CEffectMeshScript::GetBlendingDestType
EXTRN	?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z:PROC ; CEffectMeshScript::GetColorOperationType
EXTRN	?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z:PROC ; CEffectMeshScript::GetColorFactor
EXTRN	?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z:PROC ; CEffectMeshScript::GetTimeTableAlphaPointer
EXTRN	?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ:PROC ; CEffectMeshScript::isMeshAnimationLoop
EXTRN	?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ:PROC ; CEffectMeshScript::GetMeshAnimationLoopCount
EXTRN	?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ:PROC ; CEffectMeshScript::GetMeshAnimationFrameDelay
EXTRN	??_E?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMeshInstance>::`vector deleting destructor'
EXTRN	??_ECEffectMeshInstance@@UAEPAXI@Z:PROC		; CEffectMeshInstance::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A:BYTE ; CGraphicImageInstance::ms_kPool
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
CRT$XCU	SEGMENT
?ms_kPool$initializer$@CEffectMeshInstance@@2P6AXXZA DD FLAT:??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ; CEffectMeshInstance::ms_kPool$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshInstance@@@@8 ; CDynamicPool<CEffectMeshInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8 DD 00H	; CDynamicPool<CEffectMeshInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8
data$r	SEGMENT
??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMeshInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCEffectMeshInstance@@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@ DD 00H	; CDynamicPool<CEffectMeshInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R2CEffectElementBaseInstance@@8 DD FLAT:??_R1A@?0A@EA@CEffectElementBaseInstance@@8 ; CEffectElementBaseInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R3CEffectElementBaseInstance@@8 DD 00H		; CEffectElementBaseInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectElementBaseInstance@@@8
data$r	SEGMENT
??_R0?AVCEffectElementBaseInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectElementBaseInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectElementBaseInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectElementBaseInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectElementBaseInstance@@8 DD FLAT:??_R0?AVCEffectElementBaseInstance@@@8 ; CEffectElementBaseInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMeshInstance@@8 DD FLAT:??_R0?AVCEffectMeshInstance@@@8 ; CEffectMeshInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R2CEffectMeshInstance@@8 DD FLAT:??_R1A@?0A@EA@CEffectMeshInstance@@8 ; CEffectMeshInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEffectElementBaseInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMeshInstance@@8
rdata$r	SEGMENT
??_R3CEffectMeshInstance@@8 DD 00H			; CEffectMeshInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMeshInstance@@@8
data$r	SEGMENT
??_R0?AVCEffectMeshInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectMeshInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMeshInstance@@', 00H
data$r	ENDS
;	COMDAT ??_R4CEffectMeshInstance@@6B@
rdata$r	SEGMENT
??_R4CEffectMeshInstance@@6B@ DD 00H			; CEffectMeshInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMeshInstance@@@8
	DD	FLAT:??_R3CEffectMeshInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFrameController@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFrameController@@8 DD FLAT:??_R0?AVCFrameController@@@8 ; CFrameController::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_R2CFrameController@@8
rdata$r	SEGMENT
??_R2CFrameController@@8 DD FLAT:??_R1A@?0A@EA@CFrameController@@8 ; CFrameController::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CFrameController@@8
rdata$r	SEGMENT
??_R3CFrameController@@8 DD 00H				; CFrameController::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFrameController@@@8
data$r	SEGMENT
??_R0?AVCFrameController@@@8 DD FLAT:??_7type_info@@6B@	; CFrameController `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFrameController@@', 00H
data$r	ENDS
;	COMDAT ??_R4CFrameController@@6B@
rdata$r	SEGMENT
??_R4CFrameController@@6B@ DD 00H			; CFrameController::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFrameController@@@8
	DD	FLAT:??_R3CFrameController@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7CEffectMeshInstance@@6B@
CONST	SEGMENT
??_7CEffectMeshInstance@@6B@ DD FLAT:??_R4CEffectMeshInstance@@6B@ ; CEffectMeshInstance::`vftable'
	DD	FLAT:??_ECEffectMeshInstance@@UAEPAXI@Z
	DD	FLAT:?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
	DD	FLAT:?OnInitialize@CEffectMeshInstance@@MAEXXZ
	DD	FLAT:?OnDestroy@CEffectMeshInstance@@MAEXXZ
	DD	FLAT:?OnUpdate@CEffectMeshInstance@@MAE_NM@Z
	DD	FLAT:?OnRender@CEffectMeshInstance@@MAEXXZ
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@ ; CEffectMeshInstance::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCEffectMeshInstance@@@@6B@ ; CDynamicPool<CEffectMeshInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CFrameController@@6B@
CONST	SEGMENT
??_7CFrameController@@6B@ DD FLAT:??_R4CFrameController@@6B@ ; CFrameController::`vftable'
	DD	FLAT:??_ECFrameController@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z$0
__ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z$0
__ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z$0
__ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z$0
__ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z$0
__unwindtable$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z$0
__ehfuncinfo$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z$0
__ehfuncinfo$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z$0
__ehfuncinfo$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CEffectMeshInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$3
__ehfuncinfo$??1CEffectMeshInstance@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CEffectMeshInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CEffectMeshInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$3
__ehfuncinfo$??0CEffectMeshInstance@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CEffectMeshInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z$0
__ehfuncinfo$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@QAVCGraphicImageInstance@@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@QAVCGraphicImageInstance@@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CGraphicImageInstance * const,CGraphicImageInstance *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 407  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@QAVCGraphicImageInstance@@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CGraphicImageInstance * const,CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PBQAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_copy@PBQAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z PROC ; std::_Uninit_copy<CGraphicImageInstance * const *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_copy@PBQAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ENDP ; std::_Uninit_copy<CGraphicImageInstance * const *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@PAPAVCGraphicImageInstance@@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@PAPAVCGraphicImageInstance@@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@PAPAVCGraphicImageInstance@@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > > >, COMDAT
; _this$ = ecx

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	c1 f9 02	 sar	 ecx, 2
  0000e	56		 push	 esi

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00016	56		 push	 esi
  00017	50		 push	 eax
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1641 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
$LN3@construct:

; 601  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN7@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@USTextureInstance@CEffectMeshInstance@@@std@@YA$$QAUSTextureInstance@CEffectMeshInstance@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USTextureInstance@CEffectMeshInstance@@@std@@YA$$QAUSTextureInstance@CEffectMeshInstance@@AAU12@@Z PROC ; std::forward<CEffectMeshInstance::STextureInstance>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@USTextureInstance@CEffectMeshInstance@@@std@@YA$$QAUSTextureInstance@CEffectMeshInstance@@AAU12@@Z ENDP ; std::forward<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z PROC ; std::forward<CTimeEvent<float> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAV?$CTimeEvent@M@@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@@Z ENDP ; std::forward<CTimeEvent<float> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z PROC ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2553 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2557 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 35		 jle	 SHORT $LN26@Upper_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Upper_boun:
; File a:\vs\vc\include\algorithm

; 2559 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00029	f3 0f 10 04 d6	 movss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00031	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2563 : 		if (!_Pred(_Val, *_Mid))

  00034	77 0c		 ja	 SHORT $LN2@Upper_boun

; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;

  00036	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2567 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	2b c2		 sub	 eax, edx
  0003e	03 c8		 add	 ecx, eax

; 2568 : 			}
; 2569 : 		else

  00040	eb 02		 jmp	 SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2570 : 			_Count = _Count2;

  00042	8b ca		 mov	 ecx, edx
$LN1@Upper_boun:

; 2557 : 	while (0 < _Count)

  00044	85 c9		 test	 ecx, ecx
  00046	7f d8		 jg	 SHORT $LL4@Upper_boun
$LN26@Upper_boun:

; 2571 : 		}
; 2572 : 	return (_First);

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 2573 : 	}

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Upper_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Upper_bound<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAV?$CTimeEvent@M@@PAV1@@std@@YAAAPAV?$CTimeEvent@M@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
___formal$ = 24						; size = 4
??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z PROC ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2508 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 31		 jle	 SHORT $LN26@Lower_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Lower_boun:
; File a:\vs\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	0f 2f 04 d6	 comiss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002d	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

  00030	76 0c		 jbe	 SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;

  00032	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2518 : 			_Count -= _Count2 + 1;

  00035	83 c8 ff	 or	 eax, -1
  00038	2b c2		 sub	 eax, edx
  0003a	03 c8		 add	 ecx, eax

; 2519 : 			}
; 2520 : 		else

  0003c	eb 02		 jmp	 SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

  0003e	8b ca		 mov	 ecx, edx
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

  00040	85 c9		 test	 ecx, ecx
  00042	7f dc		 jg	 SHORT $LL4@Lower_boun
$LN26@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 2524 : 	}

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$_Lower_bound@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Lower_bound<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z PROC ; std::_Dist_type<CTimeEvent<float> *>, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@PAV?$CTimeEvent@M@@@std@@YAPAHPAV?$CTimeEvent@M@@@Z ENDP ; std::_Dist_type<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z PROC ; std::_Unchecked<CTimeEvent<float> *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@PAV1@@Z ENDP ; std::_Unchecked<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CTimeEvent<float> *,int>, COMDAT

; 689  : 	{	// increment iterator by offset, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 691  : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CTimeEvent<float> *,int>, COMDAT

; 741  : 	{	// add to _Off distance between random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 751  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance2@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z PROC ; std::_Iter_cat<CTimeEvent<float> *>, COMDAT

; 405  : 	{	// return category from iterator argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Iter_cat@PAV?$CTimeEvent@M@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$CTimeEvent@M@@@Z ENDP ; std::_Iter_cat<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN11@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USTextureInstance@CEffectMeshInstance@@U12@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::destroy<CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00007	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0000a	85 c0		 test	 eax, eax
  0000c	74 1e		 je	 SHORT $LN12@destroy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00017	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 1630 : 			this->_Mylast = pointer();

  0001e	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1631 : 			this->_Myend = pointer();

  00025	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN12@destroy:
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  00033	5e		 pop	 esi
; File a:\vs\vc\include\xmemory0

; 608  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::destroy<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z PROC ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAV?$CTimeEvent@M@@AAPAV0@X@?$pair@PAV?$CTimeEvent@M@@PAV1@@std@@QAE@AAPAV?$CTimeEvent@M@@0@Z ENDP ; std::pair<CTimeEvent<float> *,CTimeEvent<float> *>::pair<CTimeEvent<float> *,CTimeEvent<float> *><CTimeEvent<float> * &,CTimeEvent<float> * &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
;	COMDAT ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z PROC ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 2580 : 	{	// find first element that _Val is before, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2584 : 			_Dist_type(_First))));

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2557 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 35		 jle	 SHORT $LN36@upper_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL12@upper_boun:
; File a:\vs\vc\include\algorithm

; 2559 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00029	f3 0f 10 04 d6	 movss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00031	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2563 : 		if (!_Pred(_Val, *_Mid))

  00034	77 0c		 ja	 SHORT $LN10@upper_boun

; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;

  00036	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2567 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	2b c2		 sub	 eax, edx
  0003e	03 c8		 add	 ecx, eax

; 2568 : 			}
; 2569 : 		else

  00040	eb 02		 jmp	 SHORT $LN9@upper_boun
$LN10@upper_boun:

; 2570 : 			_Count = _Count2;

  00042	8b ca		 mov	 ecx, edx
$LN9@upper_boun:

; 2557 : 	while (0 < _Count)

  00044	85 c9		 test	 ecx, ecx
  00046	7f d8		 jg	 SHORT $LL12@upper_boun
$LN36@upper_boun:

; 2584 : 			_Dist_type(_First))));

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 2585 : 	}

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ENDP ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z PROC ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  0000a	2b ce		 sub	 ecx, esi
  0000c	c1 f9 03	 sar	 ecx, 3
; File a:\vs\vc\include\algorithm

; 2508 : 	while (0 < _Count)

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 31		 jle	 SHORT $LN36@lower_boun
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00013	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL12@lower_boun:
; File a:\vs\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	0f 2f 04 d6	 comiss	 xmm0, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002d	8d 04 d6	 lea	 eax, DWORD PTR [esi+edx*8]
; File a:\vs\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

  00030	76 0c		 jbe	 SHORT $LN10@lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;

  00032	8d 70 08	 lea	 esi, DWORD PTR [eax+8]

; 2518 : 			_Count -= _Count2 + 1;

  00035	83 c8 ff	 or	 eax, -1
  00038	2b c2		 sub	 eax, edx
  0003a	03 c8		 add	 ecx, eax

; 2519 : 			}
; 2520 : 		else

  0003c	eb 02		 jmp	 SHORT $LN9@lower_boun
$LN10@lower_boun:

; 2521 : 			_Count = _Count2;

  0003e	8b ca		 mov	 ecx, edx
$LN9@lower_boun:

; 2508 : 	while (0 < _Count)

  00040	85 c9		 test	 ecx, ecx
  00042	7f dc		 jg	 SHORT $LL12@lower_boun
$LN36@lower_boun:

; 2535 : 			_Dist_type(_First))));

  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi

; 2536 : 	}

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ENDP ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xstddef
;	COMDAT ??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z PROC ; std::less<void>::operator()<float const &,CTimeEvent<float> &>, COMDAT
; _this$ = ecx

; 263  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al
; File a:\vs\vc\include\xstddef

; 269  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$?RABMAAV?$CTimeEvent@M@@@?$less@X@std@@QBE_NABMAAV?$CTimeEvent@M@@@Z ENDP ; std::less<void>::operator()<float const &,CTimeEvent<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z PROC		; operator<<float>, COMDAT

; 198  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 199  : 	return lhs < rhs.m_fTime;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al

; 200  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$?MM@@YA_NABMABV?$CTimeEvent@M@@@Z ENDP		; operator<<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xstddef
;	COMDAT ??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z PROC ; std::less<void>::operator()<CTimeEvent<float> &,float const &>, COMDAT
; _this$ = ecx

; 263  : 		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al
; File a:\vs\vc\include\xstddef

; 269  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
??$?RAAV?$CTimeEvent@M@@ABM@?$less@X@std@@QBE_NAAV?$CTimeEvent@M@@ABM@Z ENDP ; std::less<void>::operator()<CTimeEvent<float> &,float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z PROC		; operator<<float>, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 	return lhs.m_fTime < rhs;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _rhs$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00009	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0000d	33 c0		 xor	 eax, eax
  0000f	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00012	0f 97 c0	 seta	 al

; 194  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$?MM@@YA_NABV?$CTimeEvent@M@@ABM@Z ENDP		; operator<<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z PROC ; std::advance<CTimeEvent<float> *,int>, COMDAT

; 696  : 	{	// increment iterator by offset, arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 	_Where += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00010	01 08		 add	 DWORD PTR [eax], ecx

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$advance@PAV?$CTimeEvent@M@@H@std@@YAXAAPAV?$CTimeEvent@M@@H@Z ENDP ; std::advance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z PROC ; std::_Distance<CTimeEvent<float> *,int>, COMDAT

; 765  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	01 08		 add	 DWORD PTR [eax], ecx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Distance@PAV?$CTimeEvent@M@@H@std@@YAXPAV?$CTimeEvent@M@@0AAH@Z ENDP ; std::_Distance<CTimeEvent<float> *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCEffectMeshInstance@@PAV1@PAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCEffectMeshInstance@@PAV1@PAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CEffectMeshInstance *,CEffectMeshInstance *,CEffectMeshInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCEffectMeshInstance@@PAV1@PAV1@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CEffectMeshInstance *,CEffectMeshInstance *,CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z PROC ; std::_Val_type<CEffectMeshInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CEffectMeshInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE(_First, _Last);
; 439  : 	_DEBUG_POINTER(_Dest);
; 440  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 441  : 
; 442  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	8b ff		 npad	 2
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	0f 84 81 00 00
	00		 je	 $LN4@Uninit_mov
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00048	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  0004b	85 f6		 test	 esi, esi
  0004d	74 46		 je	 SHORT $LN24@Uninit_mov
  0004f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFrameController@@6B@
  00055	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00058	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0005e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00061	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00064	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00067	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0006a	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0006d	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00070	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00073	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00076	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00079	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0007f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00082	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00085	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  00088	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0008c	50		 push	 eax
  0008d	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00090	e8 00 00 00 00	 call	 ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
$LN24@Uninit_mov:
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  00095	83 c6 30	 add	 esi, 48			; 00000030H
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00098	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

  0009c	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  0009f	83 c7 30	 add	 edi, 48			; 00000030H
  000a2	eb 9c		 jmp	 SHORT $LL6@Uninit_mov
__catch$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)

  000a4	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  000a7	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  000aa	3b f7		 cmp	 esi, edi
  000ac	74 12		 je	 SHORT $LN1@Uninit_mov
  000ae	8b ff		 npad	 2
$LL3@Uninit_mov:

; 447  : 		_Al.destroy(_Next);

  000b0	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 ??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
  000b9	83 c6 30	 add	 esi, 48			; 00000030H
  000bc	3b f7		 cmp	 esi, edi
  000be	75 f0		 jne	 SHORT $LL3@Uninit_mov
$LN1@Uninit_mov:

; 448  : 	_RERAISE;

  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Uninit_mov:
$LN4@Uninit_mov:

; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

  000c9	8b c6		 mov	 eax, esi

; 451  : 	}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
$LN45@Uninit_mov:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$3:
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR $T2[ebp]
  00014	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
__ehhandler$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVCGraphicImageInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCGraphicImageInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CGraphicImageInstance *,CGraphicImageInstance *,CGraphicImageInstance *>, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 470  : 	_DEBUG_RANGE(_First, _Last);
; 471  : 	_DEBUG_POINTER(_Dest);
; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 475  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAVCGraphicImageInstance@@PAV1@PAV1@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CGraphicImageInstance *,CGraphicImageInstance *,CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z PROC ; std::_Val_type<CGraphicImageInstance * *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z ENDP ; std::_Val_type<CGraphicImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00007	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0000a	85 c0		 test	 eax, eax
  0000c	74 1e		 je	 SHORT $LN14@destroy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00017	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 1630 : 			this->_Mylast = pointer();

  0001e	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1631 : 			this->_Myend = pointer();

  00025	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN14@destroy:
  0002c	8b ce		 mov	 ecx, esi
  0002e	5e		 pop	 esi
; File a:\vs\vc\include\xmemory0

; 731  : 		}

  0002f	5d		 pop	 ebp
  00030	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\utility
;	COMDAT ??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>, COMDAT
; _this$ = ecx

; 144  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 145  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@AAV01@X@?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >::pair<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT

; 404  : 	{	// convert to checked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@AAV10@PAV?$CTimeEvent@M@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xutility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$1$ = 16						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z PROC ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >, COMDAT

; 2603 : 	{	// find range equivalent to _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xutility

; 750  : 	_Off += _Last - _First;

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0000a	2b cb		 sub	 ecx, ebx
  0000c	c1 f9 03	 sar	 ecx, 3
  0000f	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 2607 : 	while (0 < _Count)

  00010	85 c9		 test	 ecx, ecx
  00012	7e 3c		 jle	 SHORT $LN5@Equal_rang
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00014	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00017	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0001b	eb 03 8d 49 00	 npad	 5
$LL6@Equal_rang:
; File a:\vs\vc\include\algorithm

; 2609 : 		_Diff _Count2 = _Count / 2;

  00020	8b c1		 mov	 eax, ecx
  00022	99		 cdq
  00023	2b c2		 sub	 eax, edx
  00025	8b d0		 mov	 edx, eax
  00027	d1 fa		 sar	 edx, 1
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00029	f3 0f 10 04 d3	 movss	 xmm0, DWORD PTR [ebx+edx*8]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0002e	8d 34 d3	 lea	 esi, DWORD PTR [ebx+edx*8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 193  : 	return lhs.m_fTime < rhs;

  00031	0f 2f c8	 comiss	 xmm1, xmm0
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  00034	89 75 10	 mov	 DWORD PTR __Mid$1$[ebp], esi
; File a:\vs\vc\include\algorithm

; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

  00037	76 0c		 jbe	 SHORT $LN4@Equal_rang

; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;

  00039	83 c8 ff	 or	 eax, -1
  0003c	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  0003f	2b c2		 sub	 eax, edx
  00041	03 c8		 add	 ecx, eax

; 2618 : 		else if (_Pred(_Val, *_Mid))

  00043	eb 07		 jmp	 SHORT $LN1@Equal_rang
$LN4@Equal_rang:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 199  : 	return lhs < rhs.m_fTime;

  00045	0f 2f c1	 comiss	 xmm0, xmm1
; File a:\vs\vc\include\algorithm

; 2618 : 		else if (_Pred(_Val, *_Mid))

  00048	76 12		 jbe	 SHORT $LN2@Equal_rang

; 2619 : 			_Count = _Count2;	// range in first half, loop

  0004a	8b ca		 mov	 ecx, edx
$LN1@Equal_rang:

; 2607 : 	while (0 < _Count)

  0004c	85 c9		 test	 ecx, ecx
  0004e	7f d0		 jg	 SHORT $LL6@Equal_rang
$LN5@Equal_rang:
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	5e		 pop	 esi
  00054	89 18		 mov	 DWORD PTR [eax], ebx
  00056	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00059	5b		 pop	 ebx
; File a:\vs\vc\include\algorithm

; 2630 : 	}

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN2@Equal_rang:

; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);

  0005c	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
; File a:\vs\vc\include\xutility

; 690  : 	_Where += _Off;

  0005f	8d 04 cb	 lea	 eax, DWORD PTR [ebx+ecx*8]
; File a:\vs\vc\include\algorithm

; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);

  00062	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00065	50		 push	 eax
  00066	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$upper_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::upper_bound<CTimeEvent<float> *,float,std::less<void> >
  0006f	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  00072	8b f0		 mov	 esi, eax
  00074	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Mid$1$[ebp]
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 ??$lower_bound@PAV?$CTimeEvent@M@@MU?$less@X@std@@@std@@YAPAV?$CTimeEvent@M@@PAV1@0ABMU?$less@X@0@@Z ; std::lower_bound<CTimeEvent<float> *,float,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00080	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);

  00083	83 c4 20	 add	 esp, 32			; 00000020H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00086	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00089	5e		 pop	 esi
  0008a	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\algorithm

; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));

  0008c	8b c1		 mov	 eax, ecx
  0008e	5b		 pop	 ebx

; 2630 : 	}

  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ENDP ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >, COMDAT

; 706  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 707  : 	}

  00002	c3		 ret	 0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@YAPAV?$CTimeEvent@M@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 588  : 		::new ((void *)_Ptr) _Ty();

  00024	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	85 f6		 test	 esi, esi
  00033	74 1c		 je	 SHORT $LN5@construct
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0003c	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 483  : 		_Mylast = pointer();

  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 484  : 		_Myend = pointer();

  0004a	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN5@construct:
; File a:\vs\vc\include\xmemory0

; 724  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USTextureInstance@CEffectMeshInstance@@$$$V@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@PAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::construct<CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAAAPAPAVCEffectMeshInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAAAPAPAVCEffectMeshInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CEffectMeshInstance * *,CEffectMeshInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCEffectMeshInstance@@PAPAV1@@std@@YAAAPAPAVCEffectMeshInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CEffectMeshInstance * *,CEffectMeshInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CEffectMeshInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CEffectMeshInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUSTextureInstance@CEffectMeshInstance@@PAU12@@std@@YAAAPAUSTextureInstance@CEffectMeshInstance@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUSTextureInstance@CEffectMeshInstance@@PAU12@@std@@YAAAPAUSTextureInstance@CEffectMeshInstance@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUSTextureInstance@CEffectMeshInstance@@PAU12@@std@@YAAAPAUSTextureInstance@CEffectMeshInstance@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00015	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 485  : 	}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z PROC ; std::_Unchecked<CEffectMeshInstance::STextureInstance *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z ENDP ; std::_Unchecked<CEffectMeshInstance::STextureInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCEffectMeshInstance@@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCEffectMeshInstance@@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z PROC ; std::allocator<CEffectMeshInstance *>::destroy<CEffectMeshInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCEffectMeshInstance@@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z ENDP ; std::allocator<CEffectMeshInstance *>::destroy<CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z PROC ; std::allocator<CEffectMeshInstance *>::construct<CEffectMeshInstance *,CEffectMeshInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z ENDP ; std::allocator<CEffectMeshInstance *>::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicImageInstance@@AAPAPAV1@PAPAV1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicImageInstance@@AAPAPAV1@PAPAV1@@Z PROC ; std::_Rechecked<CGraphicImageInstance * *,CGraphicImageInstance * *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 	return (_Dest);
; 291  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAPAVCGraphicImageInstance@@PAPAV1@@std@@YAAAPAPAVCGraphicImageInstance@@AAPAPAV1@PAPAV1@@Z ENDP ; std::_Rechecked<CGraphicImageInstance * *,CGraphicImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z PROC ; std::_Uninit_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ENDP ; std::_Uninit_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z PROC ; std::_Unchecked<CGraphicImageInstance * *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 282  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAPAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@@Z ENDP ; std::_Unchecked<CGraphicImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicImageInstance@@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCGraphicImageInstance@@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z PROC ; std::allocator<CGraphicImageInstance *>::destroy<CGraphicImageInstance *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCGraphicImageInstance@@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z ENDP ; std::allocator<CGraphicImageInstance *>::destroy<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00007	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0000a	85 c0		 test	 eax, eax
  0000c	74 1e		 je	 SHORT $LN16@destroy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00017	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 1630 : 			this->_Mylast = pointer();

  0001e	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1631 : 			this->_Myend = pointer();

  00025	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN16@destroy:
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  00033	5e		 pop	 esi
; File a:\vs\vc\include\xmemory0

; 880  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z PROC ; std::allocator<CGraphicImageInstance *>::construct<CGraphicImageInstance *,CGraphicImageInstance * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z ENDP ; std::allocator<CGraphicImageInstance *>::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z PROC ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >, COMDAT

; 2638 : 	{	// find range equivalent to _Val, using _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00006	6a 00		 push	 0
  00008	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  0000b	8d 45 f8	 lea	 eax, DWORD PTR __Ans$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00020	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00023	8b 4d f8	 mov	 ecx, DWORD PTR __Ans$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Ans$[ebp+4]
  0002b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\algorithm

; 2646 : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@MU?$less@X@2@@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABMU?$less@X@0@@Z ENDP ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z PROC ; std::addressof<CTimeEvent<float> >, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@AAV1@@Z ENDP ; std::addressof<CTimeEvent<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z PROC ; std::pointer_traits<CTimeEvent<float> *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 234  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 235  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAV?$CTimeEvent@M@@@std@@SAPAV?$CTimeEvent@M@@AAV3@@Z ENDP ; std::pointer_traits<CTimeEvent<float> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCEffectMeshInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectMeshInstance * *,CEffectMeshInstance * *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00003	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
  00019	83 c4 18	 add	 esp, 24			; 00000018H

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCEffectMeshInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCEffectMeshInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCEffectMeshInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCEffectMeshInstance@@0@Z PROC ; std::_Ptr_cat<CEffectMeshInstance *,CEffectMeshInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCEffectMeshInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCEffectMeshInstance@@0@Z ENDP ; std::_Ptr_cat<CEffectMeshInstance *,CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 80   : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 81   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 38		 je	 SHORT $LN1@Destroy_ra
  0000f	83 c6 24	 add	 esi, 36			; 00000024H
$LL3@Destroy_ra:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	85 c0		 test	 eax, eax
  00016	74 1d		 je	 SHORT $LN21@Destroy_ra
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001e	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00021	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0002e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN21@Destroy_ra:
  00035	8d 4e dc	 lea	 ecx, DWORD PTR [esi-36]
  00038	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
; File a:\vs\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

  0003d	83 c6 30	 add	 esi, 48			; 00000030H
  00040	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  00043	3b c7		 cmp	 eax, edi
  00045	75 cb		 jne	 SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 82   : 		_Al.destroy(_First);
; 83   : 	}

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCEffectMeshInstance@@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCEffectMeshInstance@@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCEffectMeshInstance@@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCEffectMeshInstance@@@std@@YAABQAVCEffectMeshInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCEffectMeshInstance@@@std@@YAABQAVCEffectMeshInstance@@ABQAV1@@Z PROC ; std::forward<CEffectMeshInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCEffectMeshInstance@@@std@@YAABQAVCEffectMeshInstance@@ABQAV1@@Z ENDP ; std::forward<CEffectMeshInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAXAAV?$allocator@PAVCEffectMeshInstance@@@1@PAPAVCEffectMeshInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCEffectMeshInstance@@@std@@YAAAPAVCEffectMeshInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCEffectMeshInstance@@@std@@YAAAPAVCEffectMeshInstance@@AAPAV1@@Z PROC ; std::forward<CEffectMeshInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCEffectMeshInstance@@@std@@YAAAPAVCEffectMeshInstance@@AAPAV1@@Z ENDP ; std::forward<CEffectMeshInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicImageInstance@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicImageInstance * *,CGraphicImageInstance * *,std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 90   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImageInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImageInstance@@0@Z PROC ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVCGraphicImageInstance@@0@Z ENDP ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCGraphicImageInstance@@PAPAV2@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCGraphicImageInstance@@PAPAV2@@Z PROC ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>, COMDAT

; 453  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 456  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAVCGraphicImageInstance@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVCGraphicImageInstance@@PAPAV2@@Z ENDP ; std::_Ptr_cat<CGraphicImageInstance *,CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicImageInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVCGraphicImageInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

  00000	c3		 ret	 0
??$destroy@PAVCGraphicImageInstance@@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>, COMDAT

; 645  : 	{	// copy _Count * _Valty() to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 646  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 647  : //	if (_Count < 0)
; 648  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 649  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 650  : 
; 651  : 	_FwdIt _Next = _First;

  0002b	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 652  : 
; 653  : 	_TRY_BEGIN

  0002e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00031	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_def:

; 654  : 	for (; 0 < _Count; --_Count, ++_First)

  00040	85 ff		 test	 edi, edi
  00042	74 57		 je	 SHORT $LN4@Uninit_def
; File a:\vs\vc\include\xmemory0

; 588  : 		::new ((void *)_Ptr) _Ty();

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 1c		 je	 SHORT $LN20@Uninit_def
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00056	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 483  : 		_Mylast = pointer();

  0005d	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 484  : 		_Myend = pointer();

  00064	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN20@Uninit_def:
; File a:\vs\vc\include\xmemory

; 654  : 	for (; 0 < _Count; --_Count, ++_First)

  0006b	4f		 dec	 edi
; File a:\vs\vc\include\xmemory0

; 588  : 		::new ((void *)_Ptr) _Ty();

  0006c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 654  : 	for (; 0 < _Count; --_Count, ++_First)

  00070	83 c6 30	 add	 esi, 48			; 00000030H
  00073	89 75 08	 mov	 DWORD PTR __First$[ebp], esi
  00076	eb c8		 jmp	 SHORT $LL6@Uninit_def
__catch$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 655  : 
; 656  : 		_Al.construct(_First);
; 657  : 
; 658  : 	_CATCH_ALL
; 659  : 	for (; _Next != _First; ++_Next)

  00078	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  0007b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0007e	3b f7		 cmp	 esi, edi
  00080	74 10		 je	 SHORT $LN1@Uninit_def
$LL3@Uninit_def:

; 660  : 		_Al.destroy(_Next);

  00082	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ??$destroy@USTextureInstance@CEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::destroy<CEffectMeshInstance::STextureInstance>
  0008b	83 c6 30	 add	 esi, 48			; 00000030H
  0008e	3b f7		 cmp	 esi, edi
  00090	75 f0		 jne	 SHORT $LL3@Uninit_def
$LN1@Uninit_def:

; 661  : 	_RERAISE;

  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@Uninit_def:
$LN4@Uninit_def:

; 662  : 	_CATCH_END
; 663  : 	}

  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN45@Uninit_def:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Ptr_cat@USTextureInstance@CEffectMeshInstance@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSTextureInstance@CEffectMeshInstance@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USTextureInstance@CEffectMeshInstance@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSTextureInstance@CEffectMeshInstance@@0@Z PROC ; std::_Ptr_cat<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>, COMDAT

; 444  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 447  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@USTextureInstance@CEffectMeshInstance@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSTextureInstance@CEffectMeshInstance@@0@Z ENDP ; std::_Ptr_cat<CEffectMeshInstance::STextureInstance,CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ??$_Val_type@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z PROC ; std::_Val_type<CEffectMeshInstance::STextureInstance *>, COMDAT

; 646  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 647  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUSTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@@Z ENDP ; std::_Val_type<CEffectMeshInstance::STextureInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCEffectMeshInstance@@@Z@std@@YA$$QAP6AXPAVCEffectMeshInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCEffectMeshInstance@@@Z@std@@YA$$QAP6AXPAVCEffectMeshInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CEffectMeshInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCEffectMeshInstance@@@Z@std@@YA$$QAP6AXPAVCEffectMeshInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CEffectMeshInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCEffectMeshInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCEffectMeshInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCEffectMeshInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCEffectMeshInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CEffectMeshInstance * *,void (__cdecl*)(CEffectMeshInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCEffectMeshInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCEffectMeshInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CEffectMeshInstance * *,void (__cdecl*)(CEffectMeshInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAPAPAVCEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@ABQAVCGraphicImageInstance@@@std@@YAABQAVCGraphicImageInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVCGraphicImageInstance@@@std@@YAABQAVCGraphicImageInstance@@ABQAV1@@Z PROC ; std::forward<CGraphicImageInstance * const &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAVCGraphicImageInstance@@@std@@YAABQAVCGraphicImageInstance@@ABQAV1@@Z ENDP ; std::forward<CGraphicImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN7@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAXAAV?$allocator@PAVCGraphicImageInstance@@@1@PAPAVCGraphicImageInstance@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$forward@AAPAVCGraphicImageInstance@@@std@@YAAAPAVCGraphicImageInstance@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVCGraphicImageInstance@@@std@@YAAAPAVCGraphicImageInstance@@AAPAV1@@Z PROC ; std::forward<CGraphicImageInstance * &>, COMDAT

; 1504 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAVCGraphicImageInstance@@@std@@YAAAPAVCGraphicImageInstance@@AAPAV1@@Z ENDP ; std::forward<CGraphicImageInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YA$$QAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YA$$QAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CEffectMeshInstance::STextureInstance &)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YA$$QAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CEffectMeshInstance::STextureInstance &)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAUSTextureInstance@CEffectMeshInstance@@P6AXAAU12@@Z@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAP6AXAAU12@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAUSTextureInstance@CEffectMeshInstance@@P6AXAAU12@@Z@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAP6AXAAU12@@Z@Z PROC ; std::_For_each<CEffectMeshInstance::STextureInstance *,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 23   : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 14		 je	 SHORT $LN1@For_each
  0000f	53		 push	 ebx
  00010	8b 5d 10	 mov	 ebx, DWORD PTR __Func$[ebp]
$LL3@For_each:

; 24   : 		_Func(*_First);

  00013	8b 03		 mov	 eax, DWORD PTR [ebx]
  00015	56		 push	 esi
  00016	ff d0		 call	 eax
  00018	83 c6 30	 add	 esi, 48			; 00000030H
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b f7		 cmp	 esi, edi
  00020	75 f1		 jne	 SHORT $LL3@For_each
  00022	5b		 pop	 ebx
$LN1@For_each:
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 25   : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_For_each@PAUSTextureInstance@CEffectMeshInstance@@P6AXAAU12@@Z@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAP6AXAAU12@@Z@Z ENDP ; std::_For_each<CEffectMeshInstance::STextureInstance *,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\type_traits
;	COMDAT ??$move@AAP6AXPAVCGraphicImageInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicImageInstance@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXPAVCGraphicImageInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicImageInstance@@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(CGraphicImageInstance *)>, COMDAT

; 1519 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAP6AXPAVCGraphicImageInstance@@@Z@std@@YA$$QAP6AXPAVCGraphicImageInstance@@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(CGraphicImageInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$_For_each@PAPAVCGraphicImageInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicImageInstance@@0AAP6AXPAV1@@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$_For_each@PAPAVCGraphicImageInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicImageInstance@@0AAP6AXPAV1@@Z@Z PROC ; std::_For_each<CGraphicImageInstance * *,void (__cdecl*)(CGraphicImageInstance *)>, COMDAT

; 22   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 14		 je	 SHORT $LN1@For_each
$LL3@For_each:

; 24   : 		_Func(*_First);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00025	ff 36		 push	 DWORD PTR [esi]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	47		 inc	 edi
  0002c	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b fb		 cmp	 edi, ebx
  00034	75 ec		 jne	 SHORT $LL3@For_each
$LN1@For_each:
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx

; 25   : 	}

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_For_each@PAPAVCGraphicImageInstance@@P6AXPAV1@@Z@std@@YAXPAPAVCGraphicImageInstance@@0AAP6AXPAV1@@Z@Z ENDP ; std::_For_each<CGraphicImageInstance * *,void (__cdecl*)(CGraphicImageInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPBQAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPBQAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >, COMDAT

; 264  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 265  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 266  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPBQAVCGraphicImageInstance@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >, COMDAT

; 395  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 396  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 397  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAPAPAVCGraphicImageInstance@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\utility
; File a:\vs\vc\include\algorithm
;	COMDAT ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z PROC ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>, COMDAT

; 2654 : 	{	// find range equivalent to _Val, using operator<

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00006	6a 00		 push	 0

; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));

  00008	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  0000c	8d 45 f8	 lea	 eax, DWORD PTR __Ans$1[ebp]
  0000f	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  00012	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  00015	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __First$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Equal_range@PAV?$CTimeEvent@M@@MHU?$less@X@std@@@std@@YA?AU?$pair@PAV?$CTimeEvent@M@@PAV1@@0@PAV?$CTimeEvent@M@@0ABMU?$less@X@0@PAH@Z ; std::_Equal_range<CTimeEvent<float> *,float,int,std::less<void> >
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\vs\vc\include\algorithm

; 2642 : 			_Val, _Pred, _Dist_type(_First)));

  00024	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\utility

; 144  : 		{	// construct from moved values

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __Ans$1[ebp]
  0002a	89 08		 mov	 DWORD PTR [eax], ecx
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Ans$1[ebp+4]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File a:\vs\vc\include\algorithm

; 2656 : 	}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ENDP ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 03	 shl	 eax, 3
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 03	 shl	 eax, 3
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+, COMDAT
; _this$ = ecx

; 365  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

  0000b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 368  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--, COMDAT
; _this$ = ecx

; 141  : 		--this->_Ptr;

  00000	83 01 f8	 add	 DWORD PTR [ecx], -8	; fffffff8H

; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 349  : 		}

  00005	c3		 ret	 0
??F?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->, COMDAT
; _this$ = ecx

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 330  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEAAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEPAV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked, COMDAT
; _this$ = ecx

; 312  : 		{	// reset from unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		this->_Ptr = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		return (*this);

  00008	8b c1		 mov	 eax, ecx

; 315  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV12@PAV?$CTimeEvent@M@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--, COMDAT
; _this$ = ecx

; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;

  00000	83 01 f8	 add	 DWORD PTR [ecx], -8	; fffffff8H

; 142  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 143  : 		}

  00005	c3		 ret	 0
??F?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QBEABV?$CTimeEvent@M@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@QAE@PAV?$CTimeEvent@M@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CEffectMeshInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCEffectMeshInstance@@@std@@YAPAPAVCEffectMeshInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@USTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@IPAU12@@Z PROC ; std::_Allocate<CEffectMeshInstance::STextureInstance>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 21		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 05	 cmp	 eax, 89478485		; 05555555H
  00011	77 15		 ja	 SHORT $LN1@Allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 04	 shl	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00028	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002d	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Allocate@USTextureInstance@CEffectMeshInstance@@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@IPAU12@@Z ENDP ; std::_Allocate<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEPAPAVCEffectMeshInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEPAPAVCEffectMeshInstance@@PAPAV2@00@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Umove<CEffectMeshInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCEffectMeshInstance@@@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEPAPAVCEffectMeshInstance@@PAPAV2@00@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Umove<CEffectMeshInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@IPAPAV1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@IPAPAV1@@Z PROC ; std::_Allocate<CGraphicImageInstance *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1e		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 12		 ja	 SHORT $LN1@Allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00025	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0002a	8b c1		 mov	 eax, ecx

; 32   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Allocate@PAVCGraphicImageInstance@@@std@@YAPAPAVCGraphicImageInstance@@IPAPAV1@@Z ENDP ; std::_Allocate<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAUSTextureInstance@CEffectMeshInstance@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEPAUSTextureInstance@CEffectMeshInstance@@PAU23@00@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$1 = 16						; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUSTextureInstance@CEffectMeshInstance@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEPAUSTextureInstance@CEffectMeshInstance@@PAU23@00@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Umove<CEffectMeshInstance::STextureInstance *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	ff 75 10	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	6a 00		 push	 0
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00013	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
  0001b	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1649 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSTextureInstance@CEffectMeshInstance@@@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEPAUSTextureInstance@CEffectMeshInstance@@PAU23@00@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Umove<CEffectMeshInstance::STextureInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@YAXPAPAVCEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 97   : 	}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCEffectMeshInstance@@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::destroy<CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCEffectMeshInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCEffectMeshInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::construct<CEffectMeshInstance *,CEffectMeshInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCEffectMeshInstance@@@std@@YAPBQAVCEffectMeshInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCEffectMeshInstance@@@std@@YAPBQAVCEffectMeshInstance@@ABQAV1@@Z PROC ; std::addressof<CEffectMeshInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCEffectMeshInstance@@@std@@YAPBQAVCEffectMeshInstance@@ABQAV1@@Z ENDP ; std::addressof<CEffectMeshInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@PAPAV2@00@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Umove<CGraphicImageInstance * *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	c1 f8 02	 sar	 eax, 2
  0000e	56		 push	 esi

; 473  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	56		 push	 esi
  00017	51		 push	 ecx
  00018	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	03 c6		 add	 eax, esi
  00025	5e		 pop	 esi
; File a:\vs\vc\include\vector

; 1649 : 		}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAPAVCGraphicImageInstance@@@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEPAPAVCGraphicImageInstance@@PAPAV2@00@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Umove<CGraphicImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@YAXPAPAVCGraphicImageInstance@@0AAU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$destroy@PAVCGraphicImageInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVCGraphicImageInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAVCGraphicImageInstance@@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::destroy<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT

; 690  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 691  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	ff 75 fc	 push	 DWORD PTR __Cat$1[ebp]
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00012	e8 00 00 00 00	 call	 ??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 693  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@P6AXPAVCEffectMeshInstance@@@Z@std@@YAP6AXPAVCEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >,void (__cdecl*)(CEffectMeshInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEAAPAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEAAPAVCEffectMeshInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEAAPAVCEffectMeshInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEPAPAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEPAPAVCEffectMeshInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEPAPAVCEffectMeshInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEABQAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEABQAVCEffectMeshInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBEABQAVCEffectMeshInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@PAPAVCEffectMeshInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImageInstance@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAVCGraphicImageInstance@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::construct<CGraphicImageInstance *,CGraphicImageInstance * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xstddef
;	COMDAT ??$addressof@QAVCGraphicImageInstance@@@std@@YAPBQAVCGraphicImageInstance@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVCGraphicImageInstance@@@std@@YAPBQAVCGraphicImageInstance@@ABQAV1@@Z PROC ; std::addressof<CGraphicImageInstance * const>, COMDAT

; 92   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@QAVCGraphicImageInstance@@@std@@YAPBQAVCGraphicImageInstance@@ABQAV1@@Z ENDP ; std::addressof<CGraphicImageInstance * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@P6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@P6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 23   : 	for (; _First != _Last; ++_First)

  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 18		 je	 SHORT $LN22@for_each
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Func$[ebp]
$LL13@for_each:

; 24   : 		_Func(*_First);

  00013	56		 push	 esi
  00014	ff d7		 call	 edi
  00016	83 c6 30	 add	 esi, 48			; 00000030H
  00019	83 c4 04	 add	 esp, 4
  0001c	3b f3		 cmp	 esi, ebx
  0001e	75 f3		 jne	 SHORT $LL13@for_each

; 34   : 
; 35   : 	return (_STD move(_Func));

  00020	8b c7		 mov	 eax, edi
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx

; 36   : 	}

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 36   : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@P6AXAAUSTextureInstance@CEffectMeshInstance@@@Z@std@@YAP6AXAAUSTextureInstance@CEffectMeshInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >,void (__cdecl*)(CEffectMeshInstance::STextureInstance &)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBEPAUSTextureInstance@CEffectMeshInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBEPAUSTextureInstance@CEffectMeshInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBEPAUSTextureInstance@CEffectMeshInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@PAUSTextureInstance@CEffectMeshInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicImageInstance@@@Z@std@@YAP6AXPAVCGraphicImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicImageInstance@@@Z@std@@YAP6AXPAVCGraphicImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,void (__cdecl*)(CGraphicImageInstance *)>, COMDAT

; 30   : 	{	// perform function for each element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 31   : 	_DEBUG_RANGE(_First, _Last);
; 32   : 	_DEBUG_POINTER(_Func);
; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	83 c3 03	 add	 ebx, 3
  00012	c1 eb 02	 shr	 ebx, 2
  00015	57		 push	 edi
  00016	33 ff		 xor	 edi, edi
  00018	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001b	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN22@for_each
$LL13@for_each:

; 24   : 		_Func(*_First);

  00022	ff 36		 push	 DWORD PTR [esi]
  00024	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00027	47		 inc	 edi
  00028	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b fb		 cmp	 edi, ebx
  00030	75 f0		 jne	 SHORT $LL13@for_each
$LN22@for_each:

; 34   : 
; 35   : 	return (_STD move(_Func));

  00032	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx

; 36   : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicImageInstance@@@Z@std@@YAP6AXPAVCGraphicImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >,void (__cdecl*)(CGraphicImageInstance *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-, COMDAT
; _this$ = ecx

; 376  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	c1 e0 02	 shl	 eax, 2
  0000b	2b c8		 sub	 ecx, eax

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00010	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-=, COMDAT
; _this$ = ecx

; 371  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	f7 d8		 neg	 eax
  00008	c1 e0 02	 shl	 eax, 2
  0000b	01 01		 add	 DWORD PTR [ecx], eax

; 372  : 		return (*this += -_Off);

  0000d	8b c1		 mov	 eax, ecx

; 373  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 359  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 362  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicImageInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEAAPAVCGraphicImageInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicImageInstance@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 319  : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 320  : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPAPAVCGraphicImageInstance@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=, COMDAT
; _this$ = ecx

; 153  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	01 01		 add	 DWORD PTR [ecx], eax

; 171  : 		return (*this);

  0000b	8b c1		 mov	 eax, ecx

; 172  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEABQAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEABQAVCGraphicImageInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEABQAVCGraphicImageInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPBQAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPBQAVCGraphicImageInstance@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBEPBQAVCGraphicImageInstance@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicImageInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
_rkInstance$ = 8					; size = 4
?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; CEffectMeshInstance_DeleteTextureInstance, COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstance$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0000e	33 ff		 xor	 edi, edi
  00010	8b 59 28	 mov	 ebx, DWORD PTR [ecx+40]
  00013	2b de		 sub	 ebx, esi
  00015	83 c3 03	 add	 ebx, 3
  00018	c1 eb 02	 shr	 ebx, 2
  0001b	3b 71 28	 cmp	 esi, DWORD PTR [ecx+40]
  0001e	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00021	85 db		 test	 ebx, ebx
  00023	74 20		 je	 SHORT $LN44@CEffectMes
$LL31@CEffectMes:

; 24   : 		_Func(*_First);

  00025	ff 36		 push	 DWORD PTR [esi]
  00027	e8 00 00 00 00	 call	 ?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ; CEffectMeshInstance_DeleteImageInstance
  0002c	47		 inc	 edi
  0002d	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00030	83 c4 04	 add	 esp, 4
  00033	3b fb		 cmp	 edi, ebx
  00035	75 ee		 jne	 SHORT $LL31@CEffectMes
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstance$[ebp]
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00040	89 41 28	 mov	 DWORD PTR [ecx+40], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 250  : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN44@CEffectMes:
  00045	5f		 pop	 edi
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  0004c	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 250  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; CEffectMeshInstance_DeleteTextureInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkInstance$ = 8					; size = 4
?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z PROC ; CEffectMeshInstance_DeleteImageInstance, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 242  : 	CGraphicImageInstance::ms_kPool.Free(pkInstance);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pkInstance$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00006	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+16
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 242  : 	CGraphicImageInstance::ms_kPool.Free(pkInstance);

  0000b	89 45 08	 mov	 DWORD PTR _pkData$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000e	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 243  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?CEffectMeshInstance_DeleteImageInstance@@YAXPAVCGraphicImageInstance@@@Z ENDP ; CEffectMeshInstance_DeleteImageInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++, COMDAT
; _this$ = ecx

; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 336  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEAAPAVCGraphicImage@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEAAPAVCGraphicImage@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*, COMDAT
; _this$ = ecx

; 324  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 325  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEAAPAVCGraphicImage@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 307  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Compat, COMDAT
; _this$ = ecx

; 255  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 210  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 211  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 206  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 113  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 114  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEABQAVCGraphicImage@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEABQAVCGraphicImage@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QBEABQAVCGraphicImage@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@std@@QAE@PAPAVCGraphicImage@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicImage *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
;	COMDAT ??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z
_TEXT	SEGMENT
_result$ = -8						; size = 8
_fElapsedTime$ = 8					; size = 4
_rVector$ = 12						; size = 4
_pReturnValue$ = 16					; size = 4
??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z PROC ; GetTimeEventBlendValue<float>, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _rVector$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 228  : {

  00006	83 ec 08	 sub	 esp, 8
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 229  : 	if (rVector.empty())

  00010	75 0d		 jne	 SHORT $LN6@GetTimeEve

; 230  : 	{
; 231  : 		*pReturnValue = T();

  00012	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 264  : 	}
; 265  : 
; 266  : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN6@GetTimeEve:
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  0001f	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00022	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  00024	74 3c		 je	 SHORT $LN219@GetTimeEve

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;
; 238  : 		return;
; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  00026	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002a	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fElapsedTime$[ebp]
  0002f	0f 2f c1	 comiss	 xmm0, xmm1
  00032	77 2e		 ja	 SHORT $LN219@GetTimeEve

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;
; 244  : 		return;
; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  00034	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  00038	76 0c		 jbe	 SHORT $LN3@GetTimeEve

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  0003a	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  0003d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00040	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 	}
; 265  : 
; 266  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN3@GetTimeEve:

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00046	8d 55 08	 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  00049	52		 push	 edx
  0004a	51		 push	 ecx
  0004b	50		 push	 eax
  0004c	8d 45 f8	 lea	 eax, DWORD PTR _result$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00055	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  00058	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _result$[ebp+4]
  0005e	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00060	74 0c		 je	 SHORT $LN2@GetTimeEve
$LN219@GetTimeEve:

; 258  : 		*pReturnValue = result.first->m_Value;

  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00068	89 08		 mov	 DWORD PTR [eax], ecx

; 264  : 	}
; 265  : 
; 266  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN2@GetTimeEve:

; 259  : 	else
; 260  : 	{
; 261  : 		--result.first;
; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0006e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00072	0f 28 d0	 movaps	 xmm2, xmm0
  00075	f3 0f 5c 40 f8	 subss	 xmm0, DWORD PTR [eax-8]
  0007a	f3 0f 5c 55 08	 subss	 xmm2, DWORD PTR _fElapsedTime$[ebp]
  0007f	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00083	f3 0f 10 40 fc	 movss	 xmm0, DWORD PTR [eax-4]
  00088	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0008d	8b 45 10	 mov	 eax, DWORD PTR _pReturnValue$[ebp]
  00090	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00094	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  00099	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2

; 264  : 	}
; 265  : 
; 266  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$GetTimeEventBlendValue@M@@YAXMAAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@PAM@Z ENDP ; GetTimeEventBlendValue<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00004	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 18   : 		{

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A, OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00013	85 c0		 test	 eax, eax
  00015	74 45		 je	 SHORT $LN7@ms_kPool

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00017	ff 35 14 00 00
	00		 push	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+20
  0001d	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00028	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00030	ff 35 10 00 00
	00		 push	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16, 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+20, 0

; 1631 : 			this->_Myend = pointer();

  00052	c7 05 18 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+24, 0
$LN7@ms_kPool:

; 1623 : 		if (this->_Myfirst != pointer())

  0005c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4
  00061	85 c0		 test	 eax, eax
  00063	74 45		 je	 SHORT $LN20@ms_kPool

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00065	ff 35 08 00 00
	00		 push	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8
  0006b	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy

; 642  : 		return (_Alty());

  00076	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0007e	ff 35 04 00 00
	00		 push	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4
  00084	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00089	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0008c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4, 0

; 1630 : 			this->_Mylast = pointer();

  00096	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8, 0

; 1631 : 			this->_Myend = pointer();

  000a0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+12, 0
$LN20@ms_kPool:
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMeshInstance::ms_kPool'', COMDAT

; 7    : CDynamicPool<CEffectMeshInstance>		CEffectMeshInstance::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMeshInstance::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMeshInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\vs\vc\include\math.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h
;	COMDAT ?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_v$1$ = -12						; size = 4
_v$2$ = -8						; size = 4
_v$3$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_vFrom$ = 12						; size = 4
_vTo$ = 16						; size = 4
?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z PROC ; SafeRotationNormalizedArc, COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 290  :     return x == v.x && y == v.y && z == v.z;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _vFrom$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 48   : {

  00009	83 ec 10	 sub	 esp, 16			; 00000010H
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 290  :     return x == v.x && y == v.y && z == v.z;

  0000c	8b 55 10	 mov	 edx, DWORD PTR _vTo$[ebp]
  0000f	f3 0f 10 29	 movss	 xmm5, DWORD PTR [ecx]
  00013	f3 0f 10 22	 movss	 xmm4, DWORD PTR [edx]
  00017	0f 2e ec	 ucomiss xmm5, xmm4
  0001a	9f		 lahf
  0001b	f6 c4 44	 test	 ah, 68			; 00000044H
  0001e	7a 40		 jp	 SHORT $LN2@SafeRotati
  00020	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00025	0f 2e 42 04	 ucomiss xmm0, DWORD PTR [edx+4]
  00029	9f		 lahf
  0002a	f6 c4 44	 test	 ah, 68			; 00000044H
  0002d	7a 31		 jp	 SHORT $LN2@SafeRotati
  0002f	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00034	0f 2e 42 08	 ucomiss xmm0, DWORD PTR [edx+8]
  00038	9f		 lahf
  00039	f6 c4 44	 test	 ah, 68			; 00000044H
  0003c	7a 22		 jp	 SHORT $LN2@SafeRotati

; 667  :     x = fx;

  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00041	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 668  :     y = fy;

  00047	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 669  :     z = fz;

  0004e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 670  :     w = fw;

  00055	c7 40 0c 00 00
	80 3f		 mov	 DWORD PTR [eax+12], 1065353216 ; 3f800000H
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 59   : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN2@SafeRotati:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  00060	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00068	0f 28 cc	 movaps	 xmm1, xmm4
  0006b	f3 0f 10 72 04	 movss	 xmm6, DWORD PTR [edx+4]
  00070	0f 57 c8	 xorps	 xmm1, xmm0
  00073	f3 0f 10 7a 08	 movss	 xmm7, DWORD PTR [edx+8]
  00078	0f 28 d6	 movaps	 xmm2, xmm6

; 290  :     return x == v.x && y == v.y && z == v.z;

  0007b	0f 2e e9	 ucomiss xmm5, xmm1

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  0007e	0f 28 df	 movaps	 xmm3, xmm7
  00081	0f 57 d0	 xorps	 xmm2, xmm0
  00084	0f 57 d8	 xorps	 xmm3, xmm0

; 290  :     return x == v.x && y == v.y && z == v.z;

  00087	9f		 lahf
  00088	f6 c4 44	 test	 ah, 68			; 00000044H
  0008b	7a 3e		 jp	 SHORT $LN1@SafeRotati
  0008d	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00092	0f 2e c2	 ucomiss xmm0, xmm2
  00095	9f		 lahf
  00096	f6 c4 44	 test	 ah, 68			; 00000044H
  00099	7a 30		 jp	 SHORT $LN1@SafeRotati
  0009b	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  000a0	0f 2e c3	 ucomiss xmm0, xmm3
  000a3	9f		 lahf
  000a4	f6 c4 44	 test	 ah, 68			; 00000044H
  000a7	7a 22		 jp	 SHORT $LN1@SafeRotati

; 667  :     x = fx;

  000a9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ac	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 668  :     y = fy;

  000b2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 669  :     z = fz;

  000b9	c7 40 08 00 00
	80 3f		 mov	 DWORD PTR [eax+8], 1065353216 ; 3f800000H

; 670  :     w = fw;

  000c0	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 59   : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN1@SafeRotati:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  000cb	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  000d0	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [ecx+8]
  000d5	0f 28 d3	 movaps	 xmm2, xmm3
  000d8	f3 0f 59 d7	 mulss	 xmm2, xmm7
  000dc	0f 28 c1	 movaps	 xmm0, xmm1
  000df	f3 0f 59 c6	 mulss	 xmm0, xmm6
  000e3	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000e7	0f 28 c7	 movaps	 xmm0, xmm7
  000ea	f3 0f 59 c5	 mulss	 xmm0, xmm5
  000ee	f3 0f 11 54 24
	04		 movss	 DWORD PTR _v$1$[esp+16], xmm2
  000f4	0f 28 d1	 movaps	 xmm2, xmm1
  000f7	f3 0f 59 d4	 mulss	 xmm2, xmm4

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000fb	f3 0f 59 cf	 mulss	 xmm1, xmm7

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000ff	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00103	0f 28 c3	 movaps	 xmm0, xmm3
  00106	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0010a	f3 0f 59 de	 mulss	 xmm3, xmm6
  0010e	f3 0f 59 e5	 mulss	 xmm4, xmm5

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00112	f3 0f 11 54 24
	08		 movss	 DWORD PTR _v$2$[esp+16], xmm2

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00118	0f 28 d6	 movaps	 xmm2, xmm6
  0011b	f3 0f 59 d5	 mulss	 xmm2, xmm5

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0011f	f3 0f 58 dc	 addss	 xmm3, xmm4

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00123	f3 0f 5c d0	 subss	 xmm2, xmm0

; 671  : }
; 672  : 
; 673  : 
; 674  : // casting
; 675  : D3DXINLINE
; 676  : D3DXQUATERNION::operator FLOAT* ()
; 677  : {
; 678  :     return (FLOAT *) &x;
; 679  : }
; 680  : 
; 681  : D3DXINLINE
; 682  : D3DXQUATERNION::operator CONST FLOAT* () const
; 683  : {
; 684  :     return (CONST FLOAT *) &x;
; 685  : }
; 686  : 
; 687  : 
; 688  : // assignment operators
; 689  : D3DXINLINE D3DXQUATERNION&
; 690  : D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
; 691  : {
; 692  :     x += q.x;
; 693  :     y += q.y;
; 694  :     z += q.z;
; 695  :     w += q.w;
; 696  :     return *this;
; 697  : }
; 698  : 
; 699  : D3DXINLINE D3DXQUATERNION&
; 700  : D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
; 701  : {
; 702  :     x -= q.x;
; 703  :     y -= q.y;
; 704  :     z -= q.z;
; 705  :     w -= q.w;
; 706  :     return *this;
; 707  : }
; 708  : 
; 709  : D3DXINLINE D3DXQUATERNION&
; 710  : D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
; 711  : {
; 712  :     D3DXQuaternionMultiply(this, this, &q);
; 713  :     return *this;
; 714  : }
; 715  : 
; 716  : D3DXINLINE D3DXQUATERNION&
; 717  : D3DXQUATERNION::operator *= ( FLOAT f )
; 718  : {
; 719  :     x *= f;
; 720  :     y *= f;
; 721  :     z *= f;
; 722  :     w *= f;
; 723  :     return *this;
; 724  : }
; 725  : 
; 726  : D3DXINLINE D3DXQUATERNION&
; 727  : D3DXQUATERNION::operator /= ( FLOAT f )
; 728  : {
; 729  :     FLOAT fInv = 1.0f / f;
; 730  :     x *= fInv;
; 731  :     y *= fInv;
; 732  :     z *= fInv;
; 733  :     w *= fInv;
; 734  :     return *this;
; 735  : }
; 736  : 
; 737  : 
; 738  : // unary operators
; 739  : D3DXINLINE D3DXQUATERNION
; 740  : D3DXQUATERNION::operator + () const
; 741  : {
; 742  :     return *this;
; 743  : }
; 744  : 
; 745  : D3DXINLINE D3DXQUATERNION
; 746  : D3DXQUATERNION::operator - () const
; 747  : {
; 748  :     return D3DXQUATERNION(-x, -y, -z, -w);
; 749  : }
; 750  : 
; 751  : 
; 752  : // binary operators
; 753  : D3DXINLINE D3DXQUATERNION
; 754  : D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
; 755  : {
; 756  :     return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
; 757  : }
; 758  : 
; 759  : D3DXINLINE D3DXQUATERNION
; 760  : D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
; 761  : {
; 762  :     return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
; 763  : }
; 764  : 
; 765  : D3DXINLINE D3DXQUATERNION
; 766  : D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
; 767  : {
; 768  :     D3DXQUATERNION qT;
; 769  :     D3DXQuaternionMultiply(&qT, this, &q);
; 770  :     return qT;
; 771  : }
; 772  : 
; 773  : D3DXINLINE D3DXQUATERNION
; 774  : D3DXQUATERNION::operator * ( FLOAT f ) const
; 775  : {
; 776  :     return D3DXQUATERNION(x * f, y * f, z * f, w * f);
; 777  : }
; 778  : 
; 779  : D3DXINLINE D3DXQUATERNION
; 780  : D3DXQUATERNION::operator / ( FLOAT f ) const
; 781  : {
; 782  :     FLOAT fInv = 1.0f / f;
; 783  :     return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
; 784  : }
; 785  : 
; 786  : 
; 787  : D3DXINLINE D3DXQUATERNION
; 788  : operator * (FLOAT f, CONST D3DXQUATERNION& q )
; 789  : {
; 790  :     return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
; 791  : }
; 792  : 
; 793  : 
; 794  : D3DXINLINE BOOL
; 795  : D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
; 796  : {
; 797  :     return x == q.x && y == q.y && z == q.z && w == q.w;
; 798  : }
; 799  : 
; 800  : D3DXINLINE BOOL
; 801  : D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
; 802  : {
; 803  :     return x != q.x || y != q.y || z != q.z || w != q.w;
; 804  : }
; 805  : 
; 806  : 
; 807  : 
; 808  : //--------------------------
; 809  : // Plane
; 810  : //--------------------------
; 811  : 
; 812  : D3DXINLINE
; 813  : D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
; 814  : {
; 815  : #ifdef D3DX_DEBUG
; 816  :     if(!pf)
; 817  :         return;
; 818  : #endif
; 819  : 
; 820  :     a = pf[0];
; 821  :     b = pf[1];
; 822  :     c = pf[2];
; 823  :     d = pf[3];
; 824  : }
; 825  : 
; 826  : D3DXINLINE
; 827  : D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
; 828  : {
; 829  :     a = fa;
; 830  :     b = fb;
; 831  :     c = fc;
; 832  :     d = fd;
; 833  : }
; 834  : 
; 835  : 
; 836  : // casting
; 837  : D3DXINLINE
; 838  : D3DXPLANE::operator FLOAT* ()
; 839  : {
; 840  :     return (FLOAT *) &a;
; 841  : }
; 842  : 
; 843  : D3DXINLINE
; 844  : D3DXPLANE::operator CONST FLOAT* () const
; 845  : {
; 846  :     return (CONST FLOAT *) &a;
; 847  : }
; 848  : 
; 849  : 
; 850  : // unary operators
; 851  : D3DXINLINE D3DXPLANE
; 852  : D3DXPLANE::operator + () const
; 853  : {
; 854  :     return *this;
; 855  : }
; 856  : 
; 857  : D3DXINLINE D3DXPLANE
; 858  : D3DXPLANE::operator - () const
; 859  : {
; 860  :     return D3DXPLANE(-a, -b, -c, -d);
; 861  : }
; 862  : 
; 863  : 
; 864  : // binary operators
; 865  : D3DXINLINE BOOL
; 866  : D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
; 867  : {
; 868  :     return a == p.a && b == p.b && c == p.c && d == p.d;
; 869  : }
; 870  : 
; 871  : D3DXINLINE BOOL
; 872  : D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
; 873  : {
; 874  :     return a != p.a || b != p.b || c != p.c || d != p.d;
; 875  : }
; 876  : 
; 877  : 
; 878  : 
; 879  : 
; 880  : //--------------------------
; 881  : // Color
; 882  : //--------------------------
; 883  : 
; 884  : D3DXINLINE
; 885  : D3DXCOLOR::D3DXCOLOR( DWORD dw )
; 886  : {
; 887  :     CONST FLOAT f = 1.0f / 255.0f;
; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);
; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);
; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);
; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);
; 892  : }
; 893  : 
; 894  : D3DXINLINE
; 895  : D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
; 896  : {
; 897  : #ifdef D3DX_DEBUG
; 898  :     if(!pf)
; 899  :         return;
; 900  : #endif
; 901  : 
; 902  :     r = pf[0];
; 903  :     g = pf[1];
; 904  :     b = pf[2];
; 905  :     a = pf[3];
; 906  : }
; 907  : 
; 908  : D3DXINLINE
; 909  : D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
; 910  : {
; 911  :     r = c.r;
; 912  :     g = c.g;
; 913  :     b = c.b;
; 914  :     a = c.a;
; 915  : }
; 916  : 
; 917  : D3DXINLINE
; 918  : D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
; 919  : {
; 920  :     r = fr;
; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }
; 925  : 
; 926  : 
; 927  : // casting
; 928  : D3DXINLINE
; 929  : D3DXCOLOR::operator DWORD () const
; 930  : {
; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
; 1254 : }
; 1255 : 
; 1256 : D3DXINLINE FLOAT D3DXVec3Dot
; 1257 :     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
; 1258 : {
; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00127	f3 0f 58 d9	 addss	 xmm3, xmm1

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0012b	f3 0f 11 54 24
	0c		 movss	 DWORD PTR _v$3$[esp+16], xmm2
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 56   : 	float s = sqrtf((1+d)*2);

  00131	f3 0f 58 1d 00
	00 00 00	 addss	 xmm3, DWORD PTR __real@3f800000
  00139	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40000000
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  00141	0f 5a c3	 cvtps2pd xmm0, xmm3
  00144	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  00149	f3 0f 10 4c 24
	04		 movss	 xmm1, DWORD PTR _v$1$[esp+16]
; File a:\vs\vc\include\math.h

; 775  :     return (float)sqrt(_X);

  0014f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 667  :     x = fx;

  00153	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  00156	f3 0f 5e c8	 divss	 xmm1, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 667  :     x = fx;

  0015a	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  0015e	f3 0f 10 4c 24
	08		 movss	 xmm1, DWORD PTR _v$2$[esp+16]
  00164	f3 0f 5e c8	 divss	 xmm1, xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 668  :     y = fy;

  00168	f3 0f 11 48 04	 movss	 DWORD PTR [eax+4], xmm1
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 58   : 	return D3DXQUATERNION(c.x/s,c.y/s,c.z/s,s*0.5f);

  0016d	f3 0f 10 4c 24
	0c		 movss	 xmm1, DWORD PTR _v$3$[esp+16]
  00173	f3 0f 5e c8	 divss	 xmm1, xmm0
  00177	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 669  :     z = fz;

  0017f	f3 0f 11 48 08	 movss	 DWORD PTR [eax+8], xmm1

; 670  :     w = fw;

  00184	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\grpmath.h

; 59   : }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ENDP ; SafeRotationNormalizedArc
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectMeshInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectMeshInstance@@UAEPAXI@Z PROC			; CEffectMeshInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectMeshInstance@@UAE@XZ ; CEffectMeshInstance::~CEffectMeshInstance
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCEffectMeshInstance@@UAEPAXI@Z ENDP			; CEffectMeshInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
;	COMDAT ?GetPointer@?$CRef@VCEffectMesh@@@@QBEPAVCEffectMesh@@XZ
_TEXT	SEGMENT
?GetPointer@?$CRef@VCEffectMesh@@@@QBEPAVCEffectMesh@@XZ PROC ; CRef<CEffectMesh>::GetPointer, COMDAT
; _this$ = ecx

; 80   : 			return static_cast<T*>(m_pObject);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 81   : 		}

  00002	c3		 ret	 0
?GetPointer@?$CRef@VCEffectMesh@@@@QBEPAVCEffectMesh@@XZ ENDP ; CRef<CEffectMesh>::GetPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
;	COMDAT ?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CEffectMesh>::SetPointer, COMDAT
; _this$ = ecx

; 66   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 			CReferenceObject* pOldObject = m_pObject;
; 68   : 
; 69   : 			m_pObject = pObject;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pObject$[ebp]
  00006	56		 push	 esi
  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 70   : 
; 71   : 			if (m_pObject)

  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@SetPointer

; 72   : 				m_pObject->AddReference();

  0000f	8b c8		 mov	 ecx, eax
  00011	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN2@SetPointer:

; 73   : 
; 74   : 			if (pOldObject)

  00016	85 f6		 test	 esi, esi
  00018	74 07		 je	 SHORT $LN1@SetPointer

; 75   : 				pOldObject->Release();

  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN1@SetPointer:
  00021	5e		 pop	 esi

; 76   : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetPointer@?$CRef@VCEffectMesh@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CEffectMesh>::SetPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
;	COMDAT ?Clear@?$CRef@VCEffectMesh@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$CRef@VCEffectMesh@@@@QAEXXZ PROC		; CRef<CEffectMesh>::Clear, COMDAT
; _this$ = ecx

; 52   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 53   : 			if (m_pObject)

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 0b		 je	 SHORT $LN1@Clear

; 54   : 			{
; 55   : 				m_pObject->Release();

  00009	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Clear:
  00014	5e		 pop	 esi

; 57   : 			}
; 58   : 		}

  00015	c3		 ret	 0
?Clear@?$CRef@VCEffectMesh@@@@QAEXXZ ENDP		; CRef<CEffectMesh>::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
;	COMDAT ??1?$CRef@VCEffectMesh@@@@QAE@XZ
_TEXT	SEGMENT
??1?$CRef@VCEffectMesh@@@@QAE@XZ PROC			; CRef<CEffectMesh>::~CRef<CEffectMesh>, COMDAT
; _this$ = ecx

; 37   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 40   : 		
; 41   : 		void operator = (CReferenceObject* pObject)
; 42   : 		{
; 43   : 			SetPointer(pObject);
; 44   : 		}
; 45   : 
; 46   : 		void operator = (const CRef& c_rRef)
; 47   : 		{
; 48   : 			SetPointer(c_rRef.m_pObject);			
; 49   : 		}
; 50   : 
; 51   : 		void Clear()
; 52   : 		{
; 53   : 			if (m_pObject)

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 0b		 je	 SHORT $LN3@CRef

; 54   : 			{
; 55   : 				m_pObject->Release();

  00009	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CRef:
  00014	5e		 pop	 esi

; 38   : 			Clear();
; 39   : 		}

  00015	c3		 ret	 0
??1?$CRef@VCEffectMesh@@@@QAE@XZ ENDP			; CRef<CEffectMesh>::~CRef<CEffectMesh>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
;	COMDAT ??0?$CRef@VCEffectMesh@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CRef@VCEffectMesh@@@@QAE@XZ PROC			; CRef<CEffectMesh>::CRef<CEffectMesh>, COMDAT
; _this$ = ecx

; 21   : 		{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 22   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CRef@VCEffectMesh@@@@QAE@XZ ENDP			; CRef<CEffectMesh>::CRef<CEffectMesh>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$1 = -5						; size = 1
__Alval$2 = -1						; size = 1
?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	85 c0		 test	 eax, eax
  0000d	74 2e		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000f	ff 75 fb	 push	 DWORD PTR __Cat$1[ebp]
  00012	8d 4d ff	 lea	 ecx, DWORD PTR __Alval$2[ebp]
  00015	51		 push	 ecx
  00016	ff 76 04	 push	 DWORD PTR [esi+4]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >

; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);

  0001f	ff 36		 push	 DWORD PTR [esi]
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  00036	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  0003d	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00004	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000c	56		 push	 esi
  0000d	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00010	8b d3		 mov	 edx, ebx
  00012	2b d6		 sub	 edx, esi
  00014	f7 ea		 imul	 edx
  00016	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  00017	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  0001a	c1 fa 03	 sar	 edx, 3
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx

; 1613 : 		if (_Unused_capacity() < _Count)

  00024	3b c7		 cmp	 eax, edi
  00026	73 68		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00028	2b 31		 sub	 esi, DWORD PTR [ecx]
  0002a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0002f	f7 ee		 imul	 esi

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00031	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00036	c1 fa 03	 sar	 edx, 3
  00039	8b f2		 mov	 esi, edx
  0003b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0003e	03 f2		 add	 esi, edx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00040	2b c6		 sub	 eax, esi
  00042	3b c7		 cmp	 eax, edi
  00044	72 51		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00046	2b 19		 sub	 ebx, DWORD PTR [ecx]
  00048	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004d	f7 eb		 imul	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004f	03 f7		 add	 esi, edi

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00051	bf 55 55 55 05	 mov	 edi, 89478485		; 05555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00056	c1 fa 03	 sar	 edx, 3
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005e	03 c2		 add	 eax, edx

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00060	8b d0		 mov	 edx, eax
  00062	d1 ea		 shr	 edx, 1
  00064	2b fa		 sub	 edi, edx
  00066	3b f8		 cmp	 edi, eax
  00068	73 13		 jae	 SHORT $LN27@Reserve
  0006a	33 c0		 xor	 eax, eax

; 1576 : 		if (_Capacity < _Count)

  0006c	3b c6		 cmp	 eax, esi
  0006e	5f		 pop	 edi
  0006f	0f 42 c6	 cmovb	 eax, esi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00074	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  00077	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00078	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007d	03 c2		 add	 eax, edx

; 1576 : 		if (_Capacity < _Count)

  0007f	3b c6		 cmp	 eax, esi
  00081	5f		 pop	 edi
  00082	0f 42 c6	 cmovb	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00087	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1618 : 			}
; 1619 : 		}

  0008a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0008b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reallocate
$LN2@Reserve:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 1618 : 			}
; 1619 : 		}

  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0009c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  000a1	cc		 int	 3
?_Reserve@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -20						; size = 4
__Ptr$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$3 = 8						; size = 1
__Cat$4 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$5 = 11						; size = 1
__Alval$6 = 11						; size = 1
?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00030	33 f6		 xor	 esi, esi
  00032	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00035	85 ff		 test	 edi, edi
  00037	74 25		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00039	81 ff 55 55 55
	05		 cmp	 edi, 89478485		; 05555555H
  0003f	77 18		 ja	 SHORT $LN15@Reallocate
  00041	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00044	c1 e0 04	 shl	 eax, 4
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004d	8b f0		 mov	 esi, eax
  0004f	83 c4 04	 add	 esp, 4
  00052	89 75 ec	 mov	 DWORD PTR __Ptr$2[ebp], esi
  00055	85 f6		 test	 esi, esi
  00057	75 05		 jne	 SHORT $LN16@Reallocate
$LN15@Reallocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN66@Reallocate:
$LN16@Reallocate:
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0005e	ff 75 08	 push	 DWORD PTR __Cat$4[ebp]
  00061	8d 45 0b	 lea	 eax, DWORD PTR __Alval$6[ebp]
; File a:\vs\vc\include\vector

; 1590 : 		_TRY_BEGIN

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0006b	6a 00		 push	 0
  0006d	50		 push	 eax
  0006e	56		 push	 esi
  0006f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00072	ff 33		 push	 DWORD PTR [ebx]
  00074	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUSTextureInstance@CEffectMeshInstance@@PAU12@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAPAUSTextureInstance@CEffectMeshInstance@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CEffectMeshInstance::STextureInstance *,CEffectMeshInstance::STextureInstance *,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00079	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0007c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00081	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00083	83 c4 18	 add	 esp, 24			; 00000018H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00086	f7 e9		 imul	 ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00088	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0008a	c1 fa 03	 sar	 edx, 3
  0008d	8b ca		 mov	 ecx, edx
  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00096	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00099	03 ca		 add	 ecx, edx
  0009b	89 4d ec	 mov	 DWORD PTR __Size$1$[ebp], ecx

; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  0009e	85 c0		 test	 eax, eax
  000a0	74 1d		 je	 SHORT $LN60@Reallocate
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000a2	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
  000a5	8d 4d 0b	 lea	 ecx, DWORD PTR __Alval$5[ebp]
  000a8	51		 push	 ecx
  000a9	ff 73 04	 push	 DWORD PTR [ebx+4]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >

; 573  : 		::operator delete(_Ptr);

  000b2	ff 33		 push	 DWORD PTR [ebx]
  000b4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b9	8b 4d ec	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  000bc	83 c4 14	 add	 esp, 20			; 00000014H
$LN60@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  000bf	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  000c2	89 33		 mov	 DWORD PTR [ebx], esi
  000c4	c1 e0 04	 shl	 eax, 4
  000c7	03 c6		 add	 eax, esi
  000c9	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000cc	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000cf	c1 e0 04	 shl	 eax, 4
  000d2	03 c6		 add	 eax, esi
  000d4	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1609 : 		}

  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z$0:
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  000eb	ff 75 ec	 push	 DWORD PTR __Ptr$2[ebp]
  000ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000f3	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1594 : 		_RERAISE;

  000f6	6a 00		 push	 0
  000f8	6a 00		 push	 0
  000fa	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Reallocate:
$LN65@Reallocate:
  000ff	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reallocate
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx
  0000f	56		 push	 esi
  00010	c1 fa 03	 sar	 edx, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00013	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00018	8b f2		 mov	 esi, edx
  0001a	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001d	03 f2		 add	 esi, edx

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0001f	8b ce		 mov	 ecx, esi
  00021	d1 e9		 shr	 ecx, 1
  00023	2b c1		 sub	 eax, ecx
  00025	3b c6		 cmp	 eax, esi
  00027	73 10		 jae	 SHORT $LN4@Grow_to
  00029	33 f6		 xor	 esi, esi

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0002e	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1579 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00039	03 f1		 add	 esi, ecx

; 1576 : 		if (_Capacity < _Count)

  0003b	3b 75 08	 cmp	 esi, DWORD PTR __Count$[ebp]
  0003e	0f 42 75 08	 cmovb	 esi, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi

; 1579 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?_Grow_to@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z
_TEXT	SEGMENT
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Cat$1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	ff 75 0c	 push	 DWORD PTR __Cat$1[ebp]
  00007	8d 45 ff	 lea	 eax, DWORD PTR __Alval$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
  00016	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1568 : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?_Destroy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXPAUSTextureInstance@CEffectMeshInstance@@0@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Cat$1 = -5						; size = 1
__Alval$2 = -1						; size = 1
?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear, COMDAT
; _this$ = ecx

; 1507 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00007	ff 75 fb	 push	 DWORD PTR __Cat$1[ebp]
; File a:\vs\vc\include\vector

; 1507 : 		{	// erase all

  0000a	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000c	8d 45 ff	 lea	 eax, DWORD PTR __Alval$2[ebp]
  0000f	50		 push	 eax
  00010	ff 76 04	 push	 DWORD PTR [esi+4]
  00013	ff 36		 push	 DWORD PTR [esi]
  00015	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0001c	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0001f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00022	5e		 pop	 esi

; 1511 : 		}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?clear@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Cat$1 = 8						; size = 1
__Count$ = 8						; size = 4
__Alval$2 = 11						; size = 1
?_Pop_back_n@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase _Count elements at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00008	ff 75 08	 push	 DWORD PTR __Cat$1[ebp]
; File a:\vs\vc\include\vector

; 1495 : 		{	// erase _Count elements at end

  0000b	8b f9		 mov	 edi, ecx

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	c1 e0 04	 shl	 eax, 4
  00013	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00016	8b f2		 mov	 esi, edx
  00018	2b f0		 sub	 esi, eax
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0001a	8d 45 0b	 lea	 eax, DWORD PTR __Alval$2[ebp]
  0001d	50		 push	 eax
  0001e	52		 push	 edx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
  00025	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1503 : 		this->_Mylast = _Ptr;

  00028	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 1504 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Pop_back_n@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEAAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEAAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00009	c1 e0 04	 shl	 eax, 4
  0000c	03 01		 add	 eax, DWORD PTR [ecx]

; 1210 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEAAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1149 : 		}

  00016	c3		 ret	 0
?size@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$2 = 8						; size = 1
__Cat$3 = 8						; size = 1
__Newsize$ = 8						; size = 4
__Alval$4 = 11						; size = 1
__Alval$5 = 11						; size = 1
?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::resize, COMDAT
; _this$ = ecx

; 1100 : 		{	// determine new length, padding as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d ec	 mov	 DWORD PTR _this$[ebp], ebx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00030	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00033	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00038	2b 13		 sub	 edx, DWORD PTR [ebx]

; 1101 : 		if (_Newsize < size())

  0003a	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003d	f7 ea		 imul	 edx
  0003f	c1 fa 03	 sar	 edx, 3
  00042	8b ca		 mov	 ecx, edx
  00044	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00047	03 ca		 add	 ecx, edx

; 1101 : 		if (_Newsize < size())

  00049	3b cf		 cmp	 ecx, edi
  0004b	76 35		 jbe	 SHORT $LN39@resize
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0004d	ff 75 08	 push	 DWORD PTR __Cat$3[ebp]
; File a:\vs\vc\include\vector

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  00050	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00053	2b f9		 sub	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00055	8d 4d 0b	 lea	 ecx, DWORD PTR __Alval$4[ebp]
  00058	51		 push	 ecx
  00059	50		 push	 eax
; File a:\vs\vc\include\vector

; 1496 : 		pointer _Ptr = this->_Mylast - _Count;

  0005a	8d 34 7f	 lea	 esi, DWORD PTR [edi+edi*2]
  0005d	c1 e6 04	 shl	 esi, 4
  00060	03 f0		 add	 esi, eax
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
  00068	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1503 : 		this->_Mylast = _Ptr;

  0006b	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN2@resize:

; 1115 : 			}
; 1116 : 		}

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
$LN39@resize:

; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)

  00082	73 ea		 jae	 SHORT $LN2@resize

; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());

  00084	8b c7		 mov	 eax, edi
  00086	2b c1		 sub	 eax, ecx
  00088	8b cb		 mov	 ecx, ebx
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Reserve

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00090	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00093	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File a:\vs\vc\include\xmemory

; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00098	ff 75 08	 push	 DWORD PTR __Cat$2[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0009b	8b ce		 mov	 ecx, esi

; 1107 : 			_TRY_BEGIN

  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000a4	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  000a6	f7 e9		 imul	 ecx

; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  000a8	8b cf		 mov	 ecx, edi

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000aa	c1 fa 03	 sar	 edx, 3
  000ad	8b c2		 mov	 eax, edx
  000af	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b2	03 c2		 add	 eax, edx

; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);

  000b4	2b c8		 sub	 ecx, eax
; File a:\vs\vc\include\xmemory

; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  000b6	8d 45 0b	 lea	 eax, DWORD PTR __Alval$5[ebp]
  000b9	6a 00		 push	 0
  000bb	50		 push	 eax
  000bc	51		 push	 ecx
  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 ??$_Uninit_def_fill_n@PAUSTextureInstance@CEffectMeshInstance@@IV?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@U12@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@IAAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<CEffectMeshInstance::STextureInstance *,unsigned int,std::allocator<CEffectMeshInstance::STextureInstance>,CEffectMeshInstance::STextureInstance>
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000c3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000c6	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000cb	2b 0b		 sub	 ecx, DWORD PTR [ebx]
; File a:\vs\vc\include\xmemory

; 692  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  000cd	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000d0	f7 e9		 imul	 ecx
  000d2	c1 fa 03	 sar	 edx, 3
  000d5	8b c2		 mov	 eax, edx
  000d7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000da	03 c2		 add	 eax, edx

; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();

  000dc	2b f8		 sub	 edi, eax
  000de	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  000e1	c1 e0 04	 shl	 eax, 4
  000e4	01 43 04	 add	 DWORD PTR [ebx+4], eax

; 1115 : 			}
; 1116 : 		}

  000e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f1	59		 pop	 ecx
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 04 00	 ret	 4
__catch$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z$0:

; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();

  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@IAEXXZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Tidy

; 1112 : 			_RERAISE;

  00103	6a 00		 push	 0
  00105	6a 00		 push	 0
  00107	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN40@resize:
$LN38@resize:
  0010c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::resize
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 03	 sar	 edx, 3
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1016 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 03	 sar	 edx, 3
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1011 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$1 = -5						; size = 1
__Alval$2 = -1						; size = 1
??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	85 c0		 test	 eax, eax
  0000d	74 2e		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000f	ff 75 fb	 push	 DWORD PTR __Cat$1[ebp]
  00012	8d 4d ff	 lea	 ecx, DWORD PTR __Alval$2[ebp]
  00015	51		 push	 ecx
  00016	ff 76 04	 push	 DWORD PTR [esi+4]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >

; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);

  0001f	ff 36		 push	 DWORD PTR [esi]
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  00036	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  0003d	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@USTextureInstance@CEffectMeshInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >::_Vector_val<std::_Simple_types<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct, COMDAT
; _this$ = ecx

; 862  : 		{	// default construct object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 588  : 		::new ((void *)_Ptr) _Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	85 f6		 test	 esi, esi
  00033	74 1c		 je	 SHORT $LN7@construct
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0003c	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 483  : 		_Mylast = pointer();

  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 484  : 		_Myend = pointer();

  0004a	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN7@construct:
; File a:\vs\vc\include\xmemory0

; 864  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::construct
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 05	 cmp	 eax, 89478485		; 05555555H
  00011	77 1b		 ja	 SHORT $LN14@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 04	 shl	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00028	8b c1		 mov	 eax, ecx

; 848  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00033	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@USTextureInstance@CEffectMeshInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance::STextureInstance> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QBEIXZ PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 05	 mov	 eax, 89478485		; 05555555H

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QBEIXZ ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::construct, COMDAT
; _this$ = ecx

; 587  : 		{	// default construct object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 588  : 		::new ((void *)_Ptr) _Ty();

  00024	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00027	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	85 f6		 test	 esi, esi
  00033	74 1c		 je	 SHORT $LN3@construct
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  0003c	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 483  : 		_Mylast = pointer();

  00043	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 484  : 		_Myend = pointer();

  0004a	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN3@construct:
; File a:\vs\vc\include\xmemory0

; 589  : 		}

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::construct
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 1c		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d 55 55 55 05	 cmp	 eax, 89478485		; 05555555H
  00011	77 1b		 ja	 SHORT $LN11@allocate
  00013	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00016	c1 e0 04	 shl	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	8b c8		 mov	 ecx, eax
  00021	83 c4 04	 add	 esp, 4
  00024	85 c9		 test	 ecx, ecx
  00026	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00028	8b c1		 mov	 eax, ecx

; 579  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00033	cc		 int	 3
?allocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEPAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAEXPAUSTextureInstance@CEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAE@XZ PROC ; std::allocator<CEffectMeshInstance::STextureInstance>::allocator<CEffectMeshInstance::STextureInstance>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@QAE@XZ ENDP ; std::allocator<CEffectMeshInstance::STextureInstance>::allocator<CEffectMeshInstance::STextureInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?isActive@CEffectMeshInstance@@IAEHXZ
_TEXT	SEGMENT
?isActive@CEffectMeshInstance@@IAEHXZ PROC		; CEffectMeshInstance::isActive, COMDAT
; _this$ = ecx

; 26   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 27   : 	if (!CEffectElementBaseInstance::isActive())

  00003	e8 00 00 00 00	 call	 ?isActive@CEffectElementBaseInstance@@QAE_NXZ ; CEffectElementBaseInstance::isActive
  00008	84 c0		 test	 al, al
  0000a	75 04		 jne	 SHORT $LN6@isActive
$LN20@isActive:

; 28   : 		return FALSE;

  0000c	33 c0		 xor	 eax, eax
  0000e	5e		 pop	 esi

; 41   : }

  0000f	c3		 ret	 0
$LN6@isActive:

; 29   : 
; 30   : 	if (!m_MeshFrameController.isActive())

  00010	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  0001a	85 c0		 test	 eax, eax
  0001c	74 ee		 je	 SHORT $LN20@isActive
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001e	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00021	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00026	2b 4e 50	 sub	 ecx, DWORD PTR [esi+80]
  00029	f7 e9		 imul	 ecx
  0002b	53		 push	 ebx
  0002c	c1 fa 03	 sar	 edx, 3
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  0002f	33 db		 xor	 ebx, ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00031	8b c2		 mov	 eax, edx
  00033	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00036	57		 push	 edi
  00037	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00039	74 3e		 je	 SHORT $LN2@isActive
  0003b	33 ff		 xor	 edi, edi
  0003d	8d 49 00	 npad	 3
$LL4@isActive:

; 35   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  00040	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00043	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00048	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 35   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  0004b	0f b6 c0	 movzx	 eax, al
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0004e	03 cf		 add	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 36   : 		if (m_TextureInstanceVector[j].TextureFrameController.isActive(iCurrentFrame))

  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  00056	85 c0		 test	 eax, eax
  00058	75 25		 jne	 SHORT $LN14@isActive
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0005a	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0005d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00062	2b 4e 50	 sub	 ecx, DWORD PTR [esi+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00065	43		 inc	 ebx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00066	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00068	83 c7 30	 add	 edi, 48			; 00000030H
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0006b	c1 fa 03	 sar	 edx, 3
  0006e	8b c2		 mov	 eax, edx
  00070	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00073	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 33   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00075	3b d8		 cmp	 ebx, eax
  00077	72 c7		 jb	 SHORT $LL4@isActive
$LN2@isActive:
  00079	5f		 pop	 edi
  0007a	5b		 pop	 ebx

; 38   : 	}
; 39   : 
; 40   : 	return FALSE;

  0007b	33 c0		 xor	 eax, eax
  0007d	5e		 pop	 esi

; 41   : }

  0007e	c3		 ret	 0
$LN14@isActive:
  0007f	5f		 pop	 edi
  00080	5b		 pop	 ebx

; 37   : 			return TRUE;

  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	5e		 pop	 esi

; 41   : }

  00087	c3		 ret	 0
?isActive@CEffectMeshInstance@@IAEHXZ ENDP		; CEffectMeshInstance::isActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?OnRender@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
_q$1 = -316						; size = 16
$T2 = -300						; size = 12
_Color$3 = -288						; size = 16
_rFrameData$1$ = -272					; size = 4
_TableAlpha$4 = -268					; size = 4
_result$5 = -264					; size = 8
_pEffectMesh$1$ = -256					; size = 4
_i$1$ = -252						; size = 4
_Color$1$ = -248					; size = 4
_rTextureFrameController$1$ = -248			; size = 4
tv1679 = -244						; size = 4
_byType$6 = -237					; size = 1
_fAlpha$1$ = -236					; size = 4
_dwR$1$ = -236						; size = 4
_fElapsedTime$ = -236					; size = 4
$T7 = -232						; size = 64
$T8 = -232						; size = 64
_LastPosition$9 = -168					; size = 12
_Position$10 = -156					; size = 12
_matTemp$11 = -144					; size = 64
_matTemp$12 = -144					; size = 64
_m_matWorld$13 = -80					; size = 64
_Position$14 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?OnRender@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnRender, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx

; 63   : 	if (!isActive())

  00016	e8 00 00 00 00	 call	 ?isActive@CEffectMeshInstance@@IAEHXZ ; CEffectMeshInstance::isActive
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 5e 07 00
	00		 je	 $LN13@OnRender
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00023	8b 43 5c	 mov	 eax, DWORD PTR [ebx+92]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 68   : 	for (DWORD i = 0; i < pEffectMesh->GetMeshCount(); ++i)

  00026	8b c8		 mov	 ecx, eax
  00028	56		 push	 esi
  00029	33 f6		 xor	 esi, esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  0002b	89 85 00 ff ff
	ff		 mov	 DWORD PTR _pEffectMesh$1$[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 68   : 	for (DWORD i = 0; i < pEffectMesh->GetMeshCount(); ++i)

  00031	89 b5 04 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00037	e8 00 00 00 00	 call	 ?GetMeshCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetMeshCount
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 3c 07 00
	00		 je	 $LN331@OnRender
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00044	33 c0		 xor	 eax, eax
  00046	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  00049	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv1679[ebp], eax
  0004f	57		 push	 edi
$LL15@OnRender:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 72   : 		CFrameController & rTextureFrameController = m_TextureInstanceVector[i].TextureFrameController;

  00050	8b 7b 50	 mov	 edi, DWORD PTR [ebx+80]
  00053	03 f8		 add	 edi, eax
  00055	89 bd 08 ff ff
	ff		 mov	 DWORD PTR _rTextureFrameController$1$[ebp], edi

; 73   : 		if (!rTextureFrameController.isActive(m_MeshFrameController.GetCurrentFrame()))

  0005b	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
  00060	0f b6 c0	 movzx	 eax, al
  00063	8b cf		 mov	 ecx, edi
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 e2 06 00
	00		 je	 $LN14@OnRender

; 74   : 			continue;
; 75   : 
; 76   : 		int iBillboardType = m_pMeshScript->GetBillboardType(i);

  00073	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?GetBillboardType@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::GetBillboardType
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  0007c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+56], 0
  00083	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+52], 0
  0008a	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+48], 0
  00091	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+44], 0
  00098	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+36], 0
  0009f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+32], 0
  000a6	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+28], 0
  000ad	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+24], 0
  000b4	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+16], 0
  000bb	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+12], 0
  000c2	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+8], 0
  000c9	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _m_matWorld$13[ebp+4], 0

; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  000d0	c7 45 ec 00 00
	80 3f		 mov	 DWORD PTR _m_matWorld$13[ebp+60], 1065353216 ; 3f800000H
  000d7	c7 45 d8 00 00
	80 3f		 mov	 DWORD PTR _m_matWorld$13[ebp+40], 1065353216 ; 3f800000H
  000de	c7 45 c4 00 00
	80 3f		 mov	 DWORD PTR _m_matWorld$13[ebp+20], 1065353216 ; 3f800000H
  000e5	c7 45 b0 00 00
	80 3f		 mov	 DWORD PTR _m_matWorld$13[ebp], 1065353216 ; 3f800000H
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 81   : 		switch(iBillboardType)

  000ec	48		 dec	 eax
  000ed	0f 84 b4 01 00
	00		 je	 $LN9@OnRender
  000f3	48		 dec	 eax
  000f4	0f 84 ed 00 00
	00		 je	 $LN8@OnRender
  000fa	48		 dec	 eax
  000fb	0f 85 16 02 00
	00		 jne	 $LN10@OnRender

; 105  : 
; 106  : 			case MESH_BILLBOARD_TYPE_MOVE:
; 107  : 				{
; 108  : 					D3DXVECTOR3 Position;
; 109  : 					m_pMeshScript->GetPosition(m_fLocalTime, Position);

  00101	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR [ebx+12]
  00106	8d 45 f0	 lea	 eax, DWORD PTR _Position$14[ebp]
  00109	50		 push	 eax
  0010a	51		 push	 ecx
  0010b	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0010e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00113	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition

; 110  : 					D3DXVECTOR3 LastPosition;
; 111  : 					m_pMeshScript->GetPosition(m_fLocalTime-CTimer::Instance().GetElapsedSecond(), LastPosition);

  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  0011e	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _LastPosition$9[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?GetElapsedSecond@CTimer@@QAEMXZ ; CTimer::GetElapsedSecond
  0012a	d8 6b 0c	 fsubr	 DWORD PTR [ebx+12]
  0012d	51		 push	 ecx
  0012e	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00131	d9 1c 24	 fstp	 DWORD PTR [esp]
  00134	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 213  :     x -= v.x;

  00139	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _Position$14[ebp]

; 214  :     y -= v.y;

  0013e	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _Position$14[ebp+4]
  00143	f3 0f 5c 95 5c
	ff ff ff	 subss	 xmm2, DWORD PTR _LastPosition$9[ebp+4]
  0014b	f3 0f 5c 8d 58
	ff ff ff	 subss	 xmm1, DWORD PTR _LastPosition$9[ebp]

; 215  :     z -= v.z;

  00153	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _Position$14[ebp+8]
  00158	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR _LastPosition$9[ebp+8]
  00160	f3 0f 11 55 f4	 movss	 DWORD PTR _Position$14[ebp+4], xmm2
  00165	f3 0f 11 4d f0	 movss	 DWORD PTR _Position$14[ebp], xmm1

; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0016a	f3 0f 59 d2	 mulss	 xmm2, xmm2
  0016e	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 215  :     z -= v.z;

  00172	f3 0f 11 45 f8	 movss	 DWORD PTR _Position$14[ebp+8], xmm0

; 937  : }
; 938  : 
; 939  : 
; 940  : D3DXINLINE
; 941  : D3DXCOLOR::operator FLOAT * ()
; 942  : {
; 943  :     return (FLOAT *) &r;
; 944  : }
; 945  : 
; 946  : D3DXINLINE
; 947  : D3DXCOLOR::operator CONST FLOAT * () const
; 948  : {
; 949  :     return (CONST FLOAT *) &r;
; 950  : }
; 951  : 
; 952  : 
; 953  : D3DXINLINE
; 954  : D3DXCOLOR::operator D3DCOLORVALUE * ()
; 955  : {
; 956  :     return (D3DCOLORVALUE *) &r;
; 957  : }
; 958  : 
; 959  : D3DXINLINE
; 960  : D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
; 961  : {
; 962  :     return (CONST D3DCOLORVALUE *) &r;
; 963  : }
; 964  : 
; 965  : 
; 966  : D3DXINLINE
; 967  : D3DXCOLOR::operator D3DCOLORVALUE& ()
; 968  : {
; 969  :     return *((D3DCOLORVALUE *) &r);
; 970  : }
; 971  : 
; 972  : D3DXINLINE
; 973  : D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
; 974  : {
; 975  :     return *((CONST D3DCOLORVALUE *) &r);
; 976  : }
; 977  : 
; 978  : 
; 979  : // assignment operators
; 980  : D3DXINLINE D3DXCOLOR&
; 981  : D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
; 982  : {
; 983  :     r += c.r;
; 984  :     g += c.g;
; 985  :     b += c.b;
; 986  :     a += c.a;
; 987  :     return *this;
; 988  : }
; 989  : 
; 990  : D3DXINLINE D3DXCOLOR&
; 991  : D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
; 992  : {
; 993  :     r -= c.r;
; 994  :     g -= c.g;
; 995  :     b -= c.b;
; 996  :     a -= c.a;
; 997  :     return *this;
; 998  : }
; 999  : 
; 1000 : D3DXINLINE D3DXCOLOR&
; 1001 : D3DXCOLOR::operator *= ( FLOAT f )
; 1002 : {
; 1003 :     r *= f;
; 1004 :     g *= f;
; 1005 :     b *= f;
; 1006 :     a *= f;
; 1007 :     return *this;
; 1008 : }
; 1009 : 
; 1010 : D3DXINLINE D3DXCOLOR&
; 1011 : D3DXCOLOR::operator /= ( FLOAT f )
; 1012 : {
; 1013 :     FLOAT fInv = 1.0f / f;
; 1014 :     r *= fInv;
; 1015 :     g *= fInv;
; 1016 :     b *= fInv;
; 1017 :     a *= fInv;
; 1018 :     return *this;
; 1019 : }
; 1020 : 
; 1021 : 
; 1022 : // unary operators
; 1023 : D3DXINLINE D3DXCOLOR
; 1024 : D3DXCOLOR::operator + () const
; 1025 : {
; 1026 :     return *this;
; 1027 : }
; 1028 : 
; 1029 : D3DXINLINE D3DXCOLOR
; 1030 : D3DXCOLOR::operator - () const
; 1031 : {
; 1032 :     return D3DXCOLOR(-r, -g, -b, -a);
; 1033 : }
; 1034 : 
; 1035 : 
; 1036 : // binary operators
; 1037 : D3DXINLINE D3DXCOLOR
; 1038 : D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
; 1039 : {
; 1040 :     return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
; 1041 : }
; 1042 : 
; 1043 : D3DXINLINE D3DXCOLOR
; 1044 : D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
; 1045 : {
; 1046 :     return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
; 1047 : }
; 1048 : 
; 1049 : D3DXINLINE D3DXCOLOR
; 1050 : D3DXCOLOR::operator * ( FLOAT f ) const
; 1051 : {
; 1052 :     return D3DXCOLOR(r * f, g * f, b * f, a * f);
; 1053 : }
; 1054 : 
; 1055 : D3DXINLINE D3DXCOLOR
; 1056 : D3DXCOLOR::operator / ( FLOAT f ) const
; 1057 : {
; 1058 :     FLOAT fInv = 1.0f / f;
; 1059 :     return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
; 1060 : }
; 1061 : 
; 1062 : 
; 1063 : D3DXINLINE D3DXCOLOR
; 1064 : operator * (FLOAT f, CONST D3DXCOLOR& c )
; 1065 : {
; 1066 :     return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
; 1067 : }
; 1068 : 
; 1069 : 
; 1070 : D3DXINLINE BOOL
; 1071 : D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
; 1072 : {
; 1073 :     return r == c.r && g == c.g && b == c.b && a == c.a;
; 1074 : }
; 1075 : 
; 1076 : D3DXINLINE BOOL
; 1077 : D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
; 1078 : {
; 1079 :     return r != c.r || g != c.g || b != c.b || a != c.a;
; 1080 : }
; 1081 : 
; 1082 : 
; 1083 : #endif //__cplusplus
; 1084 : 
; 1085 : 
; 1086 : 
; 1087 : //===========================================================================
; 1088 : //
; 1089 : // Inline functions
; 1090 : //
; 1091 : //===========================================================================
; 1092 : 
; 1093 : 
; 1094 : //--------------------------
; 1095 : // 2D Vector
; 1096 : //--------------------------
; 1097 : 
; 1098 : D3DXINLINE FLOAT D3DXVec2Length
; 1099 :     ( CONST D3DXVECTOR2 *pV )
; 1100 : {
; 1101 : #ifdef D3DX_DEBUG
; 1102 :     if(!pV)
; 1103 :         return 0.0f;
; 1104 : #endif
; 1105 : 
; 1106 : #ifdef __cplusplus
; 1107 :     return sqrtf(pV->x * pV->x + pV->y * pV->y);
; 1108 : #else
; 1109 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
; 1110 : #endif
; 1111 : }
; 1112 : 
; 1113 : D3DXINLINE FLOAT D3DXVec2LengthSq
; 1114 :     ( CONST D3DXVECTOR2 *pV )
; 1115 : {
; 1116 : #ifdef D3DX_DEBUG
; 1117 :     if(!pV)
; 1118 :         return 0.0f;
; 1119 : #endif
; 1120 : 
; 1121 :     return pV->x * pV->x + pV->y * pV->y;
; 1122 : }
; 1123 : 
; 1124 : D3DXINLINE FLOAT D3DXVec2Dot
; 1125 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1126 : {
; 1127 : #ifdef D3DX_DEBUG
; 1128 :     if(!pV1 || !pV2)
; 1129 :         return 0.0f;
; 1130 : #endif
; 1131 : 
; 1132 :     return pV1->x * pV2->x + pV1->y * pV2->y;
; 1133 : }
; 1134 : 
; 1135 : D3DXINLINE FLOAT D3DXVec2CCW
; 1136 :     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1137 : {
; 1138 : #ifdef D3DX_DEBUG
; 1139 :     if(!pV1 || !pV2)
; 1140 :         return 0.0f;
; 1141 : #endif
; 1142 : 
; 1143 :     return pV1->x * pV2->y - pV1->y * pV2->x;
; 1144 : }
; 1145 : 
; 1146 : D3DXINLINE D3DXVECTOR2* D3DXVec2Add
; 1147 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1148 : {
; 1149 : #ifdef D3DX_DEBUG
; 1150 :     if(!pOut || !pV1 || !pV2)
; 1151 :         return NULL;
; 1152 : #endif
; 1153 : 
; 1154 :     pOut->x = pV1->x + pV2->x;
; 1155 :     pOut->y = pV1->y + pV2->y;
; 1156 :     return pOut;
; 1157 : }
; 1158 : 
; 1159 : D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
; 1160 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1161 : {
; 1162 : #ifdef D3DX_DEBUG
; 1163 :     if(!pOut || !pV1 || !pV2)
; 1164 :         return NULL;
; 1165 : #endif
; 1166 : 
; 1167 :     pOut->x = pV1->x - pV2->x;
; 1168 :     pOut->y = pV1->y - pV2->y;
; 1169 :     return pOut;
; 1170 : }
; 1171 : 
; 1172 : D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
; 1173 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1174 : {
; 1175 : #ifdef D3DX_DEBUG
; 1176 :     if(!pOut || !pV1 || !pV2)
; 1177 :         return NULL;
; 1178 : #endif
; 1179 : 
; 1180 :     pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
; 1181 :     pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
; 1182 :     return pOut;
; 1183 : }
; 1184 : 
; 1185 : D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
; 1186 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
; 1187 : {
; 1188 : #ifdef D3DX_DEBUG
; 1189 :     if(!pOut || !pV1 || !pV2)
; 1190 :         return NULL;
; 1191 : #endif
; 1192 : 
; 1193 :     pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
; 1194 :     pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
; 1195 :     return pOut;
; 1196 : }
; 1197 : 
; 1198 : D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
; 1199 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
; 1200 : {
; 1201 : #ifdef D3DX_DEBUG
; 1202 :     if(!pOut || !pV)
; 1203 :         return NULL;
; 1204 : #endif
; 1205 : 
; 1206 :     pOut->x = pV->x * s;
; 1207 :     pOut->y = pV->y * s;
; 1208 :     return pOut;
; 1209 : }
; 1210 : 
; 1211 : D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
; 1212 :     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
; 1213 :       FLOAT s )
; 1214 : {
; 1215 : #ifdef D3DX_DEBUG
; 1216 :     if(!pOut || !pV1 || !pV2)
; 1217 :         return NULL;
; 1218 : #endif
; 1219 : 
; 1220 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);
; 1221 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);
; 1222 :     return pOut;
; 1223 : }
; 1224 : 
; 1225 : 
; 1226 : //--------------------------
; 1227 : // 3D Vector
; 1228 : //--------------------------
; 1229 : 
; 1230 : D3DXINLINE FLOAT D3DXVec3Length
; 1231 :     ( CONST D3DXVECTOR3 *pV )
; 1232 : {
; 1233 : #ifdef D3DX_DEBUG
; 1234 :     if(!pV)
; 1235 :         return 0.0f;
; 1236 : #endif
; 1237 : 
; 1238 : #ifdef __cplusplus
; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1240 : #else
; 1241 :     return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
; 1242 : #endif
; 1243 : }
; 1244 : 
; 1245 : D3DXINLINE FLOAT D3DXVec3LengthSq
; 1246 :     ( CONST D3DXVECTOR3 *pV )
; 1247 : {
; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00177	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0017b	f3 0f 58 d1	 addss	 xmm2, xmm1
  0017f	f3 0f 58 d0	 addss	 xmm2, xmm0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 113  : 					if (D3DXVec3LengthSq(&Position)>0.001f)

  00183	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@3a83126f
  0018a	0f 86 87 01 00
	00		 jbe	 $LN10@OnRender

; 114  : 					{
; 115  : 						D3DXVec3Normalize(&Position,&Position);

  00190	8d 45 f0	 lea	 eax, DWORD PTR _Position$14[ebp]
  00193	50		 push	 eax
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 116  : 						D3DXQUATERNION q = SafeRotationNormalizedArc(D3DXVECTOR3(0.0f,-1.0f,0.0f),Position);

  0019a	8d 45 f0	 lea	 eax, DWORD PTR _Position$14[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0019d	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 116  : 						D3DXQUATERNION q = SafeRotationNormalizedArc(D3DXVECTOR3(0.0f,-1.0f,0.0f),Position);

  001a7	50		 push	 eax
  001a8	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  001ae	c7 85 d8 fe ff
	ff 00 00 80 bf	 mov	 DWORD PTR $T2[ebp+4], -1082130432 ; bf800000H
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 116  : 						D3DXQUATERNION q = SafeRotationNormalizedArc(D3DXVECTOR3(0.0f,-1.0f,0.0f),Position);

  001b8	50		 push	 eax
  001b9	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _q$1[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001bf	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+8], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 116  : 						D3DXQUATERNION q = SafeRotationNormalizedArc(D3DXVECTOR3(0.0f,-1.0f,0.0f),Position);

  001c9	50		 push	 eax
  001ca	e8 00 00 00 00	 call	 ?SafeRotationNormalizedArc@@YA?AUD3DXQUATERNION@@ABUD3DXVECTOR3@@0@Z ; SafeRotationNormalizedArc
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 						D3DXMatrixRotationQuaternion(&m_matWorld,&q);

  001d2	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _q$1[ebp]
  001d8	50		 push	 eax
  001d9	8d 45 b0	 lea	 eax, DWORD PTR _m_matWorld$13[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 118  : 					}
; 119  : 				}
; 120  : 				break;

  001e2	e9 30 01 00 00	 jmp	 $LN10@OnRender
$LN8@OnRender:
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  001e7	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+56], 0
  001ee	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+52], 0
  001f5	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+48], 0
  001fc	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+44], 0
  00203	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+36], 0
  0020a	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+32], 0
  00211	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+28], 0
  00218	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+24], 0
  0021f	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _matTemp$11[ebp+16], 0
  00226	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _matTemp$11[ebp+12], 0
  00230	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _matTemp$11[ebp+8], 0
  0023a	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _matTemp$11[ebp+4], 0

; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00244	c7 45 ac 00 00
	80 3f		 mov	 DWORD PTR _matTemp$11[ebp+60], 1065353216 ; 3f800000H
  0024b	c7 45 98 00 00
	80 3f		 mov	 DWORD PTR _matTemp$11[ebp+40], 1065353216 ; 3f800000H
  00252	c7 45 84 00 00
	80 3f		 mov	 DWORD PTR _matTemp$11[ebp+20], 1065353216 ; 3f800000H
  00259	c7 85 70 ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _matTemp$11[ebp], 1065353216 ; 3f800000H
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 98   : 					D3DXMatrixInverse(&matTemp, NULL, &CScreen::GetViewMatrix());

  00263	e8 00 00 00 00	 call	 ?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ ; CGraphicBase::GetViewMatrix
  00268	50		 push	 eax
  00269	6a 00		 push	 0
  0026b	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _matTemp$11[ebp]
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12

; 99   : 					m_matWorld._11 = matTemp._11;

  00277	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _matTemp$11[ebp]
  0027f	f3 0f 11 45 b0	 movss	 DWORD PTR _m_matWorld$13[ebp], xmm0

; 100  : 					m_matWorld._12 = matTemp._12;

  00284	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _matTemp$11[ebp+4]
  0028c	f3 0f 11 45 b4	 movss	 DWORD PTR _m_matWorld$13[ebp+4], xmm0

; 101  : 					m_matWorld._21 = matTemp._21;

  00291	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _matTemp$11[ebp+16]
  00296	f3 0f 11 45 c0	 movss	 DWORD PTR _m_matWorld$13[ebp+16], xmm0

; 102  : 					m_matWorld._22 = matTemp._22;

  0029b	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _matTemp$11[ebp+20]
  002a0	f3 0f 11 45 c4	 movss	 DWORD PTR _m_matWorld$13[ebp+20], xmm0

; 103  : 				}
; 104  : 				break;

  002a5	eb 70		 jmp	 SHORT $LN10@OnRender
$LN9@OnRender:

; 82   : 		{
; 83   : 			case MESH_BILLBOARD_TYPE_ALL:
; 84   : 				{
; 85   : 					D3DXMATRIX matTemp;
; 86   : 					D3DXMatrixRotationX(&matTemp, 90.0f);

  002a7	51		 push	 ecx
  002a8	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _matTemp$12[ebp]
  002ae	c7 04 24 00 00
	b4 42		 mov	 DWORD PTR [esp], 1119092736 ; 42b40000H
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 _D3DXMatrixRotationX@8

; 87   : 					D3DXMatrixInverse(&m_matWorld, NULL, &CScreen::GetViewMatrix());

  002bb	e8 00 00 00 00	 call	 ?GetViewMatrix@CGraphicBase@@SAABUD3DXMATRIX@@XZ ; CGraphicBase::GetViewMatrix
  002c0	50		 push	 eax
  002c1	6a 00		 push	 0
  002c3	8d 45 b0	 lea	 eax, DWORD PTR _m_matWorld$13[ebp]
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 _D3DXMatrixInverse@12
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  002cc	8d 45 b0	 lea	 eax, DWORD PTR _m_matWorld$13[ebp]
  002cf	50		 push	 eax
  002d0	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _matTemp$12[ebp]
  002d6	50		 push	 eax
  002d7	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 89   : 					m_matWorld = matTemp * m_matWorld;

  002e3	f3 0f 6f 85 18
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T8[ebp]
  002eb	f3 0f 7f 45 b0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp], xmm0
  002f0	f3 0f 6f 85 28
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T8[ebp+16]
  002f8	f3 0f 7f 45 c0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+16], xmm0
  002fd	f3 0f 6f 85 38
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T8[ebp+32]
  00305	f3 0f 7f 45 d0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+32], xmm0
  0030a	f3 0f 6f 85 48
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T8[ebp+48]
  00312	f3 0f 7f 45 e0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+48], xmm0
$LN10@OnRender:

; 121  : 		}
; 122  : 
; 123  : 		if (!m_pMeshScript->isBlendingEnable(i))

  00317	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0031a	56		 push	 esi
  0031b	e8 00 00 00 00	 call	 ?isBlendingEnable@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isBlendingEnable
  00320	85 c0		 test	 eax, eax
  00322	75 10		 jne	 SHORT $LN5@OnRender

; 124  : 		{
; 125  : 			STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

  00324	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0032a	50		 push	 eax
  0032b	6a 1b		 push	 27			; 0000001bH
  0032d	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 126  : 		}
; 127  : 		else

  00332	eb 49		 jmp	 SHORT $LN4@OnRender
$LN5@OnRender:

; 128  : 		{
; 129  : 			int iBlendingSrcType = m_pMeshScript->GetBlendingSrcType(i);

  00334	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00337	56		 push	 esi
  00338	e8 00 00 00 00	 call	 ?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z ; CEffectMeshScript::GetBlendingSrcType

; 130  : 			int iBlendingDestType = m_pMeshScript->GetBlendingDestType(i);

  0033d	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00340	56		 push	 esi
  00341	0f b6 f8	 movzx	 edi, al
  00344	e8 00 00 00 00	 call	 ?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z ; CEffectMeshScript::GetBlendingDestType

; 131  : 			STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  00349	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034f	6a 01		 push	 1
  00351	6a 1b		 push	 27			; 0000001bH
  00353	0f b6 f0	 movzx	 esi, al
  00356	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 132  : 			STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, iBlendingSrcType);

  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00361	57		 push	 edi
  00362	6a 13		 push	 19			; 00000013H
  00364	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 133  : 			STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, iBlendingDestType);

  00369	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0036f	56		 push	 esi
  00370	6a 14		 push	 20			; 00000014H
  00372	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
  00377	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN4@OnRender:

; 134  : 		}
; 135  : 
; 136  : 		D3DXVECTOR3 Position;
; 137  : 		m_pMeshScript->GetPosition(m_fLocalTime, Position);

  0037d	f3 0f 10 43 0c	 movss	 xmm0, DWORD PTR [ebx+12]
  00382	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _Position$10[ebp]
  00388	50		 push	 eax
  00389	51		 push	 ecx
  0038a	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0038d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00392	e8 00 00 00 00	 call	 ?GetPosition@CEffectElementBase@@QAEXMAAUD3DXVECTOR3@@@Z ; CEffectElementBase::GetPosition

; 138  : 		m_matWorld._41 = Position.x;

  00397	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _Position$10[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0039f	8d 45 b0	 lea	 eax, DWORD PTR _m_matWorld$13[ebp]
  003a2	ff 73 04	 push	 DWORD PTR [ebx+4]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 138  : 		m_matWorld._41 = Position.x;

  003a5	f3 0f 11 45 e0	 movss	 DWORD PTR _m_matWorld$13[ebp+48], xmm0

; 139  : 		m_matWorld._42 = Position.y;

  003aa	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _Position$10[ebp+4]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  003b2	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 139  : 		m_matWorld._42 = Position.y;

  003b3	f3 0f 11 45 e4	 movss	 DWORD PTR _m_matWorld$13[ebp+52], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  003b8	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 140  : 		m_matWorld._43 = Position.z;

  003be	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _Position$10[ebp+8]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  003c6	50		 push	 eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 140  : 		m_matWorld._43 = Position.z;

  003c7	f3 0f 11 45 e8	 movss	 DWORD PTR _m_matWorld$13[ebp+56], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  003cc	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 141  : 		m_matWorld = m_matWorld * *mc_pmatLocal;

  003d1	f3 0f 6f 85 18
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T7[ebp]

; 142  : 		STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorld);

  003d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003df	8d 45 b0	 lea	 eax, DWORD PTR _m_matWorld$13[ebp]
  003e2	50		 push	 eax
  003e3	f3 0f 7f 45 b0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp], xmm0
  003e8	68 00 01 00 00	 push	 256			; 00000100H
  003ed	f3 0f 6f 85 28
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T7[ebp+16]
  003f5	f3 0f 7f 45 c0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+16], xmm0
  003fa	f3 0f 6f 85 38
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T7[ebp+32]
  00402	f3 0f 7f 45 d0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+32], xmm0
  00407	f3 0f 6f 85 48
	ff ff ff	 movdqu	 xmm0, XMMWORD PTR $T7[ebp+48]
  0040f	f3 0f 7f 45 e0	 movdqu	 XMMWORD PTR _m_matWorld$13[ebp+48], xmm0
  00414	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform
  00419	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000

; 143  : 
; 144  : 		BYTE byType;
; 145  : 		D3DXCOLOR Color(1.0f, 1.0f, 1.0f, 1.0f);
; 146  : 		if (m_pMeshScript->GetColorOperationType(i, &byType))

  00420	8d 85 13 ff ff
	ff		 lea	 eax, DWORD PTR _byType$6[ebp]
  00426	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00429	50		 push	 eax
  0042a	56		 push	 esi
  0042b	0f 11 85 e0 fe
	ff ff		 movups	 XMMWORD PTR _Color$3[ebp], xmm0
  00432	e8 00 00 00 00	 call	 ?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ; CEffectMeshScript::GetColorOperationType
  00437	85 c0		 test	 eax, eax
  00439	74 17		 je	 SHORT $LN3@OnRender

; 147  : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, byType);

  0043b	0f b6 85 13 ff
	ff ff		 movzx	 eax, BYTE PTR _byType$6[ebp]
  00442	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00448	50		 push	 eax
  00449	6a 01		 push	 1
  0044b	6a 00		 push	 0
  0044d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN3@OnRender:

; 148  : 		m_pMeshScript->GetColorFactor(i, &Color);

  00452	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00455	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _Color$3[ebp]
  0045b	50		 push	 eax
  0045c	56		 push	 esi
  0045d	e8 00 00 00 00	 call	 ?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ; CEffectMeshScript::GetColorFactor

; 149  : 
; 150  : 		TTimeEventTableFloat * TableAlpha;
; 151  : 
; 152  : 		float fAlpha = 1.0f;

  00462	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000

; 153  : 		if (m_pMeshScript->GetTimeTableAlphaPointer(i, &TableAlpha) && !TableAlpha->empty())

  0046a	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _TableAlpha$4[ebp]
  00470	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00473	50		 push	 eax
  00474	56		 push	 esi
  00475	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm0
  0047d	e8 00 00 00 00	 call	 ?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; CEffectMeshScript::GetTimeTableAlphaPointer
  00482	85 c0		 test	 eax, eax
  00484	0f 84 d8 00 00
	00		 je	 $LN71@OnRender
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  0048a	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _TableAlpha$4[ebp]
  00490	8b 01		 mov	 eax, DWORD PTR [ecx]
  00492	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00495	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 153  : 		if (m_pMeshScript->GetTimeTableAlphaPointer(i, &TableAlpha) && !TableAlpha->empty())

  00497	0f 84 c5 00 00
	00		 je	 $LN71@OnRender

; 154  : 			GetTimeEventBlendValue(m_fLocalTime,*TableAlpha, &fAlpha);

  0049d	f3 0f 10 4b 0c	 movss	 xmm1, DWORD PTR [ebx+12]
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  004a2	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 154  : 			GetTimeEventBlendValue(m_fLocalTime,*TableAlpha, &fAlpha);

  004a5	f3 0f 11 8d 14
	ff ff ff	 movss	 DWORD PTR _fElapsedTime$[ebp], xmm1
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  004ad	3b d1		 cmp	 edx, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 235  : 	if(rVector.begin()+1==rVector.end())

  004af	75 12		 jne	 SHORT $LN75@OnRender

; 236  : 	{
; 237  : 		*pReturnValue = rVector.front().m_Value;

  004b1	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004b6	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm0

; 238  : 		return;

  004be	e9 9f 00 00 00	 jmp	 $LN71@OnRender
$LN75@OnRender:

; 239  : 	}
; 240  : 	
; 241  : 	if (fElapsedTime < rVector.front().m_fTime)

  004c3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004c7	0f 2f c1	 comiss	 xmm0, xmm1
  004ca	76 12		 jbe	 SHORT $LN74@OnRender

; 242  : 	{
; 243  : 		*pReturnValue = rVector.front().m_Value;

  004cc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004d1	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm0

; 244  : 		return;

  004d9	e9 84 00 00 00	 jmp	 $LN71@OnRender
$LN74@OnRender:

; 245  : 	}
; 246  : 
; 247  : 	if (fElapsedTime > rVector.back().m_fTime)

  004de	0f 2f 49 f8	 comiss	 xmm1, DWORD PTR [ecx-8]
  004e2	76 0f		 jbe	 SHORT $LN73@OnRender

; 248  : 	{
; 249  : 		*pReturnValue = rVector.back().m_Value;

  004e4	f3 0f 10 41 fc	 movss	 xmm0, DWORD PTR [ecx-4]
  004e9	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm0

; 250  : 		return;

  004f1	eb 6f		 jmp	 SHORT $LN71@OnRender
$LN73@OnRender:

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  004f3	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR _fElapsedTime$[ebp]
  004f9	52		 push	 edx
  004fa	51		 push	 ecx
  004fb	50		 push	 eax
  004fc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _result$5[ebp]
  00502	50		 push	 eax
  00503	e8 00 00 00 00	 call	 ??$equal_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@M@std@@YA?AU?$pair@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@std@@V12@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@0@0ABM@Z ; std::equal_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimeEvent<float> > > >,float>
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00508	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _result$5[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 255  : 	std::pair<iterator, iterator> result = std::equal_range(rVector.begin(), rVector.end(), fElapsedTime);

  0050e	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00511	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _result$5[ebp+4]
  00517	3b c1		 cmp	 eax, ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 257  : 	if (result.first != result.second)

  00519	74 0f		 je	 SHORT $LN72@OnRender

; 258  : 		*pReturnValue = result.first->m_Value;

  0051b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00520	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm0

; 259  : 	else

  00528	eb 38		 jmp	 SHORT $LN71@OnRender
$LN72@OnRender:

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0052a	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
; File a:\vs\vc\include\vector

; 141  : 		--this->_Ptr;

  0052e	83 e8 08	 sub	 eax, 8
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  00531	0f 28 d0	 movaps	 xmm2, xmm0
; File a:\vs\vc\include\vector

; 141  : 		--this->_Ptr;

  00534	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _result$5[ebp], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\type.h

; 262  : 		float Head = (result.second->m_fTime - fElapsedTime) / (result.second->m_fTime - result.first->m_fTime);

  0053a	f3 0f 5c 53 0c	 subss	 xmm2, DWORD PTR [ebx+12]
  0053f	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00543	f3 0f 5e d0	 divss	 xmm2, xmm0

; 263  : 		*pReturnValue = T((result.first->m_Value-result.second->m_Value)*Head+(result.second->m_Value));

  00547	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0054c	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00551	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00555	f3 0f 58 51 04	 addss	 xmm2, DWORD PTR [ecx+4]
  0055a	f3 0f 11 95 14
	ff ff ff	 movss	 DWORD PTR _fAlpha$1$[ebp], xmm2
$LN71@OnRender:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 157  : 		CEffectMesh::TEffectMeshData * pMeshData = pEffectMesh->GetMeshDataPointer(i);

  00562	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _pEffectMesh$1$[ebp]
  00568	56		 push	 esi
  00569	e8 00 00 00 00	 call	 ?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ; CEffectMesh::GetMeshDataPointer

; 158  : 
; 159  : 		assert(m_MeshFrameController.GetCurrentFrame() < pMeshData->EffectFrameDataVector.size());
; 160  : 		CEffectMesh::TEffectFrameData & rFrameData = pMeshData->EffectFrameDataVector[m_MeshFrameController.GetCurrentFrame()];

  0056e	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  00571	8b f0		 mov	 esi, eax
  00573	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame

; 162  : 		DWORD dwcurTextureFrame = rTextureFrameController.GetCurrentFrame();

  00578	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _rTextureFrameController$1$[ebp]
  0057e	0f b6 f8	 movzx	 edi, al
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00581	c1 e7 05	 shl	 edi, 5
  00584	03 be a0 00 00
	00		 add	 edi, DWORD PTR [esi+160]
  0058a	89 bd f0 fe ff
	ff		 mov	 DWORD PTR _rFrameData$1$[ebp], edi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 162  : 		DWORD dwcurTextureFrame = rTextureFrameController.GetCurrentFrame();

  00590	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame

; 163  : 		if (dwcurTextureFrame < m_TextureInstanceVector[i].TextureInstanceVector.size())

  00595	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00598	8b b5 0c ff ff
	ff		 mov	 esi, DWORD PTR tv1679[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 162  : 		DWORD dwcurTextureFrame = rTextureFrameController.GetCurrentFrame();

  0059e	0f b6 d0	 movzx	 edx, al
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  005a1	8b 44 0e 28	 mov	 eax, DWORD PTR [esi+ecx+40]
  005a5	2b 44 0e 24	 sub	 eax, DWORD PTR [esi+ecx+36]
  005a9	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 163  : 		if (dwcurTextureFrame < m_TextureInstanceVector[i].TextureInstanceVector.size())

  005ac	3b d0		 cmp	 edx, eax
  005ae	73 23		 jae	 SHORT $LN1@OnRender

; 164  : 		{
; 165  : 			CGraphicImageInstance * pImageInstance = m_TextureInstanceVector[i].TextureInstanceVector[dwcurTextureFrame];

  005b0	8b 44 0e 24	 mov	 eax, DWORD PTR [esi+ecx+36]
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h

; 27   : 		return (*ms_singleton);

  005b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 166  : 			STATEMANAGER.SetTexture(0, pImageInstance->GetTexturePointer()->GetD3DTexture());

  005ba	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  005bd	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  005c2	8b c8		 mov	 ecx, eax
  005c4	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  005c9	50		 push	 eax
  005ca	6a 00		 push	 0
  005cc	8b ce		 mov	 ecx, esi
  005ce	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN1@OnRender:

; 169  : 		Color.a = fAlpha * rFrameData.fVisibility;

  005d3	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  005d8	0f 57 d2	 xorps	 xmm2, xmm2
  005db	f3 0f 59 85 14
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlpha$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  005e3	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 169  : 		Color.a = fAlpha * rFrameData.fVisibility;

  005eb	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _Color$1$[ebp], xmm0
  005f3	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _Color$3[ebp+12], xmm0
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  005fb	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$3[ebp]
  00603	0f 2f c1	 comiss	 xmm0, xmm1
  00606	72 0c		 jb	 SHORT $LN305@OnRender
  00608	c7 85 14 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  00612	eb 37		 jmp	 SHORT $LN304@OnRender
$LN305@OnRender:
  00614	0f 2f d0	 comiss	 xmm2, xmm0
  00617	72 0c		 jb	 SHORT $LN303@OnRender
  00619	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 0
  00623	eb 26		 jmp	 SHORT $LN304@OnRender
$LN303@OnRender:
  00625	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0062d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00635	e8 00 00 00 00	 call	 __ftoui3
  0063a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00642	0f 57 d2	 xorps	 xmm2, xmm2
  00645	89 85 14 ff ff
	ff		 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN304@OnRender:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0064b	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$3[ebp+4]
  00653	0f 2f c1	 comiss	 xmm0, xmm1
  00656	72 07		 jb	 SHORT $LN309@OnRender
  00658	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  0065d	eb 28		 jmp	 SHORT $LN308@OnRender
$LN309@OnRender:
  0065f	0f 2f d0	 comiss	 xmm2, xmm0
  00662	72 04		 jb	 SHORT $LN307@OnRender
  00664	33 ff		 xor	 edi, edi
  00666	eb 1f		 jmp	 SHORT $LN308@OnRender
$LN307@OnRender:
  00668	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00670	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00678	e8 00 00 00 00	 call	 __ftoui3
  0067d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00685	8b f8		 mov	 edi, eax
$LN308@OnRender:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00687	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _Color$3[ebp+8]
  0068f	0f 57 d2	 xorps	 xmm2, xmm2
  00692	0f 2f c1	 comiss	 xmm0, xmm1
  00695	72 07		 jb	 SHORT $LN313@OnRender
  00697	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  0069c	eb 2b		 jmp	 SHORT $LN312@OnRender
$LN313@OnRender:
  0069e	0f 2f d0	 comiss	 xmm2, xmm0
  006a1	72 04		 jb	 SHORT $LN311@OnRender
  006a3	33 f6		 xor	 esi, esi
  006a5	eb 22		 jmp	 SHORT $LN312@OnRender
$LN311@OnRender:
  006a7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006af	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006b7	e8 00 00 00 00	 call	 __ftoui3
  006bc	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  006c4	8b f0		 mov	 esi, eax
  006c6	0f 57 d2	 xorps	 xmm2, xmm2
$LN312@OnRender:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  006c9	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _Color$1$[ebp]
  006d1	0f 2f c1	 comiss	 xmm0, xmm1
  006d4	72 07		 jb	 SHORT $LN317@OnRender
  006d6	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  006db	eb 1e		 jmp	 SHORT $LN316@OnRender
$LN317@OnRender:
  006dd	0f 2f d0	 comiss	 xmm2, xmm0
  006e0	72 04		 jb	 SHORT $LN315@OnRender
  006e2	33 c0		 xor	 eax, eax
  006e4	eb 15		 jmp	 SHORT $LN316@OnRender
$LN315@OnRender:
  006e6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006ee	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006f6	e8 00 00 00 00	 call	 __ftoui3
$LN316@OnRender:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 170  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, DWORD(Color));

  006fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00701	c1 e0 08	 shl	 eax, 8
  00704	0b 85 14 ff ff
	ff		 or	 eax, DWORD PTR _dwR$1$[ebp]
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0070a	c1 e0 08	 shl	 eax, 8
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 170  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, DWORD(Color));

  0070d	0b c7		 or	 eax, edi
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0070f	c1 e0 08	 shl	 eax, 8
  00712	0b c6		 or	 eax, esi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 170  : 		STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, DWORD(Color));

  00714	50		 push	 eax
  00715	6a 3c		 push	 60			; 0000003cH
  00717	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 171  : 		STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);

  0071c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00722	68 02 01 00 00	 push	 258			; 00000102H
  00727	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 172  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLELIST,
; 173  : 									 rFrameData.dwIndexCount/3,
; 174  : 									 &rFrameData.PDTVertexVector[0],
; 175  : 									 sizeof(TPTVertex));

  0072c	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _rFrameData$1$[ebp]
  00732	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00737	6a 14		 push	 20			; 00000014H
  00739	f7 61 10	 mul	 DWORD PTR [ecx+16]
  0073c	ff 71 14	 push	 DWORD PTR [ecx+20]
  0073f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00745	d1 ea		 shr	 edx, 1
  00747	52		 push	 edx
  00748	6a 04		 push	 4
  0074a	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP
  0074f	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN14@OnRender:

; 68   : 	for (DWORD i = 0; i < pEffectMesh->GetMeshCount(); ++i)

  00755	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR _pEffectMesh$1$[ebp]
  0075b	46		 inc	 esi
  0075c	83 85 0c ff ff
	ff 30		 add	 DWORD PTR tv1679[ebp], 48 ; 00000030H
  00763	89 b5 04 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00769	e8 00 00 00 00	 call	 ?GetMeshCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetMeshCount
  0076e	3b f0		 cmp	 esi, eax
  00770	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  00773	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv1679[ebp]
  00779	0f 82 d1 f8 ff
	ff		 jb	 $LL15@OnRender
  0077f	5f		 pop	 edi
$LN331@OnRender:
  00780	5e		 pop	 esi
$LN13@OnRender:

; 176  : 		// Render //
; 177  : 	}
; 178  : }

  00781	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00784	33 cd		 xor	 ecx, ebp
  00786	5b		 pop	 ebx
  00787	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0078c	8b e5		 mov	 esp, ebp
  0078e	5d		 pop	 ebp
  0078f	c3		 ret	 0
?OnRender@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?OnUpdate@CEffectMeshInstance@@MAE_NM@Z
_TEXT	SEGMENT
_j$1$ = -4						; size = 4
_fElapsedTime$ = 8					; size = 4
?OnUpdate@CEffectMeshInstance@@MAE_NM@Z PROC		; CEffectMeshInstance::OnUpdate, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 45   : 	if (!isActive())

  00007	e8 00 00 00 00	 call	 ?isActive@CEffectMeshInstance@@IAEHXZ ; CEffectMeshInstance::isActive
  0000c	85 c0		 test	 eax, eax
  0000e	75 09		 jne	 SHORT $LN6@OnUpdate

; 46   : 		return false;

  00010	32 c0		 xor	 al, al
  00012	5e		 pop	 esi

; 59   : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN6@OnUpdate:
  00019	53		 push	 ebx

; 47   : 
; 48   : 	if (m_MeshFrameController.isActive())

  0001a	6a 00		 push	 0
  0001c	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  0001f	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  00024	85 c0		 test	 eax, eax
  00026	74 13		 je	 SHORT $LN5@OnUpdate

; 49   : 		m_MeshFrameController.Update(fElapsedTime);

  00028	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  0002d	51		 push	 ecx
  0002e	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	e8 00 00 00 00	 call	 ?Update@CFrameController@@QAEXM@Z ; CFrameController::Update
$LN5@OnUpdate:

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  0003b	33 c9		 xor	 ecx, ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0003d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00042	89 4d fc	 mov	 DWORD PTR _j$1$[ebp], ecx
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00045	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00048	2b 4e 50	 sub	 ecx, DWORD PTR [esi+80]
  0004b	f7 e9		 imul	 ecx
  0004d	c1 fa 03	 sar	 edx, 3
  00050	8b c2		 mov	 eax, edx
  00052	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00055	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00057	74 59		 je	 SHORT $LN2@OnUpdate
  00059	57		 push	 edi
  0005a	33 ff		 xor	 edi, edi
  0005c	8d 64 24 00	 npad	 4
$LL4@OnUpdate:

; 53   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  00060	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00063	e8 00 00 00 00	 call	 ?GetCurrentFrame@CFrameController@@QAEEXZ ; CFrameController::GetCurrentFrame
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  00068	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 53   : 		int iCurrentFrame = m_MeshFrameController.GetCurrentFrame();

  0006b	0f b6 c0	 movzx	 eax, al
; File a:\vs\vc\include\vector

; 1209 : 		return (*(this->_Myfirst + _Pos));

  0006e	03 cf		 add	 ecx, edi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 54   : 		if (m_TextureInstanceVector[j].TextureFrameController.isActive(iCurrentFrame))

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?isActive@CFrameController@@QAEHK@Z ; CFrameController::isActive
  00076	85 c0		 test	 eax, eax
  00078	74 15		 je	 SHORT $LN3@OnUpdate

; 55   : 			m_TextureInstanceVector[j].TextureFrameController.Update(fElapsedTime);

  0007a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  0007f	51		 push	 ecx
  00080	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00083	03 cf		 add	 ecx, edi
  00085	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008a	e8 00 00 00 00	 call	 ?Update@CFrameController@@QAEXM@Z ; CFrameController::Update
$LN3@OnUpdate:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0008f	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  00092	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00097	2b 4e 50	 sub	 ecx, DWORD PTR [esi+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  0009a	83 c7 30	 add	 edi, 48			; 00000030H
  0009d	ff 45 fc	 inc	 DWORD PTR _j$1$[ebp]
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000a0	f7 e9		 imul	 ecx
  000a2	c1 fa 03	 sar	 edx, 3
  000a5	8b c2		 mov	 eax, edx
  000a7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000aa	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 51   : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  000ac	39 45 fc	 cmp	 DWORD PTR _j$1$[ebp], eax
  000af	72 af		 jb	 SHORT $LL4@OnUpdate
  000b1	5f		 pop	 edi
$LN2@OnUpdate:
  000b2	5b		 pop	 ebx

; 56   : 	}
; 57   : 
; 58   : 	return true;

  000b3	b0 01		 mov	 al, 1
  000b5	5e		 pop	 esi

; 59   : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 04 00	 ret	 4
?OnUpdate@CEffectMeshInstance@@MAE_NM@Z ENDP		; CEffectMeshInstance::OnUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?OnDestroy@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
__Cat$1 = -5						; size = 1
__Alval$2 = -1						; size = 1
?OnDestroy@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnDestroy, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000b	8b 7b 54	 mov	 edi, DWORD PTR [ebx+84]

; 23   : 	for (; _First != _Last; ++_First)

  0000e	8b 73 50	 mov	 esi, DWORD PTR [ebx+80]
  00011	3b f7		 cmp	 esi, edi
  00013	74 10		 je	 SHORT $LN29@OnDestroy
$LL31@OnDestroy:

; 24   : 		_Func(*_First);

  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ?CEffectMeshInstance_DeleteTextureInstance@@YAXAAUSTextureInstance@CEffectMeshInstance@@@Z ; CEffectMeshInstance_DeleteTextureInstance
  0001b	83 c6 30	 add	 esi, 48			; 00000030H
  0001e	83 c4 04	 add	 esp, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 f0		 jne	 SHORT $LL31@OnDestroy
$LN29@OnDestroy:
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00025	ff 75 fb	 push	 DWORD PTR __Cat$1[ebp]
  00028	8d 45 ff	 lea	 eax, DWORD PTR __Alval$2[ebp]
  0002b	50		 push	 eax
  0002c	ff 73 54	 push	 DWORD PTR [ebx+84]
  0002f	ff 73 50	 push	 DWORD PTR [ebx+80]
  00032	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00037	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0003a	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003d	89 43 54	 mov	 DWORD PTR [ebx+84], eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00040	8b 4b 5c	 mov	 ecx, DWORD PTR [ebx+92]
  00043	c7 43 5c 00 00
	00 00		 mov	 DWORD PTR [ebx+92], 0
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 68   : 
; 69   : 			m_pObject = pObject;
; 70   : 
; 71   : 			if (m_pObject)
; 72   : 				m_pObject->AddReference();
; 73   : 
; 74   : 			if (pOldObject)

  0004d	85 c9		 test	 ecx, ecx
  0004f	74 05		 je	 SHORT $LN46@OnDestroy

; 75   : 				pOldObject->Release();

  00051	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN46@OnDestroy:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 261  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?OnDestroy@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?OnInitialize@CEffectMeshInstance@@MAEXXZ
_TEXT	SEGMENT
?OnInitialize@CEffectMeshInstance@@MAEXXZ PROC		; CEffectMeshInstance::OnInitialize, COMDAT
; _this$ = ecx

; 254  : }

  00000	c3		 ret	 0
?OnInitialize@CEffectMeshInstance@@MAEXXZ ENDP		; CEffectMeshInstance::OnInitialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\xmemory0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
_TEXT	SEGMENT
_pTextureVector$1$ = -44				; size = 4
_pImage$1$ = -40					; size = 4
$T2 = -36						; size = 4
_pkNewData$3 = -36					; size = 4
_this$2$ = -32						; size = 4
tv928 = -28						; size = 4
_this$1$ = -24						; size = 4
_pImageInstance$4 = -20					; size = 4
_pMeshData$5 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_j$1$ = 8						; size = 4
__Cat$6 = 8						; size = 1
_pElement$ = 8						; size = 4
__Alval$7 = 11						; size = 1
?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z PROC ; CEffectMeshInstance::OnSetDataPointer, COMDAT
; _this$ = ecx

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 182  : 	CEffectMeshScript * pMesh = (CEffectMeshScript *)pElement;
; 183  : 	m_pMeshScript = pMesh;

  0002d	8b 7d 08	 mov	 edi, DWORD PTR _pElement$[ebp]

; 184  : 
; 185  : 	const char * c_szMeshFileName = pMesh->GetMeshFileName();

  00030	8b cf		 mov	 ecx, edi
  00032	89 7b 24	 mov	 DWORD PTR [ebx+36], edi
  00035	e8 00 00 00 00	 call	 ?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ ; CEffectMeshScript::GetMeshFileName

; 186  : 
; 187  : 	m_pEffectMesh = (CEffectMesh *) CResourceManager::Instance().GetResourcePointer(c_szMeshFileName);

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00046	89 43 28	 mov	 DWORD PTR [ebx+40], eax

; 188  : 
; 189  : 	if (!m_pEffectMesh)

  00049	85 c0		 test	 eax, eax
  0004b	0f 84 89 02 00
	00		 je	 $LN193@OnSetDataP
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00051	8b 73 5c	 mov	 esi, DWORD PTR [ebx+92]

; 68   : 
; 69   : 			m_pObject = pObject;
; 70   : 
; 71   : 			if (m_pObject)
; 72   : 				m_pObject->AddReference();

  00054	8b c8		 mov	 ecx, eax
  00056	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  00059	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 73   : 
; 74   : 			if (pOldObject)

  0005e	85 f6		 test	 esi, esi
  00060	74 07		 je	 SHORT $LN15@OnSetDataP

; 75   : 				pOldObject->Release();

  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN15@OnSetDataP:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 194  : 	m_MeshFrameController.Clear();

  00069	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  0006c	e8 00 00 00 00	 call	 ?Clear@CFrameController@@QAEXXZ ; CFrameController::Clear

; 195  : 	m_MeshFrameController.SetMaxFrame(m_roMesh.GetPointer()->GetFrameCount());

  00071	8b 4b 5c	 mov	 ecx, DWORD PTR [ebx+92]
  00074	e8 00 00 00 00	 call	 ?GetFrameCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetFrameCount
  00079	50		 push	 eax
  0007a	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  0007d	e8 00 00 00 00	 call	 ?SetMaxFrame@CFrameController@@QAEXK@Z ; CFrameController::SetMaxFrame

; 196  : 	m_MeshFrameController.SetFrameTime(pMesh->GetMeshAnimationFrameDelay());

  00082	8b cf		 mov	 ecx, edi
  00084	e8 00 00 00 00	 call	 ?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ; CEffectMeshScript::GetMeshAnimationFrameDelay
  00089	51		 push	 ecx
  0008a	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  0008d	d9 1c 24	 fstp	 DWORD PTR [esp]
  00090	e8 00 00 00 00	 call	 ?SetFrameTime@CFrameController@@QAEXM@Z ; CFrameController::SetFrameTime

; 197  : 	m_MeshFrameController.SetLoopFlag(pMesh->isMeshAnimationLoop());

  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::isMeshAnimationLoop
  0009c	50		 push	 eax
  0009d	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  000a0	e8 00 00 00 00	 call	 ?SetLoopFlag@CFrameController@@QAEXH@Z ; CFrameController::SetLoopFlag

; 198  : 	m_MeshFrameController.SetLoopCount(pMesh->GetMeshAnimationLoopCount());

  000a5	8b cf		 mov	 ecx, edi
  000a7	e8 00 00 00 00	 call	 ?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::GetMeshAnimationLoopCount
  000ac	50		 push	 eax
  000ad	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  000b0	e8 00 00 00 00	 call	 ?SetLoopCount@CFrameController@@QAEXH@Z ; CFrameController::SetLoopCount

; 199  : 	m_MeshFrameController.SetStartFrame(0);

  000b5	6a 00		 push	 0
  000b7	8d 4b 2c	 lea	 ecx, DWORD PTR [ebx+44]
  000ba	e8 00 00 00 00	 call	 ?SetStartFrame@CFrameController@@QAEXK@Z ; CFrameController::SetStartFrame
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000bf	ff 75 08	 push	 DWORD PTR __Cat$6[ebp]
  000c2	8d 45 0b	 lea	 eax, DWORD PTR __Alval$7[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 201  : 	m_TextureInstanceVector.clear();

  000c5	8d 7b 50	 lea	 edi, DWORD PTR [ebx+80]
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000c8	50		 push	 eax
  000c9	ff 77 04	 push	 DWORD PTR [edi+4]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 201  : 	m_TextureInstanceVector.clear();

  000cc	89 7d e0	 mov	 DWORD PTR _this$2$[ebp], edi
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000cf	ff 37		 push	 DWORD PTR [edi]
  000d1	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000d6	8b 07		 mov	 eax, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  000d8	83 c4 10	 add	 esp, 16			; 00000010H
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  000db	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 202  : 	m_TextureInstanceVector.resize(m_pEffectMesh->GetMeshCount());

  000de	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  000e1	e8 00 00 00 00	 call	 ?GetMeshCount@CEffectMesh@@QAEKXZ ; CEffectMesh::GetMeshCount
  000e6	50		 push	 eax
  000e7	8b cf		 mov	 ecx, edi
  000e9	e8 00 00 00 00	 call	 ?resize@?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::resize
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000ee	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000f1	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000f6	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  000f8	33 f6		 xor	 esi, esi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000fa	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  000fc	89 75 08	 mov	 DWORD PTR _j$1$[ebp], esi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  000ff	c1 fa 03	 sar	 edx, 3
  00102	8b c2		 mov	 eax, edx
  00104	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00107	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  00109	0f 84 cb 01 00
	00		 je	 $LN193@OnSetDataP

; 194  : 	m_MeshFrameController.Clear();

  0010f	33 ff		 xor	 edi, edi
  00111	89 7d e4	 mov	 DWORD PTR tv928[ebp], edi
$LL9@OnSetDataP:

; 204  : 	{
; 205  : 		CEffectMeshScript::TMeshData * pMeshData;
; 206  : 		if (!m_pMeshScript->GetMeshDataPointer(j, &pMeshData))

  00114	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00117	8d 45 f0	 lea	 eax, DWORD PTR _pMeshData$5[ebp]
  0011a	50		 push	 eax
  0011b	56		 push	 esi
  0011c	e8 00 00 00 00	 call	 ?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ; CEffectMeshScript::GetMeshDataPointer
  00121	84 c0		 test	 al, al
  00123	0f 84 88 01 00
	00		 je	 $LN8@OnSetDataP
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00129	8b 4b 5c	 mov	 ecx, DWORD PTR [ebx+92]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 211  : 		if (!pkEftMesh)

  0012c	85 c9		 test	 ecx, ecx
  0012e	0f 84 7d 01 00
	00		 je	 $LN8@OnSetDataP

; 212  : 			continue;
; 213  : 
; 214  : 		std::vector<CGraphicImage*>* pTextureVector = pkEftMesh->GetTextureVectorPointer(j);

  00134	56		 push	 esi
  00135	e8 00 00 00 00	 call	 ?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorPointer
  0013a	8b d8		 mov	 ebx, eax
  0013c	89 5d d4	 mov	 DWORD PTR _pTextureVector$1$[ebp], ebx

; 215  : 		if (!pTextureVector)

  0013f	85 db		 test	 ebx, ebx
  00141	0f 84 67 01 00
	00		 je	 $LN195@OnSetDataP

; 216  : 			continue;
; 217  : 
; 218  : 		std::vector<CGraphicImage*>& rTextureVector = *pTextureVector;
; 219  : 
; 220  : 		CFrameController & rFrameController = m_TextureInstanceVector[j].TextureFrameController;

  00147	8b 45 e0	 mov	 eax, DWORD PTR _this$2$[ebp]
  0014a	8b 30		 mov	 esi, DWORD PTR [eax]
  0014c	03 f7		 add	 esi, edi

; 221  : 		rFrameController.Clear();

  0014e	8b ce		 mov	 ecx, esi
  00150	e8 00 00 00 00	 call	 ?Clear@CFrameController@@QAEXXZ ; CFrameController::Clear
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00155	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 222  : 		rFrameController.SetMaxFrame(rTextureVector.size());

  00158	8b ce		 mov	 ecx, esi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0015a	2b 03		 sub	 eax, DWORD PTR [ebx]
  0015c	c1 f8 02	 sar	 eax, 2
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 222  : 		rFrameController.SetMaxFrame(rTextureVector.size());

  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 ?SetMaxFrame@CFrameController@@QAEXK@Z ; CFrameController::SetMaxFrame

; 223  : 		rFrameController.SetFrameTime(pMeshData->fTextureAnimationFrameDelay);

  00165	8b 45 f0	 mov	 eax, DWORD PTR _pMeshData$5[ebp]
  00168	51		 push	 ecx
  00169	8b ce		 mov	 ecx, esi
  0016b	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00170	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00175	e8 00 00 00 00	 call	 ?SetFrameTime@CFrameController@@QAEXM@Z ; CFrameController::SetFrameTime

; 224  : 		rFrameController.SetLoopFlag(pMeshData->bTextureAnimationLoopEnable);

  0017a	8b 45 f0	 mov	 eax, DWORD PTR _pMeshData$5[ebp]
  0017d	8b ce		 mov	 ecx, esi
  0017f	ff 70 24	 push	 DWORD PTR [eax+36]
  00182	e8 00 00 00 00	 call	 ?SetLoopFlag@CFrameController@@QAEXH@Z ; CFrameController::SetLoopFlag

; 225  : 		rFrameController.SetStartFrame(pMeshData->dwTextureAnimationStartFrame);

  00187	8b 45 f0	 mov	 eax, DWORD PTR _pMeshData$5[ebp]
  0018a	8b ce		 mov	 ecx, esi
  0018c	ff 70 2c	 push	 DWORD PTR [eax+44]
  0018f	e8 00 00 00 00	 call	 ?SetStartFrame@CFrameController@@QAEXK@Z ; CFrameController::SetStartFrame

; 226  : 
; 227  : 		std::vector<CGraphicImageInstance*> & rImageInstanceVector = m_TextureInstanceVector[j].TextureInstanceVector;

  00194	8b 4d e0	 mov	 ecx, DWORD PTR _this$2$[ebp]
  00197	8b 01		 mov	 eax, DWORD PTR [ecx]
  00199	83 c0 24	 add	 eax, 36			; 00000024H
  0019c	03 f8		 add	 edi, eax
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0019e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  001a0	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 1510 : 		this->_Mylast = this->_Myfirst;

  001a3	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  001a6	2b c1		 sub	 eax, ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  001a8	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  001ab	2b 13		 sub	 edx, DWORD PTR [ebx]
  001ad	c1 fa 02	 sar	 edx, 2

; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  001b0	c1 f8 02	 sar	 eax, 2

; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

  001b3	3b c2		 cmp	 eax, edx
  001b5	73 14		 jae	 SHORT $LN48@OnSetDataP

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  001b7	81 fa ff ff ff
	3f		 cmp	 edx, 1073741823		; 3fffffffH
  001bd	0f 87 2b 01 00
	00		 ja	 $LN185@OnSetDataP

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  001c3	52		 push	 edx
  001c4	8b cf		 mov	 ecx, edi
  001c6	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
$LN48@OnSetDataP:

; 47   : 		{	// construct with pointer _Parg

  001cb	8b 33		 mov	 esi, DWORD PTR [ebx]

; 205  : 		return (this->_Ptr == _Right._Ptr);

  001cd	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 230  : 		for (std::vector<CGraphicImage*>::iterator itor = rTextureVector.begin(); itor != rTextureVector.end(); ++itor)

  001d0	0f 84 d2 00 00
	00		 je	 $LN194@OnSetDataP
$LL77@OnSetDataP:

; 231  : 		{
; 232  : 			CGraphicImage * pImage = *itor;

  001d6	8b 06		 mov	 eax, DWORD PTR [esi]
  001d8	89 45 d8	 mov	 DWORD PTR _pImage$1$[ebp], eax
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  001db	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+20
  001e0	39 05 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+16, eax
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  001e6	75 46		 jne	 SHORT $LN97@OnSetDataP

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  001e8	6a 20		 push	 32			; 00000020H
  001ea	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001ef	83 c4 04	 add	 esp, 4
  001f2	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  001f5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001fc	85 c0		 test	 eax, eax
  001fe	74 09		 je	 SHORT $LN100@OnSetDataP
  00200	8b c8		 mov	 ecx, eax
  00202	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00207	eb 02		 jmp	 SHORT $LN101@OnSetDataP
$LN100@OnSetDataP:
  00209	33 c0		 xor	 eax, eax
$LN101@OnSetDataP:
  0020b	89 45 dc	 mov	 DWORD PTR _pkNewData$3[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0020e	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+4
  00213	8d 45 dc	 lea	 eax, DWORD PTR _pkNewData$3[ebp]
  00216	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00223	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+32

; 68   : 				return pkNewData;

  00229	8b 5d dc	 mov	 ebx, DWORD PTR _pkNewData$3[ebp]
  0022c	eb 0b		 jmp	 SHORT $LN98@OnSetDataP
$LN97@OnSetDataP:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  0022e	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
; File a:\vs\vc\include\vector

; 170  : 		_Ptr += _Off;

  00231	83 c0 fc	 add	 eax, -4			; fffffffcH

; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00234	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CGraphicImageInstance@@2V?$CDynamicPool@VCGraphicImageInstance@@@@A+20, eax
$LN98@OnSetDataP:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 234  : 			pImageInstance->SetImagePointer(pImage);

  00239	ff 75 d8	 push	 DWORD PTR _pImage$1$[ebp]
  0023c	8b cb		 mov	 ecx, ebx
  0023e	89 5d ec	 mov	 DWORD PTR _pImageInstance$4[ebp], ebx
  00241	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
; File a:\vs\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00246	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00249	8d 4d ec	 lea	 ecx, DWORD PTR _pImageInstance$4[ebp]
  0024c	3b c8		 cmp	 ecx, eax
  0024e	73 2e		 jae	 SHORT $LN134@OnSetDataP
  00250	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00252	8d 55 ec	 lea	 edx, DWORD PTR _pImageInstance$4[ebp]
  00255	3b ca		 cmp	 ecx, edx
  00257	77 25		 ja	 SHORT $LN134@OnSetDataP

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00259	8b da		 mov	 ebx, edx
  0025b	2b d9		 sub	 ebx, ecx
  0025d	c1 fb 02	 sar	 ebx, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  00260	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00263	75 09		 jne	 SHORT $LN133@OnSetDataP

; 1248 : 				_Reserve(1);

  00265	6a 01		 push	 1
  00267	8b cf		 mov	 ecx, edi
  00269	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
$LN133@OnSetDataP:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0026e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00271	85 c9		 test	 ecx, ecx
  00273	74 20		 je	 SHORT $LN179@OnSetDataP
  00275	8b 07		 mov	 eax, DWORD PTR [edi]
  00277	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  0027a	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1254 : 		else

  0027c	eb 17		 jmp	 SHORT $LN179@OnSetDataP
$LN134@OnSetDataP:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  0027e	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00281	75 09		 jne	 SHORT $LN131@OnSetDataP

; 1257 : 				_Reserve(1);

  00283	6a 01		 push	 1
  00285	8b cf		 mov	 ecx, edi
  00287	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
$LN131@OnSetDataP:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  0028c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0028f	85 c0		 test	 eax, eax
  00291	74 02		 je	 SHORT $LN179@OnSetDataP
  00293	89 18		 mov	 DWORD PTR [eax], ebx
$LN179@OnSetDataP:
; File a:\vs\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00295	8b 45 d4	 mov	 eax, DWORD PTR _pTextureVector$1$[ebp]

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

  00298	83 c6 04	 add	 esi, 4

; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;

  0029b	83 47 04 04	 add	 DWORD PTR [edi+4], 4

; 205  : 		return (this->_Ptr == _Right._Ptr);

  0029f	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 230  : 		for (std::vector<CGraphicImage*>::iterator itor = rTextureVector.begin(); itor != rTextureVector.end(); ++itor)

  002a2	0f 85 2e ff ff
	ff		 jne	 $LL77@OnSetDataP
$LN194@OnSetDataP:
  002a8	8b 7d e4	 mov	 edi, DWORD PTR tv928[ebp]
  002ab	8b 75 08	 mov	 esi, DWORD PTR _j$1$[ebp]
$LN195@OnSetDataP:
  002ae	8b 5d e8	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN8@OnSetDataP:
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002b1	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  002b4	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002b9	2b 4b 50	 sub	 ecx, DWORD PTR [ebx+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  002bc	46		 inc	 esi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002bd	f7 e9		 imul	 ecx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  002bf	83 c7 30	 add	 edi, 48			; 00000030H
  002c2	89 75 08	 mov	 DWORD PTR _j$1$[ebp], esi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002c5	c1 fa 03	 sar	 edx, 3
  002c8	8b c2		 mov	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  002ca	89 7d e4	 mov	 DWORD PTR tv928[ebp], edi
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  002cd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002d0	03 c2		 add	 eax, edx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 203  : 	for (DWORD j = 0; j < m_TextureInstanceVector.size(); ++j)

  002d2	3b f0		 cmp	 esi, eax
  002d4	0f 82 3a fe ff
	ff		 jb	 $LL9@OnSetDataP
$LN193@OnSetDataP:

; 238  : }

  002da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002e4	59		 pop	 ecx
  002e5	5f		 pop	 edi
  002e6	5e		 pop	 esi
  002e7	5b		 pop	 ebx
  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c2 04 00	 ret	 4
$LN185@OnSetDataP:
; File a:\vs\vc\include\vector

; 1754 : 		_Xlength_error("vector<T> too long");

  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  002f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN198@OnSetDataP:
$LN197@OnSetDataP:
  002f8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z$0:
  00000	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnSetDataPointer@CEffectMeshInstance@@MAEXPAVCEffectElementBase@@@Z ENDP ; CEffectMeshInstance::OnSetDataPointer
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 18   : 		{

  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0000c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 1e		 je	 SHORT $LN8@scalar
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0001c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00023	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  0002a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@scalar:

; 1623 : 		if (this->_Myfirst != pointer())

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	85 c0		 test	 eax, eax
  00036	74 1e		 je	 SHORT $LN21@scalar
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00048	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004f	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN21@scalar:
  00056	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005a	74 09		 je	 SHORT $LN32@scalar
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00062	83 c4 04	 add	 esp, 4
$LN32@scalar:
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCEffectMeshInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CEffectMeshInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXPAPAVCEffectMeshInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXPAPAVCEffectMeshInstance@@0@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXPAPAVCEffectMeshInstance@@0@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBE_NPBQAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBE_NPBQAVCEffectMeshInstance@@@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBE_NPBQAVCEffectMeshInstance@@@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXPAPAVCEffectMeshInstance@@0@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@IAEXI@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEAAPAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEAAPAVCEffectMeshInstance@@XZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEAAPAVCEffectMeshInstance@@XZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::~vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::~vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCEffectMeshInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCEffectMeshInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCEffectMeshInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >::_Vector_val<std::_Simple_types<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >::_Wrap_alloc<std::allocator<CEffectMeshInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@PAVCEffectMeshInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@PAVCEffectMeshInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@SAIABV?$allocator@PAVCEffectMeshInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CEffectMeshInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCEffectMeshInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCEffectMeshInstance@@@std@@QBEIXZ PROC ; std::allocator<CEffectMeshInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCEffectMeshInstance@@@std@@QBEIXZ ENDP ; std::allocator<CEffectMeshInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV3@@Z PROC ; std::allocator<CEffectMeshInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@ABQAV3@@Z ENDP ; std::allocator<CEffectMeshInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEPAPAVCEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z PROC ; std::allocator<CEffectMeshInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCEffectMeshInstance@@@std@@QAEXPAPAVCEffectMeshInstance@@I@Z ENDP ; std::allocator<CEffectMeshInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCEffectMeshInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCEffectMeshInstance@@@std@@QAE@XZ PROC ; std::allocator<CEffectMeshInstance *>::allocator<CEffectMeshInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCEffectMeshInstance@@@std@@QAE@XZ ENDP ; std::allocator<CEffectMeshInstance *>::allocator<CEffectMeshInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z PROC ; CDynamicPool<CEffectMeshInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 110  : 			delete pkData;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pkData$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN3@Delete
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN3@Delete:

; 111  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ENDP ; CDynamicPool<CEffectMeshInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXPAVCEffectMeshInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXPAVCEffectMeshInstance@@@Z PROC ; CDynamicPool<CEffectMeshInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXPAVCEffectMeshInstance@@@Z ENDP ; CDynamicPool<CEffectMeshInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ PROC ; CDynamicPool<CEffectMeshInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00026	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00029	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0002c	75 4f		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0002e	6a 60		 push	 96			; 00000060H
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	85 c0		 test	 eax, eax
  00044	74 09		 je	 SHORT $LN4@Alloc
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 ??0CEffectMeshInstance@@QAE@XZ ; CEffectMeshInstance::CEffectMeshInstance
  0004d	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0004f	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00051	89 45 f0	 mov	 DWORD PTR _pkNewData$3[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00054	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00057	8d 45 f0	 lea	 eax, DWORD PTR _pkNewData$3[ebp]
  0005a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00067	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _pkNewData$3[ebp]

; 74   : 		}

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  0007d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00080	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File a:\vs\vc\include\vector

; 1282 : 		--this->_Mylast;

  00083	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 74   : 		}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5e		 pop	 esi
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ENDP ; CDynamicPool<CEffectMeshInstance>::Alloc
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ PROC ; CDynamicPool<CEffectMeshInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  00008	33 d2		 xor	 edx, edx
  0000a	56		 push	 esi
; File a:\vs\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

  0000b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000e	2b de		 sub	 ebx, esi
  00010	83 c3 03	 add	 ebx, 3
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 38   : 		{

  00013	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  00016	c1 eb 02	 shr	 ebx, 2
  00019	57		 push	 edi
  0001a	33 ff		 xor	 edi, edi
  0001c	3b 71 08	 cmp	 esi, DWORD PTR [ecx+8]
  0001f	0f 47 da	 cmova	 ebx, edx
; File a:\vs\vc\include\algorithm

; 23   : 	for (; _First != _Last; ++_First)

  00022	85 db		 test	 ebx, ebx
  00024	74 15		 je	 SHORT $LN29@Destroy
$LL31@Destroy:

; 24   : 		_Func(*_First);

  00026	ff 36		 push	 DWORD PTR [esi]
  00028	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Delete
  0002d	47		 inc	 edi
  0002e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00031	83 c4 04	 add	 esp, 4
  00034	3b fb		 cmp	 edi, ebx
  00036	75 ee		 jne	 SHORT $LL31@Destroy
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN29@Destroy:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	5f		 pop	 edi
  0003f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00042	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00045	5e		 pop	 esi
  00046	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00049	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 53   : 		}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Destroy@?$CDynamicPool@VCEffectMeshInstance@@@@QAEXXZ ENDP ; CDynamicPool<CEffectMeshInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ PROC	; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN7@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1630 : 			this->_Mylast = pointer();

  00020	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1631 : 			this->_Myend = pointer();

  00027	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN7@CDynamicPo:

; 1623 : 		if (this->_Myfirst != pointer())

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	85 c0		 test	 eax, eax
  00033	74 1e		 je	 SHORT $LN20@CDynamicPo
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1630 : 			this->_Mylast = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1631 : 			this->_Myend = pointer();

  0004c	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN20@CDynamicPo:
  00053	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 26   : 		}

  00054	c3		 ret	 0
??1?$CDynamicPool@VCEffectMeshInstance@@@@UAE@XZ ENDP	; CDynamicPool<CEffectMeshInstance>::~CDynamicPool<CEffectMeshInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ PROC	; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CDynamicPool@VCEffectMeshInstance@@@@6B@

; 16   : 		}

  00006	8b c1		 mov	 eax, ecx
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 483  : 		_Mylast = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 484  : 		_Myend = pointer();

  00016	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 482  : 		_Myfirst = pointer();

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 483  : 		_Mylast = pointer();

  00024	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 484  : 		_Myend = pointer();

  0002b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 14   : 			m_uInitCapacity=0;

  00032	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 15   : 			m_uUsedCapacity=0;

  00039	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 16   : 		}

  00040	c3		 ret	 0
??0?$CDynamicPool@VCEffectMeshInstance@@@@QAE@XZ ENDP	; CDynamicPool<CEffectMeshInstance>::CDynamicPool<CEffectMeshInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?Delete@CEffectMeshInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkMeshInstance$ = 8					; size = 4
?Delete@CEffectMeshInstance@@SAXPAV1@@Z PROC		; CEffectMeshInstance::Delete, COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 21   : 	pkMeshInstance->Destroy();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkMeshInstance$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?Destroy@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Destroy
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  0000e	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 22   : 	ms_kPool.Free(pkMeshInstance);

  00011	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 81   : 			m_kVct_pkFree.push_back(pkData);

  00014	50		 push	 eax
  00015	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  0001a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCEffectMeshInstance@@V?$allocator@PAVCEffectMeshInstance@@@std@@@std@@QAEXABQAVCEffectMeshInstance@@@Z ; std::vector<CEffectMeshInstance *,std::allocator<CEffectMeshInstance *> >::push_back
  0001f	5e		 pop	 esi
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 23   : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?Delete@CEffectMeshInstance@@SAXPAV1@@Z ENDP		; CEffectMeshInstance::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?New@CEffectMeshInstance@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CEffectMeshInstance@@SAPAV1@XZ PROC		; CEffectMeshInstance::New, COMDAT

; 16   : 	return ms_kPool.Alloc();

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A ; CEffectMeshInstance::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ?Alloc@?$CDynamicPool@VCEffectMeshInstance@@@@QAEPAVCEffectMeshInstance@@XZ ; CDynamicPool<CEffectMeshInstance>::Alloc
?New@CEffectMeshInstance@@SAPAV1@XZ ENDP		; CEffectMeshInstance::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\algorithm
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ?DestroySystem@CEffectMeshInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CEffectMeshInstance@@SAXXZ PROC		; CEffectMeshInstance::DestroySystem, COMDAT

; 10   : {

  00000	53		 push	 ebx
  00001	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi
; File a:\vs\vc\include\algorithm

; 33   : 	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

  0000a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4
  00010	2b de		 sub	 ebx, esi
  00012	83 c3 03	 add	 ebx, 3
  00015	c1 eb 02	 shr	 ebx, 2
  00018	57		 push	 edi
  00019	33 ff		 xor	 edi, edi
  0001b	3b 35 08 00 00
	00		 cmp	 esi, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8
  00021	0f 47 d9	 cmova	 ebx, ecx

; 23   : 	for (; _First != _Last; ++_First)

  00024	85 db		 test	 ebx, ebx
  00026	74 2a		 je	 SHORT $LN50@DestroySys
$LL33@DestroySys:

; 24   : 		_Func(*_First);

  00028	ff 36		 push	 DWORD PTR [esi]
  0002a	e8 00 00 00 00	 call	 ?Delete@?$CDynamicPool@VCEffectMeshInstance@@@@KAXPAVCEffectMeshInstance@@@Z ; CDynamicPool<CEffectMeshInstance>::Delete
  0002f	47		 inc	 edi
  00030	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00033	83 c4 04	 add	 esp, 4
  00036	3b fb		 cmp	 edi, ebx
  00038	75 ee		 jne	 SHORT $LL33@DestroySys
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  0003a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+4
  0003f	5f		 pop	 edi
  00040	a3 08 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8, eax
  00045	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  0004a	5e		 pop	 esi
  0004b	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+20, eax
  00050	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 12   : }

  00051	c3		 ret	 0
$LN50@DestroySys:
; File a:\vs\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

  00052	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+16
  00057	5f		 pop	 edi
  00058	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+8, esi
  0005e	5e		 pop	 esi
  0005f	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshInstance@@2V?$CDynamicPool@VCEffectMeshInstance@@@@A+20, eax
  00064	5b		 pop	 ebx
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 12   : }

  00065	c3		 ret	 0
?DestroySystem@CEffectMeshInstance@@SAXXZ ENDP		; CEffectMeshInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ??1CEffectMeshInstance@@UAE@XZ
_TEXT	SEGMENT
__Cat$2 = -20						; size = 1
_this$ = -20						; size = 4
__Alval$3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??1CEffectMeshInstance@@UAE@XZ PROC			; CEffectMeshInstance::~CEffectMeshInstance, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CEffectMeshInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshInstance@@6B@
  00031	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 270  : 	Destroy();

  00038	e8 00 00 00 00	 call	 ?Destroy@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Destroy
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 53   : 			if (m_pObject)

  0003d	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 271  : }

  00040	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 53   : 			if (m_pObject)

  00044	85 c9		 test	 ecx, ecx
  00046	74 0c		 je	 SHORT $LN9@CEffectMes

; 54   : 			{
; 55   : 				m_pObject->Release();

  00048	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0004d	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
$LN9@CEffectMes:
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  00054	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 271  : }

  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File a:\vs\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

  0005b	85 c0		 test	 eax, eax
  0005d	74 30		 je	 SHORT $LN14@CEffectMes
; File a:\vs\vc\include\xmemory0

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0005f	ff 75 ec	 push	 DWORD PTR __Cat$2[ebp]
  00062	8d 4d f3	 lea	 ecx, DWORD PTR __Alval$3[ebp]
  00065	51		 push	 ecx
  00066	ff 76 54	 push	 DWORD PTR [esi+84]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@@std@@YAXPAUSTextureInstance@CEffectMeshInstance@@0AAU?$_Wrap_alloc@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<CEffectMeshInstance::STextureInstance> > >

; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  : 		// TEMPLATE CLASS _Get_voidptr
; 129  : template<class _Alty,
; 130  : 	class _Pointer>
; 131  : 	struct _Get_voidptr
; 132  : 	{	// get void pointer for allocator
; 133  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 134  : 	typedef typename _Alvoid::pointer type;
; 135  : 	};
; 136  : 
; 137  : template<class _Alty,
; 138  : 	class _Ty>
; 139  : 	struct _Get_voidptr<_Alty, _Ty *>
; 140  : 	{	// get raw void pointer for allocator
; 141  : 	typedef void *type;
; 142  : 	};
; 143  : 
; 144  : 		// TEMPLATE CLASS _Is_iterator
; 145  : template<class _Iter>
; 146  : 	struct _Is_iterator
; 147  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 148  : 	{	// tests for reasonable iterator candidate
; 149  : 	};
; 150  : 
; 151  : 		// TEMPLATE STRUCT _Get_first_parameter
; 152  : template<class _Ty>
; 153  : 	struct _Get_first_parameter;
; 154  : 
; 155  : template<template<class, class...> class _Ty,
; 156  : 	class _First,
; 157  : 	class... _Rest>
; 158  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 159  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 160  : 	typedef _First type;
; 161  : 	};
; 162  : 
; 163  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 164  : template<class _Newfirst,
; 165  : 	class _Ty>
; 166  : 	struct _Replace_first_parameter;
; 167  : 
; 168  : template<class _Newfirst,
; 169  : 	template<class, class...> class _Ty,
; 170  : 	class _First,
; 171  : 	class... _Rest>
; 172  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 173  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 174  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 175  : 	};
; 176  : 
; 177  : 		// TEMPLATE STRUCT _Get_element_type
; 178  : template<class _Ty>
; 179  : 	struct _Get_element_type
; 180  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 181  : 		typename _Get_first_parameter<_Uty>::type);
; 182  : 
; 183  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 184  : template<class _Ty>
; 185  : 	struct _Get_ptr_difference_type
; 186  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 187  : 		ptrdiff_t);
; 188  : 
; 189  : 		// TEMPLATE STRUCT _Get_rebind_type
; 190  : template<class _Ty,
; 191  : 	class _Other>
; 192  : 	struct _Get_rebind_type
; 193  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 194  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 195  : 
; 196  : 		// TEMPLATE CLASS pointer_traits
; 197  : template<class _Ty>
; 198  : 	struct pointer_traits
; 199  : 	{	// defines traits for arbitrary pointers
; 200  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 201  : 	typedef _Ty pointer;
; 202  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 203  : 
; 204  : 	template<class _Other>
; 205  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 206  : 
; 207  : 	typedef typename _If<is_void<element_type>::value,
; 208  : 		char&,
; 209  : 		typename add_reference<element_type>::type>::type _Reftype;
; 210  : 
; 211  : 	static pointer pointer_to(_Reftype _Val)
; 212  : 		{	// convert raw reference to pointer
; 213  : 		return (_Ty::pointer_to(_Val));
; 214  : 		}
; 215  : 	};
; 216  : 
; 217  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 218  : template<class _Ty>
; 219  : 	struct pointer_traits<_Ty *>
; 220  : 	{	// defines traits for raw pointers
; 221  : 	typedef _Ty element_type;
; 222  : 	typedef _Ty *pointer;
; 223  : 	typedef ptrdiff_t difference_type;
; 224  : 
; 225  : 	template<class _Other>
; 226  : 		using rebind = _Other *;
; 227  : 
; 228  : 	typedef typename _If<is_void<_Ty>::value,
; 229  : 		char&,
; 230  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 231  : 
; 232  : 	static pointer pointer_to(_Reftype _Val)
; 233  : 		{	// convert raw reference to pointer
; 234  : 		return (_STD addressof(_Val));
; 235  : 		}
; 236  : 	};
; 237  : 
; 238  : 		// TEMPLATE STRUCT _Get_pointer_type
; 239  : template<class _Ty>
; 240  : 	struct _Get_pointer_type
; 241  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 242  : 		typename _Ty::value_type *);
; 243  : 
; 244  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 245  : template<class _Ty>
; 246  : 	struct _Get_const_pointer_type
; 247  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 248  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 249  : 			::template rebind<const typename _Ty::value_type>);
; 250  : 
; 251  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 252  : template<class _Ty>
; 253  : 	struct _Get_void_pointer_type
; 254  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 255  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 256  : 			::template rebind<void>);
; 257  : 
; 258  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 259  : template<class _Ty>
; 260  : 	struct _Get_const_void_pointer_type
; 261  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 262  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 263  : 			::template rebind<const void>);
; 264  : 
; 265  : 		// TEMPLATE STRUCT _Get_difference_type
; 266  : template<class _Ty>
; 267  : 	struct _Get_difference_type
; 268  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 269  : 		typename _Get_ptr_difference_type<
; 270  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_size_type
; 273  : template<class _Ty>
; 274  : 	struct _Get_size_type
; 275  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 276  : 		typename make_unsigned<
; 277  : 			typename _Get_difference_type<_Ty>::type>::type);
; 278  : 
; 279  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 280  : template<class _Ty>
; 281  : 	struct _Get_propagate_on_container_copy
; 282  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 283  : 		false_type);
; 284  : 
; 285  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 286  : template<class _Ty>
; 287  : 	struct _Get_propagate_on_container_move
; 288  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 289  : 		false_type);
; 290  : 
; 291  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 292  : template<class _Ty>
; 293  : 	struct _Get_propagate_on_container_swap
; 294  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 295  : 		false_type);
; 296  : 
; 297  : 		// STRUCT _Alloc_allocate
; 298  : struct _Alloc_allocate
; 299  : 	{	// determines allocator_traits<_Alloc>
; 300  : 		// ::allocate(size_type, const_void_pointer)
; 301  : 
; 302  : 	template<class _Alloc,
; 303  : 		class _Size_type,
; 304  : 		class _Const_void_pointer>
; 305  : 		static auto _Fn(int, _Alloc& _Al,
; 306  : 			_Size_type _Count,
; 307  : 			_Const_void_pointer _Hint)
; 308  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 309  : 		{	// call allocator supplied version
; 310  : 		return (_Al.allocate(_Count, _Hint));
; 311  : 		}
; 312  : 
; 313  : 	template<class _Alloc,
; 314  : 		class _Size_type,
; 315  : 		class _Const_void_pointer>
; 316  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 317  : 			_Size_type _Count,
; 318  : 			_Const_void_pointer)
; 319  : 			-> decltype(_Al.allocate(_Count))
; 320  : 		{	// call default version
; 321  : 		return (_Al.allocate(_Count));
; 322  : 		}
; 323  : 	};
; 324  : 
; 325  : 		// STRUCT _Alloc_construct
; 326  : struct _Alloc_construct
; 327  : 	{	// determines allocator_traits<_Ty>
; 328  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 329  : 
; 330  : 	template<class _Ty,
; 331  : 		class _Objty,
; 332  : 		class... _Types>
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 334  : 			_Types&&... _Args)
; 335  : 			-> decltype(
; 336  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))
; 337  : 		{	// call allocator supplied version
; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}
; 471  : 
; 472  : 
; 473  : 	template<class _Ty>
; 474  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}
; 478  : 
; 479  : 	static size_type max_size(const _Alloc& _Al)
; 480  : 		{	// get maximum size
; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 482  : 		}
; 483  : 
; 484  : 	static _Alloc select_on_container_copy_construction(
; 485  : 		const _Alloc& _Al)
; 486  : 		{	// get allocator to use
; 487  : 		return (_Alloc_select::_Fn(0, _Al));
; 488  : 		}
; 489  : 	};
; 490  : 
; 491  : 		// TEMPLATE CLASS _Allocator_base
; 492  : template<class _Ty>
; 493  : 	struct _Allocator_base
; 494  : 	{	// base class for generic allocators
; 495  : 	typedef _Ty value_type;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 499  : template<class _Ty>
; 500  : 	struct _Allocator_base<const _Ty>
; 501  : 	{	// base class for generic allocators for const _Ty
; 502  : 	typedef _Ty value_type;
; 503  : 	};
; 504  : 
; 505  : 		// TEMPLATE CLASS allocator
; 506  : template<class _Ty>
; 507  : 	class allocator
; 508  : 		: public _Allocator_base<_Ty>
; 509  : 	{	// generic allocator for objects of class _Ty
; 510  : public:
; 511  : 	typedef allocator<_Ty> other;
; 512  : 
; 513  : 	typedef _Allocator_base<_Ty> _Mybase;
; 514  : 	typedef typename _Mybase::value_type value_type;
; 515  : 
; 516  : 	typedef value_type *pointer;
; 517  : 	typedef const value_type *const_pointer;
; 518  : 	typedef void *void_pointer;
; 519  : 	typedef const void *const_void_pointer;
; 520  : 
; 521  : 	typedef value_type& reference;
; 522  : 	typedef const value_type& const_reference;
; 523  : 
; 524  : 	typedef size_t size_type;
; 525  : 	typedef ptrdiff_t difference_type;
; 526  : 
; 527  : 	typedef false_type propagate_on_container_copy_assignment;
; 528  : 	typedef false_type propagate_on_container_move_assignment;
; 529  : 	typedef false_type propagate_on_container_swap;
; 530  : 
; 531  : 	allocator<_Ty> select_on_container_copy_construction() const
; 532  : 		{	// return this allocator
; 533  : 		return (*this);
; 534  : 		}
; 535  : 
; 536  : 	template<class _Other>
; 537  : 		struct rebind
; 538  : 		{	// convert this type to allocator<_Other>
; 539  : 		typedef allocator<_Other> other;
; 540  : 		};
; 541  : 
; 542  : 	pointer address(reference _Val) const _NOEXCEPT
; 543  : 		{	// return address of mutable _Val
; 544  : 		return (_STD addressof(_Val));
; 545  : 		}
; 546  : 
; 547  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 548  : 		{	// return address of nonmutable _Val
; 549  : 		return (_STD addressof(_Val));
; 550  : 		}
; 551  : 
; 552  : 	allocator() _THROW0()
; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}
; 555  : 
; 556  : 	allocator(const allocator<_Ty>&) _THROW0()
; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}
; 559  : 
; 560  : 	template<class _Other>
; 561  : 		allocator(const allocator<_Other>&) _THROW0()
; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}
; 564  : 
; 565  : 	template<class _Other>
; 566  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 567  : 		{	// assign from a related allocator (do nothing)
; 568  : 		return (*this);
; 569  : 		}
; 570  : 
; 571  : 	void deallocate(pointer _Ptr, size_type)
; 572  : 		{	// deallocate object at _Ptr, ignore size
; 573  : 		::operator delete(_Ptr);

  0006f	ff 76 50	 push	 DWORD PTR [esi+80]
  00072	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00077	83 c4 14	 add	 esp, 20			; 00000014H
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  0007a	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 1630 : 			this->_Mylast = pointer();

  00081	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 1631 : 			this->_Myend = pointer();

  00088	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN14@CEffectMes:
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 271  : }

  0008f	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00092	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00096	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  0009b	8b ce		 mov	 ecx, esi
  0009d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a4	e8 00 00 00 00	 call	 ??1CEffectElementBaseInstance@@UAE@XZ ; CEffectElementBaseInstance::~CEffectElementBaseInstance
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5e		 pop	 esi
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CEffectElementBaseInstance@@UAE@XZ ; CEffectElementBaseInstance::~CEffectElementBaseInstance
__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0000e	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 50	 add	 ecx, 80			; 00000050H
  00019	e9 00 00 00 00	 jmp	 ??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
__unwindfunclet$??1CEffectMeshInstance@@UAE@XZ$3:
  0001e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00024	e9 00 00 00 00	 jmp	 ??1?$CRef@VCEffectMesh@@@@QAE@XZ ; CRef<CEffectMesh>::~CRef<CEffectMesh>
__ehhandler$??1CEffectMeshInstance@@UAE@XZ:
  00029	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00030	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEffectMeshInstance@@UAE@XZ
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEffectMeshInstance@@UAE@XZ ENDP			; CEffectMeshInstance::~CEffectMeshInstance
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp
;	COMDAT ??0CEffectMeshInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEffectMeshInstance@@QAE@XZ PROC			; CEffectMeshInstance::CEffectMeshInstance, COMDAT
; _this$ = ecx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEffectMeshInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	e8 00 00 00 00	 call	 ??0CEffectElementBaseInstance@@QAE@XZ ; CEffectElementBaseInstance::CEffectElementBaseInstance
  0002e	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshInstance@@6B@
  0003e	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController
; File a:\vs\vc\include\vector

; 482  : 		_Myfirst = pointer();

  00043	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 483  : 		_Mylast = pointer();

  0004a	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0

; 484  : 		_Myend = pointer();

  00051	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
; File a:\from c\desktop\serwer\source\source client\client\eterlib\ref.h

; 21   : 		{

  00058	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
; File a:\from c\desktop\serwer\source\source client\client\effectlib\effectmeshinstance.cpp

; 265  : 	Initialize();

  0005f	8b ce		 mov	 ecx, esi
  00061	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00065	e8 00 00 00 00	 call	 ?Initialize@CEffectElementBaseInstance@@QAEXXZ ; CEffectElementBaseInstance::Initialize

; 266  : }

  0006a	8b c6		 mov	 eax, esi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5e		 pop	 esi
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CEffectElementBaseInstance@@UAE@XZ ; CEffectElementBaseInstance::~CEffectElementBaseInstance
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0000e	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 50	 add	 ecx, 80			; 00000050H
  00019	e9 00 00 00 00	 jmp	 ??1?$vector@USTextureInstance@CEffectMeshInstance@@V?$allocator@USTextureInstance@CEffectMeshInstance@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >::~vector<CEffectMeshInstance::STextureInstance,std::allocator<CEffectMeshInstance::STextureInstance> >
__unwindfunclet$??0CEffectMeshInstance@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00024	e9 00 00 00 00	 jmp	 ??1?$CRef@VCEffectMesh@@@@QAE@XZ ; CRef<CEffectMesh>::~CRef<CEffectMesh>
__ehhandler$??0CEffectMeshInstance@@QAE@XZ:
  00029	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00030	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEffectMeshInstance@@QAE@XZ
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEffectMeshInstance@@QAE@XZ ENDP			; CEffectMeshInstance::CEffectMeshInstance
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z PROC ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00006	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00009	85 c0		 test	 eax, eax
  0000b	74 1e		 je	 SHORT $LN10@scalar
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00013	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00016	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 1630 : 			this->_Mylast = pointer();

  0001d	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1631 : 			this->_Myend = pointer();

  00024	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN10@scalar:
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  00032	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00036	74 09		 je	 SHORT $LN21@scalar
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 04	 add	 esp, 4
$LN21@scalar:
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??_GSTextureInstance@CEffectMeshInstance@@QAEPAXI@Z ENDP ; CEffectMeshInstance::STextureInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z PROC ; CEffectMeshInstance::STextureInstance::STextureInstance, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFrameController@@6B@
  00032	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00035	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00038	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0003e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00041	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00044	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00047	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0004d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00050	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00053	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00056	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00059	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0005c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0005f	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00062	8d 42 24	 lea	 eax, DWORD PTR [edx+36]
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006c	50		 push	 eax
  0006d	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00070	e8 00 00 00 00	 call	 ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
  00075	8b c6		 mov	 eax, esi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5e		 pop	 esi
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
__ehhandler$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0STextureInstance@CEffectMeshInstance@@QAE@ABU01@@Z ENDP ; CEffectMeshInstance::STextureInstance::STextureInstance
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1STextureInstance@CEffectMeshInstance@@QAE@XZ
_TEXT	SEGMENT
??1STextureInstance@CEffectMeshInstance@@QAE@XZ PROC	; CEffectMeshInstance::STextureInstance::~STextureInstance, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00006	85 c0		 test	 eax, eax
  00008	74 1e		 je	 SHORT $LN7@STextureIn
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00013	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0

; 1630 : 			this->_Mylast = pointer();

  0001a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 1631 : 			this->_Myend = pointer();

  00021	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN7@STextureIn:
  00028	8b ce		 mov	 ecx, esi
  0002a	5e		 pop	 esi
  0002b	e9 00 00 00 00	 jmp	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
??1STextureInstance@CEffectMeshInstance@@QAE@XZ ENDP	; CEffectMeshInstance::STextureInstance::~STextureInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0STextureInstance@CEffectMeshInstance@@QAE@XZ
_TEXT	SEGMENT
??0STextureInstance@CEffectMeshInstance@@QAE@XZ PROC	; CEffectMeshInstance::STextureInstance::STextureInstance, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??0CFrameController@@QAE@XZ ; CFrameController::CFrameController

; 482  : 		_Myfirst = pointer();

  00008	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0000f	8b c6		 mov	 eax, esi

; 483  : 		_Mylast = pointer();

  00011	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0

; 484  : 		_Myend = pointer();

  00018	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
??0STextureInstance@CEffectMeshInstance@@QAE@XZ ENDP	; CEffectMeshInstance::STextureInstance::STextureInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 08	 sub	 eax, 8

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ
_TEXT	SEGMENT
?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front, COMDAT
; _this$ = ecx

; 1224 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1225 : 		}

  00002	c3		 ret	 0
?front@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAEAAV?$CTimeEvent@M@@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$CTimeEvent@M@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImage@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAEAAUSEffectFrameData@CEffectMesh@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAEAAUSEffectFrameData@CEffectMesh@@I@Z PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	03 01		 add	 eax, DWORD PTR [ecx]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAEAAUSEffectFrameData@CEffectMesh@@I@Z ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAEAAUSPTVertex@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAEAAUSPTVertex@@I@Z PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 1210 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAEAAUSPTVertex@@I@Z ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCFrameController@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFrameController@@UAEPAXI@Z PROC			; CFrameController::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CFrameController@@UAE@XZ ; CFrameController::~CFrameController
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCFrameController@@UAEPAXI@Z ENDP			; CFrameController::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0CFrameController@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CFrameController@@QAE@ABV0@@Z PROC			; CFrameController::CFrameController, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CFrameController@@6B@
  0000c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00018	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0001e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00021	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00024	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00027	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0002a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0002d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00030	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00033	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00036	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00039	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0003c	8b c1		 mov	 eax, ecx
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??0CFrameController@@QAE@ABV0@@Z ENDP			; CFrameController::CFrameController
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXPAPAVCGraphicImageInstance@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXPAPAVCGraphicImageInstance@@0@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1781 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXPAPAVCGraphicImageInstance@@0@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1754 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1622 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN1@Tidy
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN1@Tidy:
  00026	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	8b c2		 mov	 eax, edx
  00008	56		 push	 esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	2b c6		 sub	 eax, esi
  0000e	57		 push	 edi

; 1613 : 		if (_Unused_capacity() < _Count)

  0000f	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

  00012	c1 f8 02	 sar	 eax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

  00015	3b c7		 cmp	 eax, edi
  00017	73 49		 jae	 SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00019	2b 31		 sub	 esi, DWORD PTR [ecx]
  0001b	53		 push	 ebx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  0001c	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00021	c1 fe 02	 sar	 esi, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

  00024	8b c3		 mov	 eax, ebx
  00026	2b c6		 sub	 eax, esi
  00028	3b c7		 cmp	 eax, edi
  0002a	72 3c		 jb	 SHORT $LN43@Reserve

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0002c	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	03 f7		 add	 esi, edi

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00030	c1 fa 02	 sar	 edx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00033	8b c2		 mov	 eax, edx
  00035	d1 e8		 shr	 eax, 1
  00037	2b d8		 sub	 ebx, eax
  00039	3b da		 cmp	 ebx, edx
  0003b	5b		 pop	 ebx
  0003c	73 12		 jae	 SHORT $LN27@Reserve
  0003e	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  00040	3b d6		 cmp	 edx, esi
  00042	5f		 pop	 edi
  00043	0f 42 d6	 cmovb	 edx, esi
  00046	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00047	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0004a	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
$LN27@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00050	03 d0		 add	 edx, eax

; 1576 : 		if (_Capacity < _Count)

  00052	3b d6		 cmp	 edx, esi
  00054	5f		 pop	 edi
  00055	0f 42 d6	 cmovb	 edx, esi
  00058	5e		 pop	 esi

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  00059	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1618 : 			}
; 1619 : 		}

  0005c	5d		 pop	 ebp

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

  0005d	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
$LN2@Reserve:
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1618 : 			}
; 1619 : 		}

  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
$LN43@Reserve:

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN45@Reserve:
$LN42@Reserve:
  00072	cc		 int	 3
?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi

; 23   : 	void *_Ptr = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
; File a:\vs\vc\include\vector

; 1587 : 		{	// move to array of exactly _Count elements

  0000b	8b f9		 mov	 edi, ecx
; File a:\vs\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0000d	85 db		 test	 ebx, ebx
  0000f	74 1e		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00011	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00017	77 5d		 ja	 SHORT $LN61@Reallocate
  00019	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	8b f0		 mov	 esi, eax
  00028	83 c4 04	 add	 esp, 4
  0002b	85 f6		 test	 esi, esi
  0002d	74 47		 je	 SHORT $LN61@Reallocate
$LN16@Reallocate:
; File a:\vs\vc\include\vector

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 472  : 	size_t _Count = (size_t)(_Last - _First);

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	2b c1		 sub	 eax, ecx

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00036	83 e0 fc	 and	 eax, -4			; fffffffcH
  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 _memmove
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00041	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File a:\vs\vc\include\xmemory

; 474  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
; File a:\vs\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00046	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00049	2b c1		 sub	 eax, ecx
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN56@Reallocate
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005b	83 c4 04	 add	 esp, 4
$LN56@Reallocate:
; File a:\vs\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

  0005e	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]

; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;

  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00066	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  00069	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0006c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 1609 : 		}

  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
$LN61@Reallocate:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00076	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN63@Reallocate:
$LN60@Reallocate:
  0007b	cc		 int	 3
?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBE_NPBQAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBE_NPBQAVCGraphicImageInstance@@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1584 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1584 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBE_NPBQAVCGraphicImageInstance@@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEII@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b c2		 cmp	 eax, edx
  00018	73 0f		 jae	 SHORT $LN4@Grow_to
  0001a	33 d2		 xor	 edx, edx

; 1576 : 		if (_Capacity < _Count)

  0001c	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0001f	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx

; 1579 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00029	03 d1		 add	 edx, ecx

; 1576 : 		if (_Capacity < _Count)

  0002b	3b 55 08	 cmp	 edx, DWORD PTR __Count$[ebp]
  0002e	0f 42 55 08	 cmovb	 edx, DWORD PTR __Count$[ebp]

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

  00032	8b c2		 mov	 eax, edx

; 1579 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IBEII@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXPAPAVCGraphicImageInstance@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXPAPAVCGraphicImageInstance@@0@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXPAPAVCGraphicImageInstance@@0@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Buy, COMDAT
; _this$ = ecx

; 1546 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN4@Buy

; 1552 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1562 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN4@Buy:

; 1553 : 		else if (max_size() < _Capacity)

  00028	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0002d	77 27		 ja	 SHORT $LN35@Buy
  0002f	57		 push	 edi
; File a:\vs\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00030	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	85 c0		 test	 eax, eax
  00042	74 1c		 je	 SHORT $LN26@Buy
; File a:\vs\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

  00044	89 06		 mov	 DWORD PTR [esi], eax
  00046	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

  00049	03 c7		 add	 eax, edi
  0004b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1560 : 			}
; 1561 : 		return (true);

  0004e	b0 01		 mov	 al, 1
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1562 : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN35@Buy:

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN37@Buy:
$LN26@Buy:
; File a:\vs\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN38@Buy:
$LN34@Buy:
  00065	cc		 int	 3
?_Buy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear, COMDAT
; _this$ = ecx

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1511 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?pop_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

  00000	83 41 04 fc	 add	 DWORD PTR [ecx+4], -4	; fffffffcH

; 1283 : 		}

  00004	c3		 ret	 0
?pop_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN4@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
$LN3@push_back:
; File a:\vs\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN49@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00036	89 01		 mov	 DWORD PTR [ecx], eax
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reserve
$LN1@push_back:
; File a:\vs\vc\include\xmemory0

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN49@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN49@push_back:
; File a:\vs\vc\include\vector

; 1261 : 			++this->_Mylast;

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1262 : 			}
; 1263 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
?back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::back, COMDAT
; _this$ = ecx

; 170  : 		_Ptr += _Off;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 e8 04	 sub	 eax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

  00006	c3		 ret	 0
?back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??A?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@I@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1210 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEAAPAVCGraphicImageInstance@@I@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?empty@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE_NXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::empty, COMDAT
; _this$ = ecx

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 1159 : 		}

  0000a	c3		 ret	 0
?empty@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::max_size, COMDAT
; _this$ = ecx

; 1153 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1154 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::size, COMDAT
; _this$ = ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1149 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end, COMDAT
; _this$ = ecx

; 1039 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end, COMDAT
; _this$ = ecx

; 1034 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin, COMDAT
; _this$ = ecx

; 1029 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		{	// construct with pointer _Parg

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1016 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::capacity, COMDAT
; _this$ = ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1011 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve, COMDAT
; _this$ = ecx

; 999  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1000 : 		if (capacity() < _Count)

  00008	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

  0000b	c1 f8 02	 sar	 eax, 2

; 1000 : 		if (capacity() < _Count)

  0000e	3b c2		 cmp	 eax, edx
  00010	73 11		 jae	 SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

  00012	81 fa ff ff ff
	3f		 cmp	 edx, 1073741823		; 3fffffffH
  00018	77 0d		 ja	 SHORT $LN22@reserve

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0001a	89 55 08	 mov	 DWORD PTR __Count$[ebp], edx

; 1005 : 			}
; 1006 : 		}

  0001d	5d		 pop	 ebp

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

  0001e	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAEXI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN22@reserve:

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN24@reserve:
$LN21@reserve:
  00031	cc		 int	 3
?reserve@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory0
; File a:\vs\vc\include\vector
;	COMDAT ??1?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::~vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 944  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1d		 je	 SHORT $LN3@vector
; File a:\vs\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
; File a:\vs\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1630 : 			this->_Mylast = pointer();

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1631 : 			this->_Myend = pointer();

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN3@vector:
  00026	5e		 pop	 esi

; 945  : 		_Tidy();
; 946  : 		}

  00027	c3		 ret	 0
??1?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::~vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
; File a:\vs\vc\include\xmemory
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 721  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi

; 721  : 		{	// construct by copying _Right

  00008	8b f9		 mov	 edi, ecx

; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 483  : 		_Mylast = pointer();

  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 484  : 		_Myend = pointer();

  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

  0001e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00021	2b 06		 sub	 eax, DWORD PTR [esi]
  00023	c1 f8 02	 sar	 eax, 2

; 722  : 		if (_Buy(_Right.size()))

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@IAE_NI@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::_Buy
  0002c	84 c0		 test	 al, al
  0002e	74 22		 je	 SHORT $LN55@vector

; 61   : 		return (_Unchecked_type(this->_Ptr));

  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File a:\vs\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	2b c1		 sub	 eax, ecx
  00037	c1 f8 02	 sar	 eax, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0003a	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00041	56		 push	 esi
  00042	51		 push	 ecx
  00043	ff 37		 push	 DWORD PTR [edi]
  00045	e8 00 00 00 00	 call	 _memmove
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	03 c6		 add	 eax, esi
; File a:\vs\vc\include\vector

; 725  : 				this->_Myfirst);

  0004f	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN55@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

  00052	8b c7		 mov	 eax, edi
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 681  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 681  : 		}

  00016	c3		 ret	 0
??0?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >, COMDAT
; _this$ = ecx

; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00006	8b c1		 mov	 eax, ecx

; 483  : 		_Mylast = pointer();

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 484  : 		_Myend = pointer();

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

  00016	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >::_Vector_alloc<0,std::_Vec_base_types<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >::_Vector_val<std::_Simple_types<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 848  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 807  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@ABV?$allocator@PAVCGraphicImageInstance@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >, COMDAT
; _this$ = ecx

; 802  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SA?AV?$allocator@PAVCGraphicImageInstance@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SA?AV?$allocator@PAVCGraphicImageInstance@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SA?AV?$allocator@PAVCGraphicImageInstance@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImageInstance@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImageInstance@@@2@@Z PROC ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 736  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@SAIABV?$allocator@PAVCGraphicImageInstance@@@2@@Z ENDP ; std::allocator_traits<std::allocator<CGraphicImageInstance *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVCGraphicImageInstance@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCGraphicImageInstance@@@std@@QBEIXZ PROC ; std::allocator<CGraphicImageInstance *>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 613  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PAVCGraphicImageInstance@@@std@@QBEIXZ ENDP ; std::allocator<CGraphicImageInstance *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV3@@Z PROC ; std::allocator<CGraphicImageInstance *>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 594  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@ABQAV3@@Z ENDP ; std::allocator<CGraphicImageInstance *>::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z PROC ; std::allocator<CGraphicImageInstance *>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 579  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEPAPAVCGraphicImageInstance@@I@Z ENDP ; std::allocator<CGraphicImageInstance *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z PROC ; std::allocator<CGraphicImageInstance *>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 573  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 574  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicImageInstance@@@std@@QAEXPAPAVCGraphicImageInstance@@I@Z ENDP ; std::allocator<CGraphicImageInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@XZ PROC ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAVCGraphicImageInstance@@@std@@QAE@XZ ENDP ; std::allocator<CGraphicImageInstance *>::allocator<CGraphicImageInstance *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAVCGraphicImageInstance@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAVCGraphicImageInstance@@@std@@QBE?AV12@XZ PROC ; std::allocator<CGraphicImageInstance *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 533  : 		return (*this);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$allocator@PAVCGraphicImageInstance@@@std@@QBE?AV12@XZ ENDP ; std::allocator<CGraphicImageInstance *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Free@?$CDynamicPool@VCGraphicImageInstance@@@@QAEXPAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Free@?$CDynamicPool@VCGraphicImageInstance@@@@QAEXPAVCGraphicImageInstance@@@Z PROC ; CDynamicPool<CGraphicImageInstance>::Free, COMDAT
; _this$ = ecx

; 76   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 77   : #ifdef DYNAMIC_POOL_STRICT
; 78   : 			assert(__IsValidData(pkData));
; 79   : 			assert(!__IsFreeData(pkData));
; 80   : #endif
; 81   : 			m_kVct_pkFree.push_back(pkData);

  00003	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00006	83 c1 10	 add	 ecx, 16			; 00000010H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back

; 82   : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?Free@?$CDynamicPool@VCGraphicImageInstance@@@@QAEXPAVCGraphicImageInstance@@@Z ENDP ; CDynamicPool<CGraphicImageInstance>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
; File a:\vs\vc\include\vector
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
_pkNewData$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ PROC ; CDynamicPool<CGraphicImageInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File a:\vs\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

  00026	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00029	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  0002c	75 4f		 jne	 SHORT $LN1@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0002e	6a 20		 push	 32			; 00000020H
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	85 c0		 test	 eax, eax
  00044	74 09		 je	 SHORT $LN4@Alloc
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0004d	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0004f	33 c0		 xor	 eax, eax
$LN5@Alloc:
  00051	89 45 f0	 mov	 DWORD PTR _pkNewData$3[ebp], eax

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00054	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00057	8d 45 f0	 lea	 eax, DWORD PTR _pkNewData$3[ebp]
  0005a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicImageInstance@@V?$allocator@PAVCGraphicImageInstance@@@std@@@std@@QAEXABQAVCGraphicImageInstance@@@Z ; std::vector<CGraphicImageInstance *,std::allocator<CGraphicImageInstance *> >::push_back

; 67   : 				++m_uUsedCapacity;

  00067	ff 46 20	 inc	 DWORD PTR [esi+32]

; 68   : 				return pkNewData;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _pkNewData$3[ebp]

; 74   : 		}

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN1@Alloc:

; 69   : 			}
; 70   : 
; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  0007d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00080	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
; File a:\vs\vc\include\vector

; 1282 : 		--this->_Mylast;

  00083	83 46 14 fc	 add	 DWORD PTR [esi+20], -4	; fffffffcH
; File a:\from c\desktop\serwer\source\source client\client\eterlib\pool.h

; 74   : 		}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5e		 pop	 esi
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCGraphicImageInstance@@@@QAEPAVCGraphicImageInstance@@XZ ENDP ; CDynamicPool<CGraphicImageInstance>::Alloc
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ PROC ; CSingleton<CResourceManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ENDP ; CSingleton<CResourceManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ PROC ; CSingleton<CStateManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCStateManager@@@@SAAAVCStateManager@@XZ ENDP ; CSingleton<CStateManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z
_TEXT	SEGMENT
_pOut$ = 8						; size = 4
?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z PROC	; D3DXMatrixIdentity, COMDAT

; 1510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1511 : #ifdef D3DX_DEBUG
; 1512 :     if(!pOut)
; 1513 :         return NULL;
; 1514 : #endif
; 1515 : 
; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00006	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  0000d	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
  00014	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0001b	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00022	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  00029	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  00030	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00037	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  0003e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00045	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0004c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00053	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0005a	c7 40 3c 00 00
	80 3f		 mov	 DWORD PTR [eax+60], 1065353216 ; 3f800000H
  00061	c7 40 28 00 00
	80 3f		 mov	 DWORD PTR [eax+40], 1065353216 ; 3f800000H
  00068	c7 40 14 00 00
	80 3f		 mov	 DWORD PTR [eax+20], 1065353216 ; 3f800000H
  0006f	c7 00 00 00 80
	3f		 mov	 DWORD PTR [eax], 1065353216 ; 3f800000H

; 1522 :     return pOut;
; 1523 : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?D3DXMatrixIdentity@@YAPAUD3DXMATRIX@@PAU1@@Z ENDP	; D3DXMatrixIdentity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_pOut$ = 8						; size = 4
_pV1$ = 12						; size = 4
_pV2$ = 16						; size = 4
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z PROC	; D3DXVec3Cross, COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1270 :     D3DXVECTOR3 v;
; 1271 : 
; 1272 : #ifdef D3DX_DEBUG
; 1273 :     if(!pOut || !pV1 || !pV2)
; 1274 :         return NULL;
; 1275 : #endif
; 1276 : 
; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00006	8b 45 10	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _pV1$[ebp]
  0000c	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]
  00011	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00016	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0001b	f3 0f 59 79 04	 mulss	 xmm7, DWORD PTR [ecx+4]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00020	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00024	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00028	0f 28 cb	 movaps	 xmm1, xmm3
  0002b	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  00030	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00034	f3 0f 59 59 04	 mulss	 xmm3, DWORD PTR [ecx+4]
  00039	0f 28 c2	 movaps	 xmm0, xmm2
  0003c	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00041	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]

; 1280 : 
; 1281 :     *pOut = v;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pOut$[ebp]
  00049	f3 0f 5c c8	 subss	 xmm1, xmm0
  0004d	f3 0f 5c d3	 subss	 xmm2, xmm3
  00051	0f 14 f9	 unpcklps xmm7, xmm1
  00054	66 0f d6 38	 movq	 QWORD PTR [eax], xmm7
  00058	f3 0f 11 55 fc	 movss	 DWORD PTR _v$[ebp+8], xmm2
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _v$[ebp+8]
  00060	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1282 :     return pOut;
; 1283 : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?D3DXVec3Cross@@YAPAUD3DXVECTOR3@@PAU1@PBU1@1@Z ENDP	; D3DXVec3Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_pV1$ = 8						; size = 4
_pV2$ = 12						; size = 4
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z PROC		; D3DXVec3Dot, COMDAT

; 1258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1259 : #ifdef D3DX_DEBUG
; 1260 :     if(!pV1 || !pV2)
; 1261 :         return 0.0f;
; 1262 : #endif
; 1263 : 
; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pV1$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	d9 01		 fld	 DWORD PTR [ecx]
  00011	d8 08		 fmul	 DWORD PTR [eax]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00018	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001b	de c1		 faddp	 ST(1), ST(0)

; 1265 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?D3DXVec3Dot@@YAMPBUD3DXVECTOR3@@0@Z ENDP		; D3DXVec3Dot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv160 = 8						; size = 4
_pV$ = 8						; size = 4
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z PROC		; D3DXVec3LengthSq, COMDAT

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1248 : #ifdef D3DX_DEBUG
; 1249 :     if(!pV)
; 1250 :         return 0.0f;
; 1251 : #endif
; 1252 : 
; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pV$[ebp]
  00006	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0000b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0000f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00014	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00018	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0001c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00020	f3 0f 58 d1	 addss	 xmm2, xmm1
  00024	f3 0f 58 d0	 addss	 xmm2, xmm0
  00028	f3 0f 11 55 08	 movss	 DWORD PTR tv160[ebp], xmm2
  0002d	d9 45 08	 fld	 DWORD PTR tv160[ebp]

; 1254 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?D3DXVec3LengthSq@@YAMPBUD3DXVECTOR3@@@Z ENDP		; D3DXVec3LengthSq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??BD3DXCOLOR@@QBEKXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??BD3DXCOLOR@@QBEKXZ PROC				; D3DXCOLOR::operator unsigned long, COMDAT
; _this$ = ecx

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00004	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0000c	0f 57 c9	 xorps	 xmm1, xmm1
  0000f	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx
  0001b	57		 push	 edi
  0001c	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  0001f	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00023	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0002a	72 07		 jb	 SHORT $LN5@operator
  0002c	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00031	eb 2b		 jmp	 SHORT $LN4@operator
$LN5@operator:
  00033	0f 2f c8	 comiss	 xmm1, xmm0
  00036	72 04		 jb	 SHORT $LN3@operator
  00038	33 db		 xor	 ebx, ebx
  0003a	eb 22		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0003c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00040	f3 0f 58 c4	 addss	 xmm0, xmm4
  00044	e8 00 00 00 00	 call	 __ftoui3
  00049	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00051	8b d8		 mov	 ebx, eax
  00053	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0005b	0f 57 c9	 xorps	 xmm1, xmm1
$LN4@operator:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0005e	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00063	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0006a	72 07		 jb	 SHORT $LN9@operator
  0006c	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  00071	eb 18		 jmp	 SHORT $LN8@operator
$LN9@operator:
  00073	0f 2f c8	 comiss	 xmm1, xmm0
  00076	72 04		 jb	 SHORT $LN7@operator
  00078	33 ff		 xor	 edi, edi
  0007a	eb 0f		 jmp	 SHORT $LN8@operator
$LN7@operator:
  0007c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00080	f3 0f 58 c4	 addss	 xmm0, xmm4
  00084	e8 00 00 00 00	 call	 __ftoui3
  00089	8b f8		 mov	 edi, eax
$LN8@operator:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0008b	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00090	0f 57 c9	 xorps	 xmm1, xmm1
  00093	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0009a	72 07		 jb	 SHORT $LN13@operator
  0009c	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  000a1	eb 23		 jmp	 SHORT $LN12@operator
$LN13@operator:
  000a3	0f 2f c8	 comiss	 xmm1, xmm0
  000a6	72 04		 jb	 SHORT $LN11@operator
  000a8	33 f6		 xor	 esi, esi
  000aa	eb 1a		 jmp	 SHORT $LN12@operator
$LN11@operator:
  000ac	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bc	e8 00 00 00 00	 call	 __ftoui3
  000c1	8b f0		 mov	 esi, eax
  000c3	0f 57 c9	 xorps	 xmm1, xmm1
$LN12@operator:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000c9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000ce	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000d5	72 07		 jb	 SHORT $LN17@operator
  000d7	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000dc	eb 1e		 jmp	 SHORT $LN16@operator
$LN17@operator:
  000de	0f 2f c8	 comiss	 xmm1, xmm0
  000e1	72 04		 jb	 SHORT $LN15@operator
  000e3	33 c0		 xor	 eax, eax
  000e5	eb 15		 jmp	 SHORT $LN16@operator
$LN15@operator:
  000e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000ef	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000f7	e8 00 00 00 00	 call	 __ftoui3
$LN16@operator:

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  000fc	c1 e0 08	 shl	 eax, 8
  000ff	0b c3		 or	 eax, ebx
  00101	c1 e0 08	 shl	 eax, 8
  00104	0b c7		 or	 eax, edi
  00106	c1 e0 08	 shl	 eax, 8
  00109	5f		 pop	 edi
  0010a	0b c6		 or	 eax, esi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx

; 937  : }

  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
??BD3DXCOLOR@@QBEKXZ ENDP				; D3DXCOLOR::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXCOLOR@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0D3DXCOLOR@@QAE@MMMM@Z PROC				; D3DXCOLOR::D3DXCOLOR, COMDAT
; _this$ = ecx

; 919  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 920  :     r = fr;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fr$[ebp]

; 921  :     g = fg;
; 922  :     b = fb;
; 923  :     a = fa;
; 924  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fb$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00027	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??0D3DXCOLOR@@QAE@MMMM@Z ENDP				; D3DXCOLOR::D3DXCOLOR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXQUATERNION@@QAE@MMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
_fw$ = 20						; size = 4
??0D3DXQUATERNION@@QAE@MMMM@Z PROC			; D3DXQUATERNION::D3DXQUATERNION, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 667  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 668  :     y = fy;
; 669  :     z = fz;
; 670  :     w = fw;
; 671  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fw$[ebp]
  00027	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??0D3DXQUATERNION@@QAE@MMMM@Z ENDP			; D3DXQUATERNION::D3DXQUATERNION
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  :     D3DXMATRIX matT;
; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00003	ff 75 0c	 push	 DWORD PTR _mat$[ebp]
  00006	51		 push	 ecx
  00007	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??8D3DXVECTOR3@@QBEHABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??8D3DXVECTOR3@@QBEHABU0@@Z PROC			; D3DXVECTOR3::operator==, COMDAT
; _this$ = ecx

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  :     return x == v.x && y == v.y && z == v.z;

  00003	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	0f 2e 02	 ucomiss xmm0, DWORD PTR [edx]
  0000d	9f		 lahf
  0000e	f6 c4 44	 test	 ah, 68			; 00000044H
  00011	7a 27		 jp	 SHORT $LN3@operator
  00013	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00018	0f 2e 42 04	 ucomiss xmm0, DWORD PTR [edx+4]
  0001c	9f		 lahf
  0001d	f6 c4 44	 test	 ah, 68			; 00000044H
  00020	7a 18		 jp	 SHORT $LN3@operator
  00022	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00027	0f 2e 42 08	 ucomiss xmm0, DWORD PTR [edx+8]
  0002b	9f		 lahf
  0002c	f6 c4 44	 test	 ah, 68			; 00000044H
  0002f	7a 09		 jp	 SHORT $LN3@operator
  00031	b8 01 00 00 00	 mov	 eax, 1

; 291  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN3@operator:

; 290  :     return x == v.x && y == v.y && z == v.z;

  0003a	33 c0		 xor	 eax, eax

; 291  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8D3DXVECTOR3@@QBEHABU0@@Z ENDP			; D3DXVECTOR3::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??GD3DXVECTOR3@@QBE?AU0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??GD3DXVECTOR3@@QBE?AU0@XZ PROC				; D3DXVECTOR3::operator-, COMDAT
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  00006	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  0000e	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00012	0f 57 c1	 xorps	 xmm0, xmm1

; 180  :     x = fx;

  00015	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  00019	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  0001e	0f 57 c1	 xorps	 xmm0, xmm1

; 181  :     y = fy;

  00021	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 249  :     return D3DXVECTOR3(-x, -y, -z);

  00026	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0002b	0f 57 c1	 xorps	 xmm0, xmm1

; 182  :     z = fz;

  0002e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 250  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??GD3DXVECTOR3@@QBE?AU0@XZ ENDP				; D3DXVECTOR3::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z PROC			; D3DXVECTOR3::operator-=, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  :     x -= v.x;

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  0000a	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0000e	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 214  :     y -= v.y;

  00012	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00017	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0001c	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 215  :     z -= v.z;

  00021	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  00026	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]

; 216  :     return *this;

  0002b	8b c1		 mov	 eax, ecx
  0002d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0

; 217  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??ZD3DXVECTOR3@@QAEAAU0@ABU0@@Z ENDP			; D3DXVECTOR3::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]

; 181  :     y = fy;
; 182  :     z = fz;
; 183  : }

  00008	8b c1		 mov	 eax, ecx
  0000a	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  0000e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00013	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00018	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\from c\desktop\serwer\source\source client\client\eterbase\singleton.h
;	COMDAT ?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ PROC	; CSingleton<CTimer>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCTimer@@@@SAAAVCTimer@@XZ ENDP	; CSingleton<CTimer>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File a:\vs\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 08	 sub	 esp, 8
  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

  0000e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00011	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00016	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001a	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv68[esp+8], xmm0
  00020	d9 44 24 04	 fld	 DWORD PTR tv68[esp+8]

; 776  : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	4e		 dec	 esi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	57		 push	 edi
  0000f	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b cf		 mov	 ecx, edi
  00014	ff d3		 call	 ebx
  00016	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00019	4e		 dec	 esi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
